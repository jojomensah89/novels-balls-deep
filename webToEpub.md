Directory structure:
└── dteviot-webtoepub/
    ├── readme.md
    ├── CONTRIBUTING.md
    ├── LICENSE.md
    ├── package.json
    ├── doc/
    │   ├── CodeProjectNotes.html
    │   ├── License.html
    │   └── ToDo.htm
    ├── eslint/
    │   ├── pack.js
    │   ├── release.js
    │   └── .eslintrc.js
    ├── plugin/
    │   ├── manifest.json
    │   ├── _locales/
    │   │   ├── en/
    │   │   │   └── messages.json
    │   │   ├── ru/
    │   │   │   └── messages.json
    │   │   ├── uk/
    │   │   │   └── messages.json
    │   │   └── vi/
    │   │       └── messages.json
    │   ├── css/
    │   │   ├── alwaysDark.css
    │   │   ├── autoDark.css
    │   │   └── default.css
    │   └── js/
    │       ├── ChapterUrlsUI.js
    │       ├── ContentScript.js
    │       ├── CoverImageUI.js
    │       ├── DebugUtil.js
    │       ├── DefaultParserUI.js
    │       ├── Download.js
    │       ├── EpubItem.js
    │       ├── EpubItemSupplier.js
    │       ├── EpubMetaInfo.js
    │       ├── EpubPacker.js
    │       ├── ErrorLog.js
    │       ├── Firefox.js
    │       ├── FootnoteExtractor.js
    │       ├── HttpClient.js
    │       ├── ImageCollector.js
    │       ├── Imgur.js
    │       ├── main.js
    │       ├── Parser.js
    │       ├── ParserFactory.js
    │       ├── ProgressBar.js
    │       ├── ReadingList.js
    │       ├── UIText.js
    │       ├── UserPreferences.js
    │       ├── Util.js
    │       ├── debugging/
    │       │   └── FakeParser.js
    │       └── parsers/
    │           ├── 230BookParser.js
    │           ├── 27kParser.js
    │           ├── 4kswParser.js
    │           ├── 69shuParser.js
    │           ├── 888novelParser.js
    │           ├── 88xiaoshuoParser.js
    │           ├── ActiveTranslationsParser.js
    │           ├── AdultfanfictionParser.js
    │           ├── AerialrainParser.js
    │           ├── AkknovelParser.js
    │           ├── AlphapolisParser.js
    │           ├── AmoryaoiParser.js
    │           ├── AnythingNovelParser.js
    │           ├── AppYoruWorldParser.js
    │           ├── ArchiveOfOurOwnParser.js
    │           ├── AsianfanficsParser.js
    │           ├── AsianHobbyistParser.js
    │           ├── AsianovelParser.js
    │           ├── AsstrParser.js
    │           ├── BabelChainParser.js
    │           ├── BakaTsukiParser.js
    │           ├── BakaTsukiSeriesPageParser.js
    │           ├── BetwixtedbutterflyParser.js
    │           ├── BiqugetwParser.js
    │           ├── BlogspotParser.js
    │           ├── BnatranslationsParser.js
    │           ├── Book18Parser.js
    │           ├── BookswithqianyaParser.js
    │           ├── Booktoki152Parser.js
    │           ├── BotitranslationParser.js
    │           ├── BoxnovelOrgParser.js
    │           ├── BoyloveParser.js
    │           ├── Bqg225Parser.js
    │           ├── Brittanypage43Parser.js
    │           ├── BuntlsParser.js
    │           ├── CangjiParser.js
    │           ├── CClawTranslationsParser.js
    │           ├── ChaleuriaParser.js
    │           ├── ChichipephParser.js
    │           ├── ChickengegeParser.js
    │           ├── ChineseFantasyNovelsParser.js
    │           ├── ChosentwofanficParser.js
    │           ├── ChrysanthemumgardenParser.js
    │           ├── ChyoaParser.js
    │           ├── ComrademaoParser.js
    │           ├── CoronatranslationParser.js
    │           ├── CreativeNovelsParser.js
    │           ├── CrimsontranslationsParser.js
    │           ├── CzbooksParser.js
    │           ├── DaoDivineTlParser.js
    │           ├── DarkNovelsParser.js
    │           ├── DasuitlParser.js
    │           ├── DdxsParser.js
    │           ├── DefaultParser.js
    │           ├── DeviantArtParser.js
    │           ├── DiurnisParser.js
    │           ├── DudushugeParser.js
    │           ├── DummynovelsParser.js
    │           ├── EdanglarstranslationsParser.js
    │           ├── EightMusesParser.js
    │           ├── EmpirenovelParser.js
    │           ├── EngnovelParser.js
    │           ├── ErofusParser.js
    │           ├── EstarParser.js
    │           ├── ExiledrebelsscanlationsParser.js
    │           ├── FanFicParadiseParser.js
    │           ├── FanFictionParser.js
    │           ├── FanficusParser.js
    │           ├── FastNovelParser.js
    │           ├── FenrirealmParser.js
    │           ├── Ffxs8Parser.js
    │           ├── FicbookParser.js
    │           ├── FictioneerParser.js
    │           ├── FictionhuntParser.js
    │           ├── FictionManiaParser.js
    │           ├── FicwadParser.js
    │           ├── FimfictionParser.js
    │           ├── FlyingLinesParser.js
    │           ├── FoxaholicParser.js
    │           ├── FoxtellerParser.js
    │           ├── FreelightnovelParser.js
    │           ├── FreeWebNovelParser.js
    │           ├── FuhuzzParser.js
    │           ├── FullnovelParser.js
    │           ├── GamefaqsGamespotParser.js
    │           ├── GenesiStudioParser.js
    │           ├── GlobalNovelpiaParser.js
    │           ├── GoodNovelParser.js
    │           ├── GraverobbertlParser.js
    │           ├── GravityNovelsParser.js
    │           ├── GravityTalesParser.js
    │           ├── GunnerkriggParser.js
    │           ├── GutenbergDEParser.js
    │           ├── GzbpParser.js
    │           ├── HelheimscansParser.js
    │           ├── HellpingParser.js
    │           ├── HentaiFoundryParser.js
    │           ├── HiscensionParser.js
    │           ├── HostednovelParser.js
    │           ├── Hui3rParser.js
    │           ├── IdleturtletranslationsParser.js
    │           ├── IdnovelmyidParser.js
    │           ├── ImgurParser.js
    │           ├── IndomtlParser.js
    │           ├── IndowebnovelParser.js
    │           ├── InkittParser.js
    │           ├── InoveltranslationParser.js
    │           ├── IsekaiScanParser.js
    │           ├── IsotlsParser.js
    │           ├── IxdzsParser.js
    │           ├── JadeRabbitParser.js
    │           ├── JadeScrollsParser.js
    │           ├── JaptemParser.js
    │           ├── JjwxcParser.js
    │           ├── JonaxxstoriesParser.js
    │           ├── JpmtlParser.js
    │           ├── KakaoParser.js
    │           ├── KakuyomuParser.js
    │           ├── KariStudioParser.js
    │           ├── KaystlsParser.js
    │           ├── KemonopartyParser.js
    │           ├── KobatochanParser.js
    │           ├── KrytykalParser.js
    │           ├── LanrySpaceParser.js
    │           ├── LeafStudioParser.js
    │           ├── LibersparkParser.js
    │           ├── Libri7Parser.js
    │           ├── LightNovelBastionParser.js
    │           ├── LightnovelboxParser.js
    │           ├── LightnovelfrParser.js
    │           ├── LightnovelreaderParser.js
    │           ├── LightnovelreadParser.js
    │           ├── LightnovelsmeParser.js
    │           ├── LightNovelsTranslationsParser.js
    │           ├── LightNovelWorldParser.js
    │           ├── LiteroticaParser.js
    │           ├── LnmtlParser.js
    │           ├── LoreNovelsParser.js
    │           ├── MachineTranslationParser.js
    │           ├── MadaraParser.js
    │           ├── MadnovelParser.js
    │           ├── MagicWizardsParser.js
    │           ├── MandarinducktalesParser.js
    │           ├── MangadexParser.js
    │           ├── MangaHereParser.js
    │           ├── MangakakalotParser.js
    │           ├── MangallamaParser.js
    │           ├── ManganeloParser.js
    │           ├── ManganovParser.js
    │           ├── MangaReadParser.js
    │           ├── ManhwadenParser.js
    │           ├── ManhwatopParser.js
    │           ├── Marx2maoParser.js
    │           ├── MarxistsCNParser.js
    │           ├── MayanovelParser.js
    │           ├── McStoriesParser.js
    │           ├── MeionovelParser.js
    │           ├── MetanovelParser.js
    │           ├── MidnightramblesParser.js
    │           ├── MimihuiParser.js
    │           ├── MMyWwuxiaWorldParser.js
    │           ├── MoonDaisyParser.js
    │           ├── MoonQuillParser.js
    │           ├── MottruyenParser.js
    │           ├── MtlarchiveParser.js
    │           ├── MtledNovelsParser.js
    │           ├── MtlnationParser.js
    │           ├── MtlnovelsParser.js
    │           ├── MtlreaderParser.js
    │           ├── MtnovelParser.js
    │           ├── MuggleNetParser.js
    │           ├── MvlempyrParser.js
    │           ├── MydramanovelParser.js
    │           ├── MyxlsParser.js
    │           ├── MznovelsParser.js
    │           ├── NanodesuParser.js
    │           ├── NanomashinonlineParser.js
    │           ├── NeobookParser.js
    │           ├── NepustationParser.js
    │           ├── NineHeavensParser.js
    │           ├── NobadnovelParser.js
    │           ├── NoblemtlParser.js
    │           ├── Novel543Parser.js
    │           ├── NovelAllParser.js
    │           ├── NovelcoolParser.js
    │           ├── NovelCrushParser.js
    │           ├── NovelFeverParser.js
    │           ├── NovelfullParser.js
    │           ├── NovelgoParser.js
    │           ├── NovelgreatParser.js
    │           ├── NovelhallParser.js
    │           ├── NovelhiParser.js
    │           ├── NovelholdParser.js
    │           ├── NovelightParser.js
    │           ├── NovelinguaParser.js
    │           ├── NovelmaniaParser.js
    │           ├── NovelmaoParser.js
    │           ├── NovelmediumParser.js
    │           ├── NovelNaverParser.js
    │           ├── NovelOnlineFreeParser.js
    │           ├── NovelonomiconParser.js
    │           ├── NovelpassionParser.js
    │           ├── NovelplexParser.js
    │           ├── NovelsectParser.js
    │           ├── NovelsemperorParser.js
    │           ├── NovelsfullParser.js
    │           ├── NovelshubParser.js
    │           ├── NovelsOnlineParser.js
    │           ├── NovelsplParser.js
    │           ├── NovelSpreadParser.js
    │           ├── NovelsquareParser.js
    │           ├── NovelsRockParser.js
    │           ├── NoveltoonParser.js
    │           ├── NoveltranslatedbycParser.js
    │           ├── NovelUniverseParser.js
    │           ├── NovelUpdatesOnlineParser.js
    │           ├── NovelUpdatesParser.js
    │           ├── NovelversetranslationsParser.js
    │           ├── NovicetranslationsParser.js
    │           ├── NrvnqsrParser.js
    │           ├── NtruyenParser.js
    │           ├── NyahFanfictionParser.js
    │           ├── NyantlParser.js
    │           ├── OctopiiParser.js
    │           ├── OldranobelibParser.js
    │           ├── OnlinenovelbookParser.js
    │           ├── OntimestoryParser.js
    │           ├── OssantlParser.js
    │           ├── PandaNovelParser.js
    │           ├── PatreonParser.js
    │           ├── PawreadParser.js
    │           ├── PeachblossomcodexParser.js
    │           ├── PeachpittingParser.js
    │           ├── PeachpuffParser.js
    │           ├── PeachygardensBlogspotParser.js
    │           ├── PindangscansParser.js
    │           ├── PowanjuanParser.js
    │           ├── PtwxzParser.js
    │           ├── PuretlParser.js
    │           ├── QidianParser.js
    │           ├── QinxiaoshuoParser.js
    │           ├── QqxsParser.js
    │           ├── Quanben5Parser.js
    │           ├── QuanbenParser.js
    │           ├── QueenrosenovelblogspotParser.js
    │           ├── QuotevParser.js
    │           ├── RaeitranslationsParser.js
    │           ├── RainOfSnowParser.js
    │           ├── RandomtranslatorParser.js
    │           ├── RanobesParser.js
    │           ├── ReadComicOnlineParser.js
    │           ├── ReaderNovelParser.js
    │           ├── ReadhiveParser.js
    │           ├── ReadindpiaParser.js
    │           ├── ReadLightNovelCcParser.js
    │           ├── ReadLightNovelParser.js
    │           ├── ReadnoveldailyParser.js
    │           ├── ReadnovelfullorgParser.js
    │           ├── ReadNovelFullParser.js
    │           ├── ReadnovelmtlParser.js
    │           ├── ReadwnParser.js
    │           ├── RebirthOnline.js
    │           ├── RedditParser.js
    │           ├── ReLibraryParser.js
    │           ├── RequiemtlsParser.js
    │           ├── RoyalRoadParser.js
    │           ├── RtdMoeParser.js
    │           ├── RtenzoParser.js
    │           ├── RubymaybetranslationsParser.js
    │           ├── RulateParser.js
    │           ├── RuversParser.js
    │           ├── SangtacvietParser.js
    │           ├── ScribblehubParser.js
    │           ├── SecondlifetranslationsParser.js
    │           ├── SemprotParser.js
    │           ├── SexStoriesParser.js
    │           ├── ShanghaifantasyParser.js
    │           ├── ShikkakutranslationsParser.js
    │           ├── ShinningnoveltranslationsParser.js
    │           ├── ShinsoriParser.js
    │           ├── ShintranslationsParser.js
    │           ├── ShirokunsParser.js
    │           ├── ShitouxsParser.js
    │           ├── ShmtranslationsParser.js
    │           ├── ShubaowbParser.js
    │           ├── ShubaowParser.js
    │           ├── Shw5Parser.js
    │           ├── SitesGoogleParser.js
    │           ├── Sjks88Parser.js
    │           ├── SjuukanshuParser.js
    │           ├── SkydemonorderParser.js
    │           ├── SnoutandcoParser.js
    │           ├── SnowyCodexParser.js
    │           ├── SonakoParser.js
    │           ├── SoverseParser.js
    │           ├── SpacebattlesParser.js
    │           ├── SpiritfanfictionParser.js
    │           ├── SspaiParser.js
    │           ├── StarlightstreamParser.js
    │           ├── StellarRealmParser.js
    │           ├── StocxParser.js
    │           ├── StorySeedlingParser.js
    │           ├── SweekParser.js
    │           ├── SyosetuParser.js
    │           ├── SystemTranslationParser.js
    │           ├── Taffygirl13Parser.js
    │           ├── TapasParser.js
    │           ├── TapreadParser.js
    │           ├── TeanovelParser.js
    │           ├── TeenficParser.js
    │           ├── Template.js
    │           ├── TigertranslationsParser.js
    │           ├── TimotxtParser.js
    │           ├── TitannovelParser.js
    │           ├── ToctruyenParser.js
    │           ├── TomotranslationsParser.js
    │           ├── TongrenquanParser.js
    │           ├── TranslationChickenParser.js
    │           ├── TravistranslationsParser.js
    │           ├── TruyenfullParser.js
    │           ├── TruyenFullVisionParser.js
    │           ├── TruyenParser.js
    │           ├── TruyenyyParser.js
    │           ├── TrxsParser.js
    │           ├── TumblrParser.js
    │           ├── TwkanParser.js
    │           ├── UaaParser.js
    │           ├── UltimaguilParser.js
    │           ├── UnlimitedNovelFailuresParser.js
    │           ├── UntamedAlleyParser.js
    │           ├── VelvetReverieParser.js
    │           ├── VipNovelParser.js
    │           ├── VolarenovelsParser.js
    │           ├── VynovelParser.js
    │           ├── WanderinginnParser.js
    │           ├── WatashiwasugoidesuParser.js
    │           ├── WattpadParser.js
    │           ├── WebNovelOnlineParser.js
    │           ├── Wenku8Parser.js
    │           ├── WetriedTlsParser.js
    │           ├── WfxsParser.js
    │           ├── WikipediaParser.js
    │           ├── WixParser.js
    │           ├── WLPublishingParser.js
    │           ├── WnmtlOrgParser.js
    │           ├── WnmtlParser.js
    │           ├── WoopreadParser.js
    │           ├── WordexcerptParser.js
    │           ├── WordpressBaseParser.js
    │           ├── WorldnovelOnlineParser.js
    │           ├── WtnovelsParser.js
    │           ├── WtrlabParser.js
    │           ├── WuxiaBlogParser.js
    │           ├── WuxiacityParser.js
    │           ├── WuxiaworldCoParser.js
    │           ├── WuxiaworldeuParser.js
    │           ├── WuxiaworldParser.js
    │           ├── WuxiaworldWorldParser.js
    │           ├── WxscsPaser.js
    │           ├── XbiqugeParser.js
    │           ├── XenforoBatchParser.js
    │           ├── XiaoshubaoParser.js
    │           ├── XiaoshuoguiParser.js
    │           ├── XiaxuenovelsParser.js
    │           ├── XklxswParser.js
    │           ├── YedugeParser.js
    │           ├── YushuboParser.js
    │           ├── ZenithNovelsParser.js
    │           ├── ZenithtlsParser.js
    │           ├── ZeonicrepublicParser.js
    │           ├── ZhenhunxiaoshuoParser.js
    │           └── ZirusMusingsParser.js
    ├── testdata/
    │   ├── Baka-Tsuki.html
    │   ├── DredC1.html
    │   ├── FanFiction.html
    │   ├── FanFictionSinglePage.html
    │   ├── muggleNet.html
    │   └── muggleNetSinglePage.html
    ├── unitTest/
    │   ├── polyfillChrome.js
    │   ├── Tests.html
    │   ├── TestUtils.js
    │   ├── UtestActiveTranslationsParser.js
    │   ├── UtestArchiveOfOurOwnParser.js
    │   ├── UtestBakaTsukiParser.js
    │   ├── UtestBlogspotParser.js
    │   ├── UtestChapterUrlsUI.js
    │   ├── UtestChickengegeParser.js
    │   ├── UtestChineseFantasyNovelsParser.js
    │   ├── UtestComrademaoParser.js
    │   ├── UtestDebugUtil.js
    │   ├── UtestDefaultParser.js
    │   ├── UtestDeviantArtParser.js
    │   ├── UtestDownload.js
    │   ├── UtestEpubItem.js
    │   ├── UtestEpubMetaInfo.js
    │   ├── UtestEpubPacker.js
    │   ├── UtestFanFictionParser.js
    │   ├── UtestFicwadParser.js
    │   ├── UtestFirefox.js
    │   ├── UtestGravityTalesParser.js
    │   ├── UtestHttpClient.js
    │   ├── UtestImageCollector.js
    │   ├── UtestImgur.js
    │   ├── UtestJpmtlParser.js
    │   ├── UtestLightNovelWorldParser.js
    │   ├── UtestLiteroticaParser.js
    │   ├── UtestLnmtlParser.js
    │   ├── UtestMangaHereParser.js
    │   ├── UtestMuggleNetParser.js
    │   ├── UtestNepustationParser.js
    │   ├── UtestNovelfullParser.js
    │   ├── UtestNovelPlanetParser.js
    │   ├── UtestNovelSpreadParser.js
    │   ├── UtestParser.js
    │   ├── UtestParserFactory.js
    │   ├── UtestQidianParser.js
    │   ├── UtestQinxiaoshuoParser.js
    │   ├── UtestRanobesParser.js
    │   ├── UtestReadComicOnlineParser.js
    │   ├── UtestReadingList.js
    │   ├── UtestRoyalRoadParser.js
    │   ├── UtestShinsoriParser.js
    │   ├── UtestShmtranslationsParser.js
    │   ├── UtestStocxParser.js
    │   ├── UtestTapreadParser.js
    │   ├── UtestTranslationChickenParser.js
    │   ├── UtestTruyenfullParser.js
    │   ├── UtestTruyenyyParser.js
    │   ├── UtestUserPreferences.js
    │   ├── UtestUtil.js
    │   ├── UtestWattpadParser.js
    │   ├── UtestWebNovelOnlineParser.js
    │   ├── UtestWuxiaBlogParser.js
    │   ├── UtestWuxiaworldParser.js
    │   ├── UtestZipAndDownload.js
    │   └── qunit/
    │       └── qunit-1.19.0.css
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── add-site-request.md
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            ├── AutoRelease.yml
            └── node.js.yml

Files Content:

================================================
FILE: readme.md
================================================
<!-- Improved compatibility of back to top link: See: https://github.com/othneildrew/Best-README-Template/pull/73 -->

<a id="readme-top"></a>

<!-- PROJECT SHIELDS -->
<!--
*** I'm using markdown "reference style" links for readability.
*** Reference links are enclosed in brackets [ ] instead of parentheses ( ).
*** See the bottom of this document for the declaration of the reference variables
*** for contributors-url, forks-url, etc. This is an optional, concise syntax you may use.
*** https://www.markdownguide.org/basic-syntax/#reference-style-links
-->
 <div align="center">

[![Contributors][contributors-shield]][contributors-url]
[![Forks][forks-shield]][forks-url]
[![Stargazers][stars-shield]][stars-url]
[![Issues][issues-shield]][issues-url]
[![GPLv3 License][license-shield]][license-url]

 </div>
<!-- PROJECT LOGO -->
<br />
<div align="center">
  <a href="https://github.com/dteviot/WebToEpub">
    <img src="doc/logo.png" alt="Logo" width="80" height="80">
  </a>

  <h3 align="center">WebToEpub</h3>

  <p align="center">
    Extension that converts Web Novels (and other web pages) into an EPUB for offline reading.
    <br />
    <a href="https://github.com/dteviot/WebToEpub/wiki"><strong>Explore the wiki »</strong></a>
    <br />
    <br />
    <a href="https://github.com/dteviot/WebToEpub/issues/new?assignees=&labels=&projects=&template=add-site-request.md&title=Please+add+site+https%3A%2F%2F%3F%3F%3F%3F">Add Site Request</a>
    ·
    <a href="https://github.com/dteviot/WebToEpub/issues/new?assignees=&labels=&projects=&template=bug_report.md&title=">Bug Report</a>
    ·
    <a href="https://github.com/dteviot/WebToEpub/issues/new?assignees=&labels=&projects=&template=feature_request.md&title=">Feature Request</a>
  </p>
</div>

<!-- TABLE OF CONTENTS -->
<details>
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#about-the-project">About The Project</a>
      <ul>
        <li><a href="#supported-sites">Supported Sites</a></li>
        <li>
          <a href="#built-with">Built With</a>
          <ul>
            <li><a href="#libraries-used-in-webtoepub">Libraries used (in WebToEpub)</a></li>
            <li><a href="#libraries-used-by-webtoepub-build-process">Libraries used by WebToEpub build process</a></li>  
        </li>
      </ul>
    </li>
    <li>
      <a href="#installation">Installation</a>
      <ul>
        <li>
          <a href="#firefox">Firefox</a>
          <ul>
            <li>
              <a href="#from-firefox-add-ons">From Firefox Add-ons</a>
            </li>
            <li>
              <a href="#from-source-firefox">From Source (Firefox)</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#chrome">Chrome</a>
          <ul>
            <li>
              <a href="#from-chrome-web-store">From Chrome Web Store</a>
            </li>
            <li>
              <a href="#from-source-chrome">From Source (Chrome)</a>
            </li>
          </ul>
        </li>
        <li><a href="#from-source-developers">From Source (Developers)</a></li>
        <li><a href="#android-untested">Android (untested)</a></li>
      </ul>
    <li>
      <a href="#usage">Usage</a>
      <ul>
        <li><a href="#how-to-use-with-baka-tsuki">How to use with Baka-Tsuki</a></li>
        <li><a href="#how-to-use-with-archive-of-our-own">How to use with Archive of Our Own</a></li>
        <li><a href="#how-to-use-for-site-that-there-is-no-specific-parser-for">How to use for site that there is no specific parser for</a></li>
        <li><a href="#how-to-create-parsers-for-new-sites">How to create Parsers for new sites</a></li>
      </ul>
    </li>
    <li>
      <a href="#contributing">Contributing</a>
      <ul>
        <li>
          <a href="#top-contributors">Top Contributors</a>
        </li>
        <li>
          <a href="#credits">Credits</a>
        </li>
      </ul>
    </li>
    <li><a href="#license">License</a></li>
    <li><a href="#contact">Contact</a></li>
    <li><a href="#notes">Notes</a></li>
  </ol>
</details>

<!-- ABOUT THE PROJECT -->

## About The Project

![WebToEpub Screen Shot][product-screenshot]

&copy; 2015 David Teviotdale

WebToEpub is a browser extension for Firefox and Chrome that converts web novels and other web pages into EPUB format. It supports a wide range of websites, including:

- Baka-Tsuki.org
- ArchiveOfOurOwn.org
- FanFiction.net
- Wuxiaworld.com
- Royalroad.com and many more...

<p align="right">(<a href="#readme-top">back to top</a>)</p>

### Supported Sites

<details>
  <summary>Last we checked, the following sites were known to work</summary>
  <ul>
    <li>230book.net</li>
    <li>38xs.com</li>
    <li>4ksw.com</li>
    <li>888novel.com</li>
    <li>88xiaoshuo.net</li>
    <li>8muses.com</li>
    <li>a-t.nu</li>
    <li>aerialrain.com</li>
    <li>akknovel.com</li>
    <li>all-novelfull.net</li>
    <li>allnovel.org</li>
    <li>allnovelbin.net</li>
    <li>allnovelbook.com</li>
    <li>allnovelfull.app</li>
    <li>allnovelfull.com</li>
    <li>allnovelfull.net</li>
    <li>allnovelfull.org</li>
    <li>allnovelnext.com</li>
    <li>alphapolis.co.jp</li>
    <li>alternatehistory.com</li>
    <li>amor-yaoi.com</li>
    <li>anythingnovel.com</li>
    <li>arcanetranslations.com</li>
    <li>archiveofourown.org</li>
    <li>asianfanfics.com</li>
    <li>asianhobbyist.com</li>
    <li>asianovel.net</li>
    <li>asstr.org</li>
    <li>babelnovel.com</li>
    <li>baka-tsuki.org</li>
    <li>bakapervert.wordpress.com</li>
    <li>bednovel.com</li>
    <li>bestlightnovel.com</li>
    <li>betwixtedbutterfly.com</li>
    <li>bnatranslations.com</li>
    <li>book18.org</li>
    <li>bookalb.com</li>
    <li>bookswithqianya.com</li>
    <li>botitranslation.com</li>
    <li>boxnovel.net</li>
    <li>boxnovel.org</li>
    <li>boxnovelfull.com</li>
    <li>boylove.cc</li>
    <li>bqka.cc</li>
    <li>cangji.net</li>
    <li>cclawtranslations.home.blog</li>
    <li>chaleuria.com</li>
    <li>chichipeph.com</li>
    <li>chickengege.org</li>
    <li>chinesewuxia.world</li>
    <li>chrysanthemumgarden.com</li>
    <li>chyoa.com</li>
    <li>ckandawrites.online</li>
    <li>comics.8muses.com</li>
    <li>comrademao.com</li>
    <li>coronatranslation.com</li>
    <li>creativenovels.com</li>
    <li>crimsonmagic.me</li>
    <li>crimsontranslations.com</li>
    <li>cyborg-tl.com</li>
    <li>czbooks.net</li>
    <li>daotranslate.com</li>
    <li>daotranslate.us</li>
    <li>dark-novels.ru</li>
    <li>deviantart.com</li>
    <li>dummynovels.com</li>
    <li>edanglarstranslations.com</li>
    <li>engnovel.com</li>
    <li>erofus.com</li>
    <li>exiledrebelsscanlations.com</li>
    <li>faloomtl.com</li>
    <li>fanfiction.com.br</li>
    <li>fanfiction.mugglenet.com</li>
    <li>fanfiction.net</li>
    <li>fanmtl.com</li>
    <li>fannovel.com</li>
    <li>fannovels.com</li>
    <li>fansmtl.com</li>
    <li>fastnovel.net</li>
    <li>ffxs8.com</li>
    <li>fictionhunt.com</li>
    <li>fictionmania.tv</li>
    <li>fictionpress.com</li>
    <li>fictionzone.net</li>
    <li>ficwad.com</li>
    <li>fimfiction.net</li>
    <li>finestories.com</li>
    <li>flying-lines.com</li>
    <li>forum.questionablequesting.com</li>
    <li>forums.nrvnqsr.com</li>
    <li>forums.spacebattles.com</li>
    <li>forums.sufficientvelocity.com</li>
    <li>foxteller.com</li>
    <li>freelightnovel.net</li>
    <li>freenovelsread.com</li>
    <li>freewebnovel.com</li>
    <li>freewn.com</li>
    <li>frostfire10.wordpress.com</li>
    <li>fullnovel.co</li>
    <li>gamefaqs.gamespot.com</li>
    <li>genesistls.com</li>
    <li>genesistudio.com</li>
    <li>goblinsguide.com</li>
    <li>graverobbertl.site</li>
    <li>gravitynovels.com</li>
    <li>gravitytales.com</li>
    <li>gunnerkrigg.com</li>
    <li>gutenberg.spiegel.de</li>
    <li>helheimscans.com</li>
    <li>hellping.org</li>
    <li>hentai-foundry.com</li>
    <li>hiscension.com</li>
    <li>hostednovel.com</li>
    <li>hoxionia.com</li>
    <li>hui3r.wordpress.com</li>
    <li>idleturtle-translations.com</li>
    <li>idnovel.my.id</li>
    <li>imgur.com</li>
    <li>indomtl.com</li>
    <li>indowebnovel.id</li>
    <li>inkitt.com</li>
    <li>innnovel.com</li>
    <li>inoveltranslation.com</li>
    <li>isekaicyborg.wordpress.com</li>
    <li>isekaiscan.com</li>
    <li>isotls.com</li>
    <li>jade-rabbit.net</li>
    <li>japtem.com</li>
    <li>jjwxc.net</li>
    <li>jobnib.com</li>
    <li>jonaxxstories.com</li>
    <li>jpmtl.com</li>
    <li>kakuyomu.jp</li>
    <li>kaystls.site</li>
    <li>kemono.su</li>
    <li>knoxt.space</li>
    <li>kobatochan.com</li>
    <li>krytykal.org</li>
    <li>lazygirltranslations.com</li>
    <li>liberspark.com</li>
    <li>libread.com</li>
    <li>libri7.com</li>
    <li>lightnovelbastion.com</li>
    <li>lightnovelbox.com</li>
    <li>lightnovelcave.com</li>
    <li>lightnovelfr.com</li>
    <li>lightnovelpub.com</li>
    <li>lightnovelpub.fan</li>
    <li>lightnovelread.com</li>
    <li>lightnovelreader.org</li>
    <li>lightnovels.live</li>
    <li>lightnovels.me</li>
    <li>lightnovelstranslations.com</li>
    <li>lightnovelworld.co</li>
    <li>lightnovelworld.com</li>
    <li>lightsnovel.com</li>
    <li>listnovel.com</li>
    <li>literotica.com</li>
    <li>lnmtl.com</li>
    <li>lnreader.org</li>
    <li>m.88xiaoshuo.net</li>
    <li>m.bqg225.com</li>
    <li>m.chinesefantasynovels.com</li>
    <li>m.freelightnovel.net</li>
    <li>m.gzbpi.com</li>
    <li>m.metanovel.org</li>
    <li>m.mywuxiaworld.com</li>
    <li>m.novelspread.com</li>
    <li>m.qqxs.vip</li>
    <li>m.tapas.io</li>
    <li>m.wuxiaworld.co</li>
    <li>m.xklxsw.net</li>
    <li>machine-translation.org</li>
    <li>madnovel.com</li>
    <li>magic.wizards.com</li>
    <li>mandarinducktales.com</li>
    <li>mangabob.com</li>
    <li>mangadex.org</li>
    <li>mangahere.cc</li>
    <li>mangakakalot.com</li>
    <li>mangallama.com</li>
    <li>manganelo.com</li>
    <li>manganov.com</li>
    <li>mangaread.co</li>
    <li>mangasushi.net</li>
    <li>manhwaden.com</li>
    <li>manhwatop.com</li>
    <li>marx2mao.com</li>
    <li>mayanovel.com</li>
    <li>mcstories.com</li>
    <li>meionovel.id</li>
    <li>midnightrambles.in</li>
    <li>moonbunnycafe.com</li>
    <li>moonlightnovel.com</li>
    <li>moonquill.com</li>
    <li>morenovel.net</li>
    <li>mtlarchive.com</li>
    <li>mtled-novels.com</li>
    <li>mtlnation.com</li>
    <li>mtlnovel.com</li>
    <li>mtlreader.com</li>
    <li>mtnovel.net</li>
    <li>myxls.net</li>
    <li>nanomashin.online</li>
    <li>ncode.syosetu.com</li>
    <li>nightcomic.com</li>
    <li>noblemtl.com</li>
    <li>novel-bin.com</li>
    <li>novel-bin.net</li>
    <li>novel-bin.org</li>
    <li>novel-next.com</li>
    <li>novel.babelchain.org</li>
    <li>novel.naver.com</li>
    <li>novel18.syosetu.com</li>
    <li>novel35.com</li>
    <li>novelactive.org</li>
    <li>novelall.com</li>
    <li>novelbin.com</li>
    <li>novelbin.me</li>
    <li>novelbin.net</li>
    <li>novelbuddy.com</li>
    <li>novelbuddy.io</li>
    <li>novelcool.com</li>
    <li>novelcranel.org</li>
    <li>novelcrush.com</li>
    <li>novelebook.net</li>
    <li>novelfever.com</li>
    <li>novelfire.docsachhay.net</li>
    <li>novelfull.com</li>
    <li>novelfull.net</li>
    <li>novelfullbook.com</li>
    <li>novelgate.net</li>
    <li>novelgo.id</li>
    <li>novelgreat.net</li>
    <li>novelhall.com</li>
    <li>novelhi.com</li>
    <li>novelhold.com</li>
    <li>novelhulk.net</li>
    <li>novellive.app</li>
    <li>novellive.com</li>
    <li>novellive.net</li>
    <li>novelmania.com.br</li>
    <li>novelmao.com</li>
    <li>novelmax.net</li>
    <li>novelmedium.com</li>
    <li>novelmt.com</li>
    <li>novelmtl.com</li>
    <li>novelnext.com</li>
    <li>novelnext.dramanovels.io</li>
    <li>novelnext.net</li>
    <li>novelnextz.com</li>
    <li>novelonlinefree.com</li>
    <li>novelonlinefree.info</li>
    <li>novelonlinefull.com</li>
    <li>novelonomicon.com</li>
    <li>novelpassion.com</li>
    <li>novelplex.org</li>
    <li>novelpub.com</li>
    <li>novels.pl</li>
    <li>novelsect.com</li>
    <li>novelsemperor.com</li>
    <li>novelsemperor.net</li>
    <li>novelsknight.com</li>
    <li>novelsparadise.net</li>
    <li>novelspread.com</li>
    <li>novelsrock.com</li>
    <li>noveltoon.mobi</li>
    <li>noveltop1.org</li>
    <li>noveltranslatedbyc.blogspot.com</li>
    <li>noveltrench.com</li>
    <li>noveltrust.net</li>
    <li>noveluniverse.com</li>
    <li>novelupdates.cc</li>
    <li>novelupdates.online</li>
    <li>novelusb.com</li>
    <li>novelusb.net</li>
    <li>novelversetranslations.com</li>
    <li>novelxo.net</li>
    <li>novicetranslations.com</li>
    <li>ntruyen.vn</li>
    <li>nyantl.wordpress.com</li>
    <li>octopii.co</li>
    <li>onlinenovelbook.com</li>
    <li>ontimestory.eu</li>
    <li>ossantl.com</li>
    <li>panda-novel.com</li>
    <li>pandamtl.com</li>
    <li>pandapama.com</li>
    <li>pandasnovel.com</li>
    <li>patreon.com</li>
    <li>pawread.com</li>
    <li>peachblossomcodex.com</li>
    <li>peachpitting.com</li>
    <li>peachpuff.in</li>
    <li>pery.info</li>
    <li>piaotia.com</li>
    <li>puretl.com</li>
    <li>qinxiaoshuo.com</li>
    <li>quanben.io</li>
    <li>quanben5.io</li>
    <li>questionablequesting.com</li>
    <li>quotev.com</li>
    <li>raeitranslations.com</li>
    <li>rainingtl.org</li>
    <li>rainofsnow.com</li>
    <li>raisingthedead.ninja</li>
    <li>ranobes.net</li>
    <li>ranobes.top</li>
    <li>re-library.com</li>
    <li>readcomiconline.li</li>
    <li>reader-hub.com</li>
    <li>readfreebooksonline.org</li>
    <li>readhive.org</li>
    <li>readlightnovel.cc</li>
    <li>readlightnovel.me</li>
    <li>readlightnovel.meme</li>
    <li>readlightnovel.org</li>
    <li>readlightnovel.today</li>
    <li>readlitenovel.com</li>
    <li>readnoveldaily.com</li>
    <li>readnovelfull.com</li>
    <li>readnovelfull.me</li>
    <li>readnovelfull.org</li>
    <li>readwebnovel.xyz</li>
    <li>readwn.com</li>
    <li>readwn.org</li>
    <li>rebirth.online</li>
    <li>reddit.com</li>
    <li>royalroad.com</li>
    <li>royalroadl.com</li>
    <li>rtd.moe</li>
    <li>rtenzo.net</li>
    <li>rubymaybetranslations.com</li>
    <li>scifistories.com</li>
    <li>scribblehub.com</li>
    <li>secondlifetranslations.com</li>
    <li>semprot.com</li>
    <li>sexstories.com</li>
    <li>shalvationtranslations.wordpress.com</li>
    <li>shanghaifantasy.com</li>
    <li>shikkakutranslations.org</li>
    <li>shinsori.com</li>
    <li>shintranslations.com</li>
    <li>shirokuns.com</li>
    <li>shmtranslations.com</li>
    <li>shubaow.net</li>
    <li>shubaowb.com</li>
    <li>shw5.cc</li>
    <li>sites.google.com</li>
    <li>sj.uukanshu.com</li>
    <li>sjks88.com</li>
    <li>skydemonorder.com</li>
    <li>skythewoodtl.com</li>
    <li>snowycodex.com</li>
    <li>sonako.fandom.com</li>
    <li>sonako.wikia.com</li>
    <li>sousetsuka.com</li>
    <li>soverse.com</li>
    <li>spiritfanfiction.com</li>
    <li>sspai.com</li>
    <li>starlightstream.net</li>
    <li>sto.cx</li>
    <li>storiesonline.net</li>
    <li>storyseedling.com</li>
    <li>sweek.com</li>
    <li>systemtranslation.com</li>
    <li>taffygirl13.wordpress.com</li>
    <li>tamagotl.com</li>
    <li>taonovel.com</li>
    <li>tapas.io</li>
    <li>tapread.com</li>
    <li>teanovel.com</li>
    <li>teanovel.net</li>
    <li>teenfic.net</li>
    <li>thenovelbin.org</li>
    <li>tigertranslations.org</li>
    <li>timotxt.com</li>
    <li>titannovel.net</li>
    <li>tl.rulate.ru</li>
    <li>tomotranslations.com</li>
    <li>topnovelfull.com</li>
    <li>translationchicken.com</li>
    <li>travistranslations.com</li>
    <li>truyenfull.vn</li>
    <li>truyenyy.com</li>
    <li>trxs.me</li>
    <li>ultimaguil.org</li>
    <li>universalnovel.com</li>
    <li>unlimitednovelfailures.mangamatters.com</li>
    <li>untamedalley.com</li>
    <li>veratales.com</li>
    <li>vipnovel.com</li>
    <li>volarenovels.com</li>
    <li>wanderertl130.id</li>
    <li>wanderinginn.com</li>
    <li>watashiwasugoidesu.com</li>
    <li>wattpad.com</li>
    <li>wetriedtls.com</li>
    <li>webnovel.com</li>
    <li>webnovel.live</li>
    <li>webnovelonline.com</li>
    <li>webnovelpub.com</li>
    <li>webnovelpub.pro</li>
    <li>wenku8.net</li>
    <li>wfxs.tw</li>
    <li>whitemoonlightnovels.com</li>
    <li>wnmtl.com</li>
    <li>wnmtl.org</li>
    <li>woopread.com</li>
    <li>wordexcerpt.com</li>
    <li>worldnovel.online</li>
    <li>wtr-lab.com</li>
    <li>wuxia-world.online</li>
    <li>wuxia.blog</li>
    <li>wuxia.city</li>
    <li>wuxia.click</li>
    <li>wuxiabee.com</li>
    <li>wuxiabee.net</li>
    <li>wuxiabee.org</li>
    <li>wuxiafox.com</li>
    <li>wuxiago.com</li>
    <li>wuxiahere.com</li>
    <li>wuxiahub.com</li>
    <li>wuxiamtl.com</li>
    <li>wuxiaone.com</li>
    <li>wuxiap.com</li>
    <li>wuxiapub.com</li>
    <li>wuxiar.com</li>
    <li>wuxiaspot.com</li>
    <li>wuxiau.com</li>
    <li>wuxiaworld.co</li>
    <li>wuxiaworld.com</li>
    <li>wuxiaworld.eu</li>
    <li>wuxiaworld.live</li>
    <li>wuxiaworld.online</li>
    <li>wuxiaworld.site</li>
    <li>wuxiaworld.world</li>
    <li>wuxiazone.com</li>
    <li>wxscs.com</li>
    <li>xbiquge.so</li>
    <li>xiaoshuogui.com</li>
    <li>xiaxuenovels.xyz</li>
    <li>yoraikun.wordpress.com</li>
    <li>yushubo.net</li>
    <li>zenithnovels.com</li>
    <li>zeonic-republic.net</li>
    <li>zhenhunxiaoshuo.com</li>
    <li>zinnovel.net</li>
    <li>zirusmusings.com</li>
  </ul>
</details>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

### Built With

- Node.js
- eslint

##### Libraries used (in WebToEpub)

- zip.js
- DOMPurify

#### Libraries used by WebToEpub build process

- @xmldom/xmldom
- copyfiles
- quint

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- INSTALLATION -->

## Installation

### Firefox

#### From Firefox Add-ons

Open Firefox and visit [WebToEpub on Firefox Add-ons][firefox-add-ons].

#### From Source (Firefox)

The easiest set of steps is using Firefox.

1. Download prebuilt Firefox version of extension from <https://github.com/dteviot/WebToEpub/releases/tag/developer-build>.
2. Open Firefox and type "about:debugging#/runtime/this-firefox" into the URL bar.
3. Click "Load Temporary Add-on".
4. Click on the zip file you downloaded in step 1.
   ![Installing in Firefox screenshot](doc/FirefoxLoadFromSource.png?raw=true)

### Chrome

#### From Chrome Web Store

Open Chrome (or any Chromium-based browser like Edge, Opera, etc.) and go to [WebToEpub on Chrome Web Store][chrome-web-store].

#### From Source (Chrome)

1. Download prebuilt Chrome version of extension from <https://github.com/dteviot/WebToEpub/releases/tag/developer-build>.
2. Unpack zip file
3. Open Chrome and type "chrome://extensions" into the browser.
4. Make sure "Developer Mode" at the top of the page is checked.
5. Press the "Load unpacked extension.." button and browse to unpacked zip directory from step 2.
   ![wte-chrome-small](https://user-images.githubusercontent.com/20068737/136224439-57af48bd-21fb-463d-99db-74f44769327e.gif)

### Android (Firefox Nightly for Developers)

#### From Firefox Add-ons Store

Open Firefox and visit [WebToEpub on Firefox Add-ons][firefox-add-ons].

#### From Source (Firefox Nightly for Developers)

1. Download prebuilt Firefox version of extension from <https://github.com/dteviot/WebToEpub/releases/tag/developer-build>.
2. Open the site "about:config"
3. Search "xpinstall.signatures.required" and set the value to false.
4. Open Settings and scoll down to "About Firefox Nightly"
5. Tap the Firefox Nightly icon (blue fox) 6 times to enable Debug menu
6. Open Settings -> Advanced -> Install extension from file
7. Select the zip file you downloaded in step 1.

### From Source (Developers)

1. Clone this repo.

   ```sh
    git clone https://github.com/dteviot/WebToEpub.git
   ```

2. Build extension.

   - Install [Node.js](https://nodejs.org/) (if not already installed)
   - Run `npm install` to install dependencies
   - Run `npm run lint` to build plugin and lint
   - This will produce 3 files in the eslint directory.
     - WebToEpub0.0.0.x.xpi (Firefox version of plug-in)
     - WebToEpub0.0.0.x.zip (Chrome version of plug-in)
     - packed.js (concatenated JS for linting - don't edit this file directly)
   - Lint tests are OK if output ends with `Wrote Zip to disk; Done in XXXs.`
   - To auto-fix lint errors run `npm run lint:fix`

3. Install extension in browser of choice, using instructions above.

See [notes](#notes) for more information.

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- USAGE EXAMPLES -->

## Usage

### How to use with Baka-Tsuki

- Browse to a Baka-Tsuki web page that has the full text of a story.
- Click on the WebToEpub icon on top right of the window.
- Check story details are correct.
- Select image to use for cover.
- Click the "Pack EPUB" button.
- Wait for progress bar to finish (indicating the images being downloaded) and the generated EPUB to be placed in your downloads directory.

### How to use with Archive of Our Own

- Browse to first chapter of story you want.
- Click on the WebToEpub icon on top right of the window.
- Check story details are correct.
- Click the "Pack EPUB" button.
- Wait for progress bar to finish (indicating the additional chapters are being downloaded) and the generated EPUB to be placed in your downloads directory.

### How to use for site that there is no specific parser for

See: <https://github.com/dteviot/WebToEpub/wiki/FAQ#how-to-convert-a-new-site-using-the-default-parser>

### How to create Parsers for new sites

For details on how to extend, see the following

- <https://github.com/dteviot/WebToEpub/wiki/FAQ#how-to-write-a-new-parser>
- <http://www.codeproject.com/Articles/1060680/Web-to-EPUB-Extension-for-Chrome>.

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- CONTRIBUTING -->

## Contributing

> [!NOTE]
>
> Read [CONTRIBUTING.md](/CONTRIBUTING.md) first.

Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are **greatly appreciated**.

If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag "enhancement".
Don't forget to give the project a star! Thanks again!

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### Top contributors

<a href="https://github.com/dteviot/WebToEpub/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=dteviot/WebToEpub" alt="contrib.rocks image" />
</a>

### Credits

<details>
  <summary>Contributors</summary>
  <ul>
    <li>Firefox port by Markus Vieth</li>
    <li>Michael Fox (Belldandu)</li>
    <li>typhoon71</li>
    <li>toshiya44</li>
    <li>dreamer2908</li>
    <li>Parser for German Project Gutenberg by GallusMax</li>
    <li>Hogesyx</li>
    <li>Asif Mahmood</li>
    <li>snnsnn</li>
    <li>Sergii Pravdzivyi</li>
    <li>Aurimas Niekis</li>
    <li>Tom Goetz</li>
    <li>Alen Toma (css styling)</li>
    <li>JimmXinu</li>
    <li>gamebeaker (additional metadata, Library)</li>
    <li>Kondeeza</li>
    <li>Mathnerd314</li>
    <li>Sickan90</li>
    <li>Miracutor</li>
    <li>Kiradien</li>
    <li>Synteresis</li>
    <li>Lej77</li>
    <li>nandakishore2009 (Parsers for madnovel.com, www.panda-novel.com)</li>
    <li>courli79</li>
    <li>Dimava</li>
    <li>alethiophile</li>
    <li>Yoanhg421</li>
    <li>Leone Jacob Sunil (ImLJS)</li>
    <li>xRahul</li>
    <li>Oleksii Taranenko</li>
    <li>Naheulf</li>
    <li>perishableloc</li>
    <li>praschke</li>
    <li>ImmortalDreamer</li>
    <li>ktrin</li>
    <li>nozwock</li>
    <li>Tyderion</li>
    <li>Darthagnon</li>
    <li>LucasFreitaslpf1</li>
    <li>Jemeni11</li>
    <li>maforn</li>
    <li>phazei</li>
    <li>rizkiv1</li>
    <li>pavan3999</li>
    <li>Anartigone</li>
    <li>crybx</li>
    <li>ltsKbrc</li>
    <li>Ori Avtalion</li>
    <li>NamTH</li>
    <li>minhngoc25a</li>
    <li>basitcodeenv</li>
    <li>X-Xadro</li>
    <li>Yomafil</li>
    <li>Varun Patkar</li>
    <li>Peter Kaufman</li>
    <li>patiorjunrick</li>
    <li>MD Shabrez</li>
    <li>jurassicplayer</li>
    <li>X2E4VXpZKv</li>
    <li>meson1271 (Parser for jadescrolls.com)</li>
    <li>AgatZan (Parser for ficbook.net)</li>
    <li>Joel Sunil</li>
    <li>nothing0074</li>
  </ul>
</details>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- LICENSE -->

## License

Licensed under GPLv3. See [LICENSE][license-url] for more information.

WebToEpub uses the following libraries:

- zip.js library v2.7.57: <https://github.com/gildas-lormeau/zip.js>, licensed under BSD 3-Clause.
- quint: <http://qunitjs.com/>, licensed under MIT license.

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- CONTACT -->

## Contact

David Teviotdale - [@dteviot](https://github.com/dteviot)

Project Link: [https://github.com/dteviot/WebToEpub](https://github.com/dteviot/WebToEpub)

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- NOTES -->

## Notes

### To run unit tests

- Install [Node.js](https://nodejs.org/) (if not already installed)
- Run `npm install` to install dependencies
- Run `npm test`
- Tests will be launched in your default browser. To open them in different browser, open the page URL in it.

> ### To run unit tests without Node.js
>
> - If you are not trying to run unit tests in `/unitTest/` folder, you do not need this
> - If you can use nodejs, see previous paragraph instead
> - If you can not install nodejs or http-server is not working when you run `npm test`, and you have no alternative ways to serve files (like [chrome Web Server app](https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb) for example), you have to allow browser to run local html files to run tests.
>
> #### To run unit tests (without local server) under Chrome
>
> - Close all running copies of Chrome
> - Start Chrome with command line argument `--allow-file-access-from-files`. That is:
>   - Open a command propmt
>   - Browse to the directory holding Chrome
>   - Type in command `chrome.exe --allow-file-access-from-files` . Press "Enter".
>   - If you don't do this, some tests will fail with error messages containing the text **_Failed to execute 'send' on 'XMLHttpRequest': Failed to load_**.
> - Load `unitTest/Tests.html`
> - If you get **_Failed to read the 'localStorage' property from 'Window': Access is denied for this document_** errors
>   - Type **_chrome://settings/content_** into Chrome's search bar
>   - Uncheck **_Block third-party cookies and site data_**
>   - Click **_Finished_**
>   - Re-run unit tests
> - When finished with unit tests.
>   - Restore original value of **_Block third-party cookies and site data_** (if you changed it).
>   - close all running copies of Chrome
>
> #### To run unit tests (without local server) under Firefox
>
> - Start Firefox
> - Go to `about:config`
> - Find `security.fileuri.strict_origin_policy` parameter
> - Set it to false
> - Load `unitTest/Tests.html`
> - (Remember to reset `security.fileuri.strict_origin_policy` to true when done.

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- MARKDOWN LINKS & IMAGES -->
<!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->

[contributors-shield]: https://img.shields.io/github/contributors/dteviot/WebToEpub.svg?style=for-the-badge
[contributors-url]: https://github.com/dteviot/WebToEpub/graphs/contributors
[forks-shield]: https://img.shields.io/github/forks/dteviot/WebToEpub.svg?style=for-the-badge
[forks-url]: https://github.com/dteviot/WebToEpub/network/members
[stars-shield]: https://img.shields.io/github/stars/dteviot/WebToEpub.svg?style=for-the-badge
[stars-url]: https://github.com/dteviot/WebToEpub/stargazers
[issues-shield]: https://img.shields.io/github/issues/dteviot/WebToEpub.svg?style=for-the-badge
[issues-url]: https://github.com/dteviot/WebToEpub/issues

<!-- GitHub can't automatically ID the current license so let's hard code it -->

[license-shield]: https://img.shields.io/badge/LICENSE-GPLv3-%23555555?style=for-the-badge&label=LICENSE&color=285959
[license-url]: /LICENSE.md
[product-screenshot]: doc/product-screenshot.png

<!-- Store Links -->

[firefox-add-ons]: https://addons.mozilla.org/en-US/firefox/addon/webtoepub-for-baka-tsuki
[chrome-web-store]: https://chrome.google.com/webstore/detail/webtoepub/akiljllkbielkidmammnifcnibaigelm

================================================
FILE: CONTRIBUTING.md
================================================

## Pull Request Check List

- Do all existing unit tests pass?  (FYI, I find it easier to get the unit tests to run under Firefox, instead of Chrome.)

- Have all warnings and errors reported by eslint been fixed?
- If you've added new behavior,
  - Can a user turn it off?  
  - Is it off by default?  Note, users don't like it when behavior changes without warning.
- Have you updated the "contributors" section of packages.json with your name? (and ideally email, so I can contact you easily.)
- Have you updated the "Credits" section of readme.md with your name?
- Are you committing to the ExperimentalTab branch?
- Have you rebased your commit?

================================================
FILE: LICENSE.md
================================================

GNU GENERAL PUBLIC LICENSE
==========================

Version 3, 29 June 2007

Copyright &copy; 2007 Free Software Foundation, Inc. &lt;<http://fsf.org/>&gt;

Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.

## Preamble

The GNU General Public License is a free, copyleft license for software and other
kinds of works.

The licenses for most software and other practical works are designed to take away
your freedom to share and change the works. By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change all versions of a
program--to make sure it remains free software for all its users. We, the Free
Software Foundation, use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors. You can apply it to
your programs, too.

When we speak of free software, we are referring to freedom, not price. Our General
Public Licenses are designed to make sure that you have the freedom to distribute
copies of free software (and charge for them if you wish), that you receive source
code or can get it if you want it, that you can change the software or use pieces of
it in new free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you these rights or
asking you to surrender the rights. Therefore, you have certain responsibilities if
you distribute copies of the software, or if you modify it: responsibilities to
respect the freedom of others.

For example, if you distribute copies of such a program, whether gratis or for a fee,
you must pass on to the recipients the same freedoms that you received. You must make
sure that they, too, receive or can get the source code. And you must show them these
terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps: (1) assert
copyright on the software, and (2) offer you this License giving you legal permission
to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains that there is
no warranty for this free software. For both users' and authors' sake, the GPL
requires that modified versions be marked as changed, so that their problems will not
be attributed erroneously to authors of previous versions.

Some devices are designed to deny users access to install or run modified versions of
the software inside them, although the manufacturer can do so. This is fundamentally
incompatible with the aim of protecting users' freedom to change the software. The
systematic pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable. Therefore, we have designed
this version of the GPL to prohibit the practice for those products. If such problems
arise substantially in other domains, we stand ready to extend this provision to
those domains in future versions of the GPL, as needed to protect the freedom of
users.

Finally, every program is threatened constantly by software patents. States should
not allow patents to restrict development and use of software on general-purpose
computers, but in those that do, we wish to avoid the special danger that patents
applied to a free program could make it effectively proprietary. To prevent this, the
GPL assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and modification follow.

## TERMS AND CONDITIONS

### 0. Definitions

&ldquo;This License&rdquo; refers to version 3 of the GNU General Public License.

&ldquo;Copyright&rdquo; also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

&ldquo;The Program&rdquo; refers to any copyrightable work licensed under this
License. Each licensee is addressed as &ldquo;you&rdquo;. &ldquo;Licensees&rdquo; and
&ldquo;recipients&rdquo; may be individuals or organizations.

To &ldquo;modify&rdquo; a work means to copy from or adapt all or part of the work in
a fashion requiring copyright permission, other than the making of an exact copy. The
resulting work is called a &ldquo;modified version&rdquo; of the earlier work or a
work &ldquo;based on&rdquo; the earlier work.

A &ldquo;covered work&rdquo; means either the unmodified Program or a work based on
the Program.

To &ldquo;propagate&rdquo; a work means to do anything with it that, without
permission, would make you directly or secondarily liable for infringement under
applicable copyright law, except executing it on a computer or modifying a private
copy. Propagation includes copying, distribution (with or without modification),
making available to the public, and in some countries other activities as well.

To &ldquo;convey&rdquo; a work means any kind of propagation that enables other
parties to make or receive copies. Mere interaction with a user through a computer
network, with no transfer of a copy, is not conveying.

An interactive user interface displays &ldquo;Appropriate Legal Notices&rdquo; to the
extent that it includes a convenient and prominently visible feature that (1)
displays an appropriate copyright notice, and (2) tells the user that there is no
warranty for the work (except to the extent that warranties are provided), that
licensees may convey the work under this License, and how to view a copy of this
License. If the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

### 1. Source Code

The &ldquo;source code&rdquo; for a work means the preferred form of the work for
making modifications to it. &ldquo;Object code&rdquo; means any non-source form of a
work.

A &ldquo;Standard Interface&rdquo; means an interface that either is an official
standard defined by a recognized standards body, or, in the case of interfaces
specified for a particular programming language, one that is widely used among
developers working in that language.

The &ldquo;System Libraries&rdquo; of an executable work include anything, other than
the work as a whole, that (a) is included in the normal form of packaging a Major
Component, but which is not part of that Major Component, and (b) serves only to
enable use of the work with that Major Component, or to implement a Standard
Interface for which an implementation is available to the public in source code form.
A &ldquo;Major Component&rdquo;, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system (if any) on which
the executable work runs, or a compiler used to produce the work, or an object code
interpreter used to run it.

The &ldquo;Corresponding Source&rdquo; for a work in object code form means all the
source code needed to generate, install, and (for an executable work) run the object
code and to modify the work, including scripts to control those activities. However,
it does not include the work's System Libraries, or general-purpose tools or
generally available free programs which are used unmodified in performing those
activities but which are not part of the work. For example, Corresponding Source
includes interface definition files associated with source files for the work, and
the source code for shared libraries and dynamically linked subprograms that the work
is specifically designed to require, such as by intimate data communication or
control flow between those subprograms and other parts of the work.

The Corresponding Source need not include anything that users can regenerate
automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same work.

### 2. Basic Permissions

All rights granted under this License are granted for the term of copyright on the
Program, and are irrevocable provided the stated conditions are met. This License
explicitly affirms your unlimited permission to run the unmodified Program. The
output from running a covered work is covered by this License only if the output,
given its content, constitutes a covered work. This License acknowledges your rights
of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey, without
conditions so long as your license otherwise remains in force. You may convey covered
works to others for the sole purpose of having them make modifications exclusively
for you, or provide you with facilities for running those works, provided that you
comply with the terms of this License in conveying all material for which you do not
control copyright. Those thus making or running the covered works for you must do so
exclusively on your behalf, under your direction and control, on terms that prohibit
them from making any copies of your copyrighted material outside their relationship
with you.

Conveying under any other circumstances is permitted solely under the conditions
stated below. Sublicensing is not allowed; section 10 makes it unnecessary.

### 3. Protecting Users' Legal Rights From Anti-Circumvention Law

No covered work shall be deemed part of an effective technological measure under any
applicable law fulfilling obligations under article 11 of the WIPO copyright treaty
adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention
of such measures.

When you convey a covered work, you waive any legal power to forbid circumvention of
technological measures to the extent such circumvention is effected by exercising
rights under this License with respect to the covered work, and you disclaim any
intention to limit operation or modification of the work as a means of enforcing,
against the work's users, your or third parties' legal rights to forbid circumvention
of technological measures.

### 4. Conveying Verbatim Copies

You may convey verbatim copies of the Program's source code as you receive it, in any
medium, provided that you conspicuously and appropriately publish on each copy an
appropriate copyright notice; keep intact all notices stating that this License and
any non-permissive terms added in accord with section 7 apply to the code; keep
intact all notices of the absence of any warranty; and give all recipients a copy of
this License along with the Program.

You may charge any price or no price for each copy that you convey, and you may offer
support or warranty protection for a fee.

### 5. Conveying Modified Source Versions

You may convey a work based on the Program, or the modifications to produce it from
the Program, in the form of source code under the terms of section 4, provided that
you also meet all of these conditions:

- **a)** The work must carry prominent notices stating that you modified it, and giving a
relevant date.
- **b)** The work must carry prominent notices stating that it is released under this
License and any conditions added under section 7. This requirement modifies the
requirement in section 4 to &ldquo;keep intact all notices&rdquo;.
- **c)** You must license the entire work, as a whole, under this License to anyone who
comes into possession of a copy. This License will therefore apply, along with any
applicable section 7 additional terms, to the whole of the work, and all its parts,
regardless of how they are packaged. This License gives no permission to license the
work in any other way, but it does not invalidate such permission if you have
separately received it.
- **d)** If the work has interactive user interfaces, each must display Appropriate Legal
Notices; however, if the Program has interactive interfaces that do not display
Appropriate Legal Notices, your work need not make them do so.

A compilation of a covered work with other separate and independent works, which are
not by their nature extensions of the covered work, and which are not combined with
it such as to form a larger program, in or on a volume of a storage or distribution
medium, is called an &ldquo;aggregate&rdquo; if the compilation and its resulting
copyright are not used to limit the access or legal rights of the compilation's users
beyond what the individual works permit. Inclusion of a covered work in an aggregate
does not cause this License to apply to the other parts of the aggregate.

### 6. Conveying Non-Source Forms

You may convey a covered work in object code form under the terms of sections 4 and
5, provided that you also convey the machine-readable Corresponding Source under the
terms of this License, in one of these ways:

- **a)** Convey the object code in, or embodied in, a physical product (including a
physical distribution medium), accompanied by the Corresponding Source fixed on a
durable physical medium customarily used for software interchange.
- **b)** Convey the object code in, or embodied in, a physical product (including a
physical distribution medium), accompanied by a written offer, valid for at least
three years and valid for as long as you offer spare parts or customer support for
that product model, to give anyone who possesses the object code either (1) a copy of
the Corresponding Source for all the software in the product that is covered by this
License, on a durable physical medium customarily used for software interchange, for
a price no more than your reasonable cost of physically performing this conveying of
source, or (2) access to copy the Corresponding Source from a network server at no
charge.
- **c)** Convey individual copies of the object code with a copy of the written offer to
provide the Corresponding Source. This alternative is allowed only occasionally and
noncommercially, and only if you received the object code with such an offer, in
accord with subsection 6b.
- **d)** Convey the object code by offering access from a designated place (gratis or for
a charge), and offer equivalent access to the Corresponding Source in the same way
through the same place at no further charge. You need not require recipients to copy
the Corresponding Source along with the object code. If the place to copy the object
code is a network server, the Corresponding Source may be on a different server
(operated by you or a third party) that supports equivalent copying facilities,
provided you maintain clear directions next to the object code saying where to find
the Corresponding Source. Regardless of what server hosts the Corresponding Source,
you remain obligated to ensure that it is available for as long as needed to satisfy
these requirements.
- **e)** Convey the object code using peer-to-peer transmission, provided you inform
other peers where the object code and Corresponding Source of the work are being
offered to the general public at no charge under subsection 6d.

A separable portion of the object code, whose source code is excluded from the
Corresponding Source as a System Library, need not be included in conveying the
object code work.

A &ldquo;User Product&rdquo; is either (1) a &ldquo;consumer product&rdquo;, which
means any tangible personal property which is normally used for personal, family, or
household purposes, or (2) anything designed or sold for incorporation into a
dwelling. In determining whether a product is a consumer product, doubtful cases
shall be resolved in favor of coverage. For a particular product received by a
particular user, &ldquo;normally used&rdquo; refers to a typical or common use of
that class of product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected to use, the
product. A product is a consumer product regardless of whether the product has
substantial commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

&ldquo;Installation Information&rdquo; for a User Product means any methods,
procedures, authorization keys, or other information required to install and execute
modified versions of a covered work in that User Product from a modified version of
its Corresponding Source. The information must suffice to ensure that the continued
functioning of the modified object code is in no case prevented or interfered with
solely because modification has been made.

If you convey an object code work under this section in, or with, or specifically for
use in, a User Product, and the conveying occurs as part of a transaction in which
the right of possession and use of the User Product is transferred to the recipient
in perpetuity or for a fixed term (regardless of how the transaction is
characterized), the Corresponding Source conveyed under this section must be
accompanied by the Installation Information. But this requirement does not apply if
neither you nor any third party retains the ability to install modified object code
on the User Product (for example, the work has been installed in ROM).

The requirement to provide Installation Information does not include a requirement to
continue to provide support service, warranty, or updates for a work that has been
modified or installed by the recipient, or for the User Product in which it has been
modified or installed. Access to a network may be denied when the modification itself
materially and adversely affects the operation of the network or violates the rules
and protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided, in accord with
this section must be in a format that is publicly documented (and with an
implementation available to the public in source code form), and must require no
special password or key for unpacking, reading or copying.

### 7. Additional Terms

&ldquo;Additional permissions&rdquo; are terms that supplement the terms of this
License by making exceptions from one or more of its conditions. Additional
permissions that are applicable to the entire Program shall be treated as though they
were included in this License, to the extent that they are valid under applicable
law. If additional permissions apply only to part of the Program, that part may be
used separately under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option remove any
additional permissions from that copy, or from any part of it. (Additional
permissions may be written to require their own removal in certain cases when you
modify the work.) You may place additional permissions on material, added by you to a
covered work, for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you add to a
covered work, you may (if authorized by the copyright holders of that material)
supplement the terms of this License with terms:

- **a)** Disclaiming warranty or limiting liability differently from the terms of
sections 15 and 16 of this License; or
- **b)** Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices displayed by works
containing it; or
- **c)** Prohibiting misrepresentation of the origin of that material, or requiring that
modified versions of such material be marked in reasonable ways as different from the
original version; or
- **d)** Limiting the use for publicity purposes of names of licensors or authors of the
material; or
- **e)** Declining to grant rights under trademark law for use of some trade names,
trademarks, or service marks; or
- **f)** Requiring indemnification of licensors and authors of that material by anyone
who conveys the material (or modified versions of it) with contractual assumptions of
liability to the recipient, for any liability that these contractual assumptions
directly impose on those licensors and authors.

All other non-permissive additional terms are considered &ldquo;further
restrictions&rdquo; within the meaning of section 10. If the Program as you received
it, or any part of it, contains a notice stating that it is governed by this License
along with a term that is a further restriction, you may remove that term. If a
license document contains a further restriction but permits relicensing or conveying
under this License, you may add to a covered work material governed by the terms of
that license document, provided that the further restriction does not survive such
relicensing or conveying.

If you add terms to a covered work in accord with this section, you must place, in
the relevant source files, a statement of the additional terms that apply to those
files, or a notice indicating where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the form of a
separately written license, or stated as exceptions; the above requirements apply
either way.

### 8. Termination

You may not propagate or modify a covered work except as expressly provided under
this License. Any attempt otherwise to propagate or modify it is void, and will
automatically terminate your rights under this License (including any patent licenses
granted under the third paragraph of section 11).

However, if you cease all violation of this License, then your license from a
particular copyright holder is reinstated (a) provisionally, unless and until the
copyright holder explicitly and finally terminates your license, and (b) permanently,
if the copyright holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently
if the copyright holder notifies you of the violation by some reasonable means, this
is the first time you have received notice of violation of this License (for any
work) from that copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of
parties who have received copies or rights from you under this License. If your
rights have been terminated and not permanently reinstated, you do not qualify to
receive new licenses for the same material under section 10.

### 9. Acceptance Not Required for Having Copies

You are not required to accept this License in order to receive or run a copy of the
Program. Ancillary propagation of a covered work occurring solely as a consequence of
using peer-to-peer transmission to receive a copy likewise does not require
acceptance. However, nothing other than this License grants you permission to
propagate or modify any covered work. These actions infringe copyright if you do not
accept this License. Therefore, by modifying or propagating a covered work, you
indicate your acceptance of this License to do so.

### 10. Automatic Licensing of Downstream Recipients

Each time you convey a covered work, the recipient automatically receives a license
from the original licensors, to run, modify and propagate that work, subject to this
License. You are not responsible for enforcing compliance by third parties with this
License.

An &ldquo;entity transaction&rdquo; is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an organization, or
merging organizations. If propagation of a covered work results from an entity
transaction, each party to that transaction who receives a copy of the work also
receives whatever licenses to the work the party's predecessor in interest had or
could give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if the predecessor
has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the rights granted or
affirmed under this License. For example, you may not impose a license fee, royalty,
or other charge for exercise of rights granted under this License, and you may not
initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging
that any patent claim is infringed by making, using, selling, offering for sale, or
importing the Program or any portion of it.

### 11. Patents

A &ldquo;contributor&rdquo; is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based. The work thus
licensed is called the contributor's &ldquo;contributor version&rdquo;.

A contributor's &ldquo;essential patent claims&rdquo; are all patent claims owned or
controlled by the contributor, whether already acquired or hereafter acquired, that
would be infringed by some manner, permitted by this License, of making, using, or
selling its contributor version, but do not include claims that would be infringed
only as a consequence of further modification of the contributor version. For
purposes of this definition, &ldquo;control&rdquo; includes the right to grant patent
sublicenses in a manner consistent with the requirements of this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free patent license
under the contributor's essential patent claims, to make, use, sell, offer for sale,
import and otherwise run, modify and propagate the contents of its contributor
version.

In the following three paragraphs, a &ldquo;patent license&rdquo; is any express
agreement or commitment, however denominated, not to enforce a patent (such as an
express permission to practice a patent or covenant not to sue for patent
infringement). To &ldquo;grant&rdquo; such a patent license to a party means to make
such an agreement or commitment not to enforce a patent against the party.

If you convey a covered work, knowingly relying on a patent license, and the
Corresponding Source of the work is not available for anyone to copy, free of charge
and under the terms of this License, through a publicly available network server or
other readily accessible means, then you must either (1) cause the Corresponding
Source to be so available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner consistent with
the requirements of this License, to extend the patent license to downstream
recipients. &ldquo;Knowingly relying&rdquo; means you have actual knowledge that, but
for the patent license, your conveying the covered work in a country, or your
recipient's use of the covered work in a country, would infringe one or more
identifiable patents in that country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or arrangement, you
convey, or propagate by procuring conveyance of, a covered work, and grant a patent
license to some of the parties receiving the covered work authorizing them to use,
propagate, modify or convey a specific copy of the covered work, then the patent
license you grant is automatically extended to all recipients of the covered work and
works based on it.

A patent license is &ldquo;discriminatory&rdquo; if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on the
non-exercise of one or more of the rights that are specifically granted under this
License. You may not convey a covered work if you are a party to an arrangement with
a third party that is in the business of distributing software, under which you make
payment to the third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties who would receive
the covered work from you, a discriminatory patent license (a) in connection with
copies of the covered work conveyed by you (or copies made from those copies), or (b)
primarily for and in connection with specific products or compilations that contain
the covered work, unless you entered into that arrangement, or that patent license
was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting any implied
license or other defenses to infringement that may otherwise be available to you
under applicable patent law.

### 12. No Surrender of Others' Freedom

If conditions are imposed on you (whether by court order, agreement or otherwise)
that contradict the conditions of this License, they do not excuse you from the
conditions of this License. If you cannot convey a covered work so as to satisfy
simultaneously your obligations under this License and any other pertinent
obligations, then as a consequence you may not convey it at all. For example, if you
agree to terms that obligate you to collect a royalty for further conveying from
those to whom you convey the Program, the only way you could satisfy both those terms
and this License would be to refrain entirely from conveying the Program.

### 13. Use with the GNU Affero General Public License

Notwithstanding any other provision of this License, you have permission to link or
combine any covered work with a work licensed under version 3 of the GNU Affero
General Public License into a single combined work, and to convey the resulting work.
The terms of this License will continue to apply to the part which is the covered
work, but the special requirements of the GNU Affero General Public License, section
13, concerning interaction through a network will apply to the combination as such.

### 14. Revised Versions of this License

The Free Software Foundation may publish revised and/or new versions of the GNU
General Public License from time to time. Such new versions will be similar in spirit
to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program specifies that
a certain numbered version of the GNU General Public License &ldquo;or any later
version&rdquo; applies to it, you have the option of following the terms and
conditions either of that numbered version or of any later version published by the
Free Software Foundation. If the Program does not specify a version number of the GNU
General Public License, you may choose any version ever published by the Free
Software Foundation.

If the Program specifies that a proxy can decide which future versions of the GNU
General Public License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the Program.

Later license versions may give you additional or different permissions. However, no
additional obligations are imposed on any author or copyright holder as a result of
your choosing to follow a later version.

### 15. Disclaimer of Warranty

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM &ldquo;AS IS&rdquo; WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE
QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

### 16. Limitation of Liability

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY
COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS
PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE
WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

### 17. Interpretation of Sections 15 and 16

If the disclaimer of warranty and limitation of liability provided above cannot be
given local legal effect according to their terms, reviewing courts shall apply local
law that most closely approximates an absolute waiver of all civil liability in
connection with the Program, unless a warranty or assumption of liability accompanies
a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS

## How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest possible use to
the public, the best way to achieve this is to make it free software which everyone
can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest to attach them
to the start of each source file to most effectively state the exclusion of warranty;
and each file should have at least the &ldquo;copyright&rdquo; line and a pointer to
where the full notice is found.

    WebToEpub, an extension used to convert popular books on pages like baka-tsuki into epub format.
    Copyright (C) 2015  David Teviotdale

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short notice like this
when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type 'show c' for details.

The hypothetical commands 'show w' and 'show c' should show the appropriate parts of
the General Public License. Of course, your program's commands might be different;
for a GUI interface, you would use an &ldquo;about box&rdquo;.

You should also get your employer (if you work as a programmer) or school, if any, to
sign a &ldquo;copyright disclaimer&rdquo; for the program, if necessary. For more
information on this, and how to apply and follow the GNU GPL, see
&lt;<http://www.gnu.org/licenses/>&gt;.

The GNU General Public License does not permit incorporating your program into
proprietary programs. If your program is a subroutine library, you may consider it
more useful to permit linking proprietary applications with the library. If this is
what you want to do, use the GNU Lesser General Public License instead of this
License. But first, please read
&lt;<http://www.gnu.org/philosophy/why-not-lgpl.html>&gt;.

================================================
FILE: package.json
================================================

{
  "name": "@dteviot/web_to_epub",
  "version": "1.0.0",
  "description": "Extension for Chrome and Firefox that converts a story on Baka-Tsuki (or a number of other sites) into an EPUB.",
  "dependencies": {
    "@zip.js/zip.js": "~2.7.72",
    "dompurify": "^3.2.6"
  },
  "devDependencies": {
    "@xmldom/xmldom": "^0.7.5",
    "copyfiles": "^2.4.1",
    "eslint": "^8.0.0",
    "http-server": "^13.0.2",
    "web-ext": "_"
  },
  "main": "popup.html",
  "directories": {
    "doc": "doc"
  },
  "scripts": {
    "up": "npm add @zip.js/zip.js@latest && npm install",
    "postinstall-zip": "copyfiles -V -u 1 node_modules/@zip.js/zip.js/dist/zip-no-worker.min.js plugin",
    "postinstall-DOMpurify": "copyfiles -V -u 1 node_modules/dompurify/dist/purify.min.js plugin",
    "postinstall": "npm run -s postinstall-zip && npm run -s postinstall-DOMpurify",
    "test": "http-server -o unitTest/Tests.html",
    "lint": "cd eslint && node pack.js && eslint packed.js",
    "lint:fix": "eslint --config eslint/.eslintrc.js --fix plugin/js",
    "web-ext": "cd eslint && cp_.xpi temp.xpi && web-ext lint -w -s temp.xpi && rm temp.xpi",
    "build": "cd eslint && node pack.js",
    "release": "node eslint/release.js"
  },
  "repository": {
    "type": "git",
    "url": "git+<https://github.com/dteviot/WebToEpub.git>"
  },
  "keywords": ["epub"],
  "author": {
    "name": "David Teviotdale",
    "email": "<dteviot@gmail.com>"
  },
  "contributors" : [
    { "name": "Alen Toma"},
    { "name": "Anartigone"},
    { "name": "Asif Mahmood"},
    { "name": "Aurimas Niekis"},
    { "name": "Markus Vieth"},
    { "name": "Michael Fox"},
    { "name": "typhoon71"},
    { "name": "toshiya44"},
    { "name": "dreamer2908"},
    { "name": "GallusMax"},
    { "name": "Hogesyx"},
    { "name": "snnsnn"},
    { "name": "Tom Goetz"},
    { "name": "Sergii Pravdzivyi"},
    { "name": "JimmXinu"},
    { "name": "gamebeaker"},
    { "name": "Mathnerd314"},
    { "name": "Kondeeza"},
    { "name": "Sickan90"},
    { "name": "Kiradien"},
    { "name": "Miracutor"},
    { "name": "Synteresis"},
    { "name": "Lej77"},
    { "name": "nandakishore2009"},
    { "name": "courli79"},
    { "name": "alethiophile"},
    { "name": "Dimava"},
    { "name": "Leone Jacob Sunil (ImLJS)"},
    { "name": "Yoanhg421"},
    { "name": "xRahul"},
    { "name": "Oleksii Taranenko"},
    { "name": "Naheulf"},
    { "name": "perishableloc"},
    { "name": "praschke"},
    { "name": "ImmortalDreamer"},
    { "name": "ktrin"},
    { "name": "Tyderion"},
    { "name": "nozwock"},
    { "name": "Darthagnon"},
    { "name": "LucasFreitaslpf1"},
    { "name": "Jemeni11"},
    { "name": "maforn"},
    { "name": "phazei"},
    { "name": "rizkiv1"},
    { "name": "pavan3999"},
    { "name": "ltsKbrc"},
    { "name": "crybx"},
    { "name": "Ori Avtalion"},
    { "name": "NamTH"},
    { "name": "minhngoc25a"},
    { "name": "basitcodeenv"},
    { "name": "X-Xadro"},
    { "name": "Yomafil"},
    { "name": "Varun Patkar", "email": "varunpatkar501@gmail.com" },
    { "name": "Peter Kaufman", "email": "PeterJamesKaufman@gmail.com" },
    { "name": "patiorjunrick"},
    { "name": "MD Shabrez" },
    { "name": "jurassicplayer" },
    { "name": "X2E4VXpZKv" },
    { "name": "johnpyp", "email": "johnpyp.dev@gmail.com" },
    { "name": "meson1271" },
    { "name": "AgatZan" },
    { "name": "Joel Sunil" },
    { "name": "nothing0074", "email": "phong322010@proton.me" }
  ],
  "license": "GPL-3.0-only",
  "bugs": {
    "url": "<https://github.com/dteviot/WebToEpub/issues>"
  },
  "homepage": "<https://github.com/dteviot/WebToEpub#readme>",
  "private": true
}

================================================
FILE: doc/CodeProjectNotes.html
================================================

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <TITLE></TITLE>
 <STYLE TYPE="text/css">
 </STYLE>
</HEAD>
<BODY LANG="en-NZ" DIR="LTR">
<H1>Web to EPUB Extension for Chrome</H1>
<p><br />
</p>
<h2>Introduction</h2>
<p><br />
</p>
<p>If you're like me, you will have
discovered that there are many sites on the Internet that have
fiction that is free to read. For example,
<a HREF="http://archiveofourown.org/">http://archiveofourown.org</a>.
Unfortunately, most of these sites have two minor drawbacks. Firstly,
because they're online sites, you need to be on-line to view them.
Second, the individual chapters of each story (and the good stories
almost always have multiple chapters) are on multiple web pages. So
you need to go between the web pages to read the story.</p>
<p>Consequently, when after reading the
first chapter of one of these stories, I've often wished that I could
press a single button on my browser and have the whole story saved to
an EPUB file in my downloads directory, ready to copy to my EPUB
viewer.</p>
<p>Well, it turns out that it's possible
to write "extensions" for Google's Chrome browser, which
allow you to add additional functionality to Chrome. So, I've used
that to to create a "Save to EPUB" plug-in, and I'm now
going to show you how it's done, so you can use it, and extend it to
handle the sites you like.
</p>
<p><br />
</p>
<p>The topics covered are:
</p>
<ul>
    <li>The basics of building a Chrome extension.</li>
    <li>How to get your extension to read the HTML of a web page in a Chrome tab.</li>
    <li>How to use Chrome to examine a web page to figure out the author, title and list of chapters of a story, then write JavaScript to extract the information.</li>
    <li>How to get Chrome to fetch additional web pages automatically.</li>
    <li>How to pack the web pages into an EPUB file.</li>
    <li>Some notes on Unit testing.</li>
    <li>How to add a parser for a site you like.</li>
</ul>
<p><br />
</p>
<h2>Using the Code or "How to load an Extension into Chrome"</h2>
<p>For those of you who just want to use the code, the basic steps are:
</p>
<ul>
 <li>Download the code for this Extension.</li>
    <li>Load the Extension in the folder "plugin" into Chrome. (See section below.)</li>
    <li>Go to web page you want to extract the story from. Note, currently the only site that's supported is <a href="http://archiveofourown.org/">Archive of Our Own</a>. So for a test try loading a story from there.</li>
    <li>Click on the "Web To EPUB" action button <img src="02-book128.png" /> that's now on the chrome toolbar. <img src="01-ActionButton.png" /></li>
    <li>Check that the story details on the popup are correct.</li>
    <li>Press "Fetch Chapters" button and wait for them to load.</li>
    <li>Press "Pack EPUB" button.</li>
</ul>
<p><br />
</p>
    <h3>Steps to load an extension into Chrome are:</h3>
<ul>
 <li>Open Chrome and type "chrome://extensions" into the browser.</li>
    <li>Make sure "Developer Mode" at the top of the page is checked.</li>
    <li>Press the "Load unpacked extension.." button and browse to the root folder for the extensions files.</li>
</ul>
<p><br />
</p>
<h2>Basics of Building a Chrome extension</h2>
<p>Google's excellent documentation on building extensions can be found at
<a HREF="http://developer.chrome.com/extensions/getstarted.htm">http://developer.chrome.com/extensions/getstarted.htm</a>.</p>
<p>However, here's the key points.</p>
<ul>
    <li>Extensions are a mixture of HTML and JavaScript.</li>
    <li>Extensions contain the following:
        <ul>
            <li>A manifest, which is JSON that describes the extension.</li>
            <li>A collection of HTML, CCS and JavaScript files that make up the extension.</li>
        </ul>
    </li>
</ul>
<p><br />
</p>
<p>The manifest for the Web To EPUB
extension looks like this:</p>
<pre lang="json">
{
  "manifest_version": 2,
  "name": "WebToEpub",
  "version": "1",
  "icons": { "128": "book128.png" },
  "permissions": ["tabs", "&lt;all_urls&gt;" ],
  "browser_action": {
    "default_title": "",
    "default_icon": "book128.png",
    "default_popup": "popup.html"
  },
  "minimum_chrome_version": "46"
}</pre>
<p><br />
</p>
<p>The major points of note are:
    <ul>
        <li>The extension puts a button on the Chrome toolbar which uses book128.png <img src="02-book128.png" /> as the image on the button.</li>
        <li>When button is pressed, the web page "popup.html" is launched.  So, popup.html is the "main" page of this extension.</li>
        <li>The extension needs the following permissions to work
            <ul>
                <li>tabs: can manipulate the contents on web page Chrome is displaying (i.e. A tab.)</li>
                <li>all_urls: can make HTTP calls to any URL.</li>
            </ul>
        </li>
    </ul>
</p>
<p><br />
</p>
<p>Popup.html is this:</p>
    <pre lang="html">
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;WebToEpub&lt;/title&gt;
    &lt;base /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;style&gt;
        body {
        }
        .scrollingtable {
            overflow: scroll;
            height: 300px;
        }
    &lt;/style&gt;
    &lt;section id="inputSection"&gt;
        &lt;table id="inputTable"&gt;
            &lt;tr&gt;
                &lt;td&gt;Starting URL&lt;/td&gt;
                &lt;td&gt;&lt;input id="startingUrlInput" type="url" name="startingUrlInput" size="80" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Title&lt;/td&gt;
                &lt;td&gt;&lt;input id="titleInput" type="text" name="titleInput" size="80" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Author&lt;/td&gt;
                &lt;td&gt;&lt;input id="authorInput" type="text" name="authorInput" size="80" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Language&lt;/td&gt;
                &lt;td&gt;&lt;input id="languageInput" type="text" name="languageInput" size="80" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        &lt;button id=fetchChaptersButton&gt;Fetch Chapters&lt;/button&gt;
        &lt;button id=packEpubButton&gt;Pack EPUB&lt;/button&gt;
    &lt;/section&gt;
    &lt;section id="testSection"&gt;&lt;/section&gt;
    &lt;section id="outputSection"&gt;
        &lt;div class="scrollingtable"&gt;
            &lt;table id=chapterUrlsTable&gt;
                &lt;tr&gt;
                    &lt;th align=left&gt;Title&lt;/th&gt;
                    &lt;th align=left&gt;Loaded?&lt;/th&gt;
                    &lt;th align=left&gt;URL&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/section&gt;
    &lt;!-- scripts go here --&gt;
    &lt;script src="js/EpubMetaInfo.js"&gt;&lt;/script&gt;
    &lt;script src="js/Util.js"&gt;&lt;/script&gt;
    &lt;script src="js/HttpClient.js"&gt;&lt;/script&gt;
    &lt;script src="js/parsers/ArchiveOfOurOwnParser.js"&gt;&lt;/script&gt;
    &lt;script src="js-lib/jszip.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/EpubPacker.js"&gt;&lt;/script&gt;
    &lt;script src="js/testFunctions.js"&gt;&lt;/script&gt;
    &lt;script src="js/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p><br />
</p>
<p>As you can see, it's an ordinary HTML
file, with fields to show the key attributes of the story: Title,
Author, Language and Chapters.  The only, even slightly, unusual
aspect is that it has no embedded JavaScript.</p>
<p><br />
</p>
<h2>How to read the HTML of a web page on a Chrome tab.</h2>
<p>When this Extension is activated, the first thing it does is find the currently active tab (web page) in Chrome and search it for story information.  Basic steps are:
    <ul>
        <li>Add the "tabs" permission to manifest.json.  (We did this in the previous step.)</li>
        <li>When popup.html starts, a function attached to the onload() event is called.</li>
        <li>This function tells Chrome to inject a "Content Script" into the active web page.</li>
        <li>The Content Script  is a simple JavaScript file that is run within the context of the active server page, so has access to the page's Document Object Model (DOM.)</li>
        <li>The script reads the DOM and sends a serialized copy of it back to popup.html as a message.</li>
        <li>Popup.html listens for the message, which will return asynchronously.  When the message arrives, the DOM is de-serialized and parsed to extract the story information to populate popup.html</li>
        <li>Note that because the message returns asynchronously, the onload() function needs to set up a listener for the message before injecting the Content Script.</li>
    </ul>
</p>
<p><br />
</p>
<p>The contents of the Content Script looks like this:</p>
<pre code="javascript">
// pack the DOM of this page into a message
var parseResults = {
    messageType: "ParseResults",
    document: document.all[0].outerHTML,
};

// send message back to our extension
chrome.runtime.sendMessage(parseResults);</pre>
<p><br />
</p>
<p>And the onload() function in popup.html
looks like this:</p>
<pre code="javascript">
// actions to do when window opens
window.onload = function () {
    // register listener that is called when content script injected into HTML sends its results
    chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
        if (request.messageType == "ParseResults") {
            // convert the string returned from content script back into a DOM
            let dom = new DOMParser().parseFromString(message.document, "text/html");
            // pass the DOM onto our function to extract the story info (more on this later)
            processHtmlFromTab(dom);
        }
    });

    // inject the content script into the active tab.
    // in this case, the content script is in a file called "ContentScript.js"
    chrome.tabs.executeScript({file: "js/ContentScript.js"});    
}</pre>
<p><br />
</p>
<p>And that's all you need to do for an extension to read the current tab's contents in Chrome.
    For more details on what's going on, check out Google's documentation on <a href="https://developer.chrome.com/extensions/content_scripts.html">Content Scripts</a>
    and <a href="http://developer.chrome.com/extensions/messaging.html">Sending Messages</a>.</p>
<p><br />
</p>
<h2>Using Chrome's &quot;Inspect Element&quot; to examine the DOM</h2>
<p>This section assumes you know what a DOM is. If you don't, I suggest you read <a href="http://eloquentjavascript.net/13_dom.html">Chapter 13 of Eloquent Javascript</a>.  Go ahead, I'll wait.</p>
<p>Welcome back. Now that you know what a DOM is and we got the DOM for the web page in the previous section,
 the next step is to extract the information we need from the DOM. The things that we want are:
    <ul>
        <li>Title of the story</li>
        <li>Author of the story</li>
        <li>Title of each chapter</li>
        <li>URL to each chapter</li>
        <li>Language the story is in.  (Note, if you're only interested in American stories, you could skip extracting this and just hard code it to "en-us". If you're only interested in other languages, you could hard code their language code instead.)</li>
    </ul>
</p>
<p>The first step to extracting the information is to figure out how to find it in the DOM.
Fortunately, Chrome has the tools built in to make doing this easy. All you need to do is:
    <ul>
        <li>Open the web page in Chrome</li>
        <li>Place your mouse over the item you're interested in.</li>
        <li>Click the right mouse button</li>
        <li>Select "Inspect Element".</li>
        <li>Chrome will open a window showing the DOM for the web page, with the cursor set to the element you clicked on.</li>
        <li>Examine the DOM to to see how the element can be identified.</li>
    </ul>
</p>
<p>I'll walk you through an example.  Start by loading the page <a href="http://archiveofourown.org/works/685590/chapters/1258295">http://archiveofourown.org/works/685590/chapters/1258295</a>
    and scroll through it until you see the story's Title and Author.  It will look something like this.</p>
<img src="03-WebPage.png" />
<p>Right click on "Judgement Day" and select "Inspect Element".  The Elements window appears at the bottom of the screen, looking something like this</p>
<img src="04-WebPage.png" />
<p>Note the element that is highlighted, this is the element holding the title.</p>
<pre lang="html">
&lt;h2 class="title heading"&gt;
    Judgement Day
&lt;/h2&gt;
</pre>
<p>This shows us that the Title is in a &lt;h2&gt; tag, with a class of "title heading". If we now click on the Author's name on the web page, the following DOM element is highlighted.</p>
<pre lang="html">
&lt;a href="http://archiveofourown.org/users/TheUnknownJohnSmith/pseuds/TheUnknownJohnSmith" class="login author" rel="author"&gt;TheUnknownJohnSmith&lt;/a&gt;
</pre>
<p>So the author is in an "a" tag, with a class of "login author".</p>
<p>Finally, right click on drop down box that shows the list of chapters. The section of DOM looks like</p>
<pre lang="html">
&lt;select id="selected_id" name="selected_id"&gt;&lt;option value="1258295" selected="selected"&gt;1. Chapter 1&lt;/option&gt;
&lt;option value="1258298"&gt;2. Judgement Day Part II&lt;/option&gt;
&lt;option value="1457060"&gt;3. The Chariot&lt;/option&gt;
&lt;option value="1457063"&gt;4. The World&lt;/option&gt;
&lt;option value="1663608"&gt;5. Judgment&lt;/option&gt;
&lt;option value="2342893"&gt;6. Temperance&lt;/option&gt;&lt;/select&gt;
</pre>
<p>As you can see, each chapter is in an "option" tag, with a "value" attribute that is URL of the chapter (relative to the web page).</p>
<p>Finding the language of the story is a bit more difficult, as it's not explicitly shown on the web page.  
    However, if we look at the source of the web page, which Chrome will show if we right click on the page and select "View page source", we find the following</p>
<pre lang="html">
&lt;meta name="keywords" content="fanfiction, transformative works, otw, fair use, archive"&gt;
&lt;meta name="language" content="en-US"&gt;
&lt;meta name="subject" content="fandom"&gt;
</pre>
<p>So the language is the "content" attribute of "meta" tag, with a "name" attribute "language".</p>
<p><br />
</p>
<p>Now that we know where the information we want is in the DOM, the next step is to extract it.  Let's start with the title.
    As previously mentioned, the title is in a &lt;h2&gt; tag, with a class of "title heading".  
    So, given the DOM object returned by the ContentScript, the following function will extract the title.</p>
<pre lang="JavaScript">
    extractTitle: function(dom) {
    // first, get a list of all "h2" elements in the document
    let elements = dom.getElementsByTagName("h2");

    // getElementsByTagName() returns a HTMLCollection, convert it into an array
    elements = Array.prototype.slice.apply(elements);

    // remove all elements that do not have a class name of "title heading"
    elements = elements.filter(e =&gt; e.className === "title heading");

    // if the list has an element, then we've found the element we're looking for, so return its innerText.
    return (elements.length != 0) ? elements[0].innerText() : null;
}</pre>
<p><br />
</p>
    <p>The two interesting parts are the functions <b>getElementsByTagName()</b> and <b>filter()</b>.</p>
    <p><b>getElementsByTagName()</b> does just what it's name suggests, it returns all elements in the DOM with the specified tag.
    Actually, it's more powerful that that. As well as searching an entire DOM, if you give it an element of the DOM, it will search the child nodes of that element.
    This can be useful if you wanted to find a specific child node of a section of the DOM.</p>

<p>The <b>.filter()</b> function removes the &lt;h2&gt; elements that don't have a className of "title heading".
    The essentials of filter() are it takes an array of objects and a function that returns true or false. (The technical term for this is a predicate.)
    Given these two inputs, filter() builds and a new array that containing all elements that the predicate returns true for.
    In the above function, <b>e =&gt; e.className === "title heading"</b> is the predicate, I've written it as an arrow function expression that newer versions of Chrome support (it's part of the ECMAScript 6 standard.)
    This is just a shorthand way of saying: <b>function(e) { return e.className === "title heading"; }</b>.  Congratulations! You've just had your first introduction to <a href="http://eloquentjavascript.net/05_higher_order.html">functional programming.</a></p>

<p>Now that we've seen how to get the Title, it should be obvious that getting the author is an almost identical process.  
    The only difference is we look for an <b>&lt;a&gt;</b> element, with a class of <b>"login author"</b>. </p>

<p>Finding the Language is also easy.</p>
<ul>
    <li>Use getElementsByTagName() to find the &lt;option&gt; elements.</li>
    <li>The predicate must test for an element with a "name" attribute of "language".  Which is <b>e =&gt; (e.getAttribute("name") === "language")</b></li>
    <li>The language value isn't the innerText of the element, but the value of the "content" attribute, so call <b>getAttribute()</b> to get the value.</li>
</ul>

<p>Finding an extracting the chapter information is only a tiny bit more complicated. The new wrinkles are</p>
<ul>
    <li>For each chapter we want both the title of the chapter and a URL to the chapter.</li>
    <li>There are multiple chapters.</li>
</ul>
    <p>
        Having to return title and URL for a chapter is easy.
        Once we have an &lt;option&gt; element, the title is the innerText, and the URL is the "value" attribute.
        We already know how to extract both of these.  So, all we need is a function to extract and package them together.
    </p>
<pre lang="JavaScript">
optionToChapterInfo: function(optionElement) {
    return {
        sourceUrl: optionElement.getAttribute("value"),
        title: optionElement.innerText
    };
}</pre>
<p>Handling multiple chapters is also easy.  If you look at the extractTitle() function we wrote previously,
    you'll see that it's handling multiple elements (at least until the last line where it takes just the first element.)  
    So, we can use that code to get an array of &lt;option&gt; elements.  
    After that, it's just a matter of converting the &lt;option&gt; elements array into an array of "chapterInfo" objects.
    And this is really easy.  The following code will do it.</p>
<pre lang="JavaScript">
    return elements.map(optionToChapterInfo);
</pre>
<p>What the <b>map()</b> function does: if you have a function that converts one type of object into a new type
    (which we do, it's optionToChapterInfo we wrote previously) and an array of objects you want converted,
    it will create an array of the new types from the old ones. Functional Programming is awesome.</p>
<p><br />
</p>
<h2>Fetching Web Pages programatically</h2>
<p>Now that we have a list of URLs for the chapters, the next step is to fetch the them.
    This can be done using <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">XMLHttpRequest</a>.
    If you followed the above link, then the only additional thing you need to know is that Chrome requires a "&lt;all_urls&gt;" permission in the extension's manifest.
    For those that didn't follow the link, the basics are:</p>
<ul>
    <li>Create a XMLHttpObject object</li>
    <li>Set a onerror() handler, to deal with any network errors.</li>
    <li>Set a onload() handler, (more on this later)</li>
    <li>Call XMLHttpObject.send() to ask the server for the page.</li>
    <li>If the server responds, the onload() hander will be called asynchronously at a later point in the future.</li>
    <li>In your onload(), check if the server sent an error.  If it's not an error, process the response.</li>
</ul>
<p>The big complication XMLHttpObject, in case you didn't get it, is that the response is asynchronous<sup>1</sup> and we have multiple pages to fetch.
    This requires asynchronous, recursive logic in the onload() handler which checks which chapter has been received, then calls the XMLHttpObject,
    setting the onload() handler to itself when the result arrives.  I'm not going to try explaining it in more detail here because it makes my head hurt.
    If you want to see how it's done, examine onFetchChapters() and onLoadChapter() in main.js of this project.</p>
<p>
    <sup>Note 1</sup>You can use XMLHttpRequest synchronously under some conditions, but it's not a good idea.  Read the XMLHttpRequest docs for details.
</p>
<p><br />
</p>
<h2>Creating an EPUB</h2>
<p>At this point, you have the web pages making up the story and the story's metadata (Title, Author, source URL and language).
    This is everything you need to create an EPUB for the story.
    The <a href="http://www.idpf.org/epub/301/spec/epub-overview.html">full EPUB specifications</a> (currently version 3.0.1) are available on the web.  
    If you find those documents lengthy, <a href="http://en.wikipedia.org/wiki/EPUB">Wikipedia has an excellent summary</a>.
 Or, you could read my <a href="http://www.codeproject.com/Articles/592909/EPUB-Viewer-for-Android-with-Text-to-Speech">earlier article</a> on building an EPUB reader.
    If that's still too lengthy, here's the thumbnail "An EPUB is a zip containing web pages and some files that describe how to view the web pages."</p>
<p>Therefore, if we're going to create an EPUB, the first thing we're going to need is a way to make a zip file in JavaScript.
   I use the <a href="https://stuk.github.io/jszip/">jszip library</a> for this, it's very easy to use. There's just three steps needed.</p>
<ul>
    <li>Create a JSZip object</li>
    <li>Call file() on the JSZip object to add each file into it.</li>
    <li>Call generate() to get the zip file as a blob. (Which you can then save.)</li>
</ul>
<p>Jumping back to the "some files that describe how to view the web pages", there are 4 files we need.</p>
<ul>
    <li>mimetype: an uncompressed ASCII file that contains the string <b>application/epub+zip</b></li>
    <li>container.xml in directory META-INF:  an XML file that specifies which file in the zip is the OPF file.</li>
    <li>OPF: XML file that describes all the other files in the zip, and their reading order.</li>
    <li>Table of Contents: XML file that says where each chapter is in the zip.</li>
</ul>
<p>Adding a mimetype file to the zip is trivial, as it's just a string, the following code will do the job.</p>
<pre lang="JavaScript">zipFile.file("mimetype", "application/epub+zip");</pre>
<p>Adding the container.xml file is almost as easy.
    Because we will always use the same name for our OPF file, container.xml is also just a constant string.  
    So, code to add container.xml is identical to that for mimetype, except we replace "mimetype" with "META-INF/container.xml" and
    "application/epub+zip" with the XML for container.xml.</p>
<p>Adding the OPF file is not much more difficult, even thought we need to build it using the information about the story before we can add it to the zip file.
    That said, the OPF file is XML and has a simple structure.  
    My <a href="http://www.codeproject.com/Articles/592909/EPUB-Viewer-for-Android-with-Text-to-Speech">earlier article</a> on parsing an EPUB file describes the OPF structure, so I won't repeat it here.
    Assembling the XML to build such a structure is easy.  You could do it by inserting text into strings, if you wanted.
    I would advise against doing it that way, it fails when the text you're inserting contains characters that need to be escaped.
    Using a DOM and add elements to it is just as easy, much safer, and easier to understand.
    To see how it's done, look at the function buildContentOpf() in EpubPacker.js.</p>
<p>Once we have the OPF file, we want to add it to the file as a compressed file. This is trivial:</p>
<pre lang="JavaScript">zipFile.file("content.opf", buildContentOpf(), { compression: "DEFLATE" });</pre>
<p>Like the OPF, the "Table of Contents" (ToC) is a simple XML file that needs to built before it can be saved.
    There's nothing new to creating the ToC that you didn't see for the OPF, look at buildTableOfContents() in EpubPacker.js if you want to see the details.</p>
<p>Next step is to add the web pages to the zip.
    There is a minor complication.  The EPUB 2 specification requires these web pages to be XHTML, also known as HTML 4.  
    But web pages fetched from the Internet are usually HTML.
    I solve this problem by stripping the actual story content from the fetched web page, inserting it into a blank XHTML document, which is added to the zip file.
    As a beneficial side effect, this process usually strips out JavaScript and CCS file links as well.  So you don't need to fetch these files and pack them into the EPUB.
    </p>
<p>Once all the files have been added to the zip, the final step is to generate a blob and save the blob to your browser's "Downloads" folder.  
    Ideally, we'd just call saveAs() to do this, but Chrome no longer supports it.
    So, we can either use a <a href="http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js">polyfill library</a>, or use code like this</p>
<pre lang="JavaScript">
saveAs: function (blob, fileName) {
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    a.click();
}</pre>
<p><br />
</p>
<h2>Unit testing notes</h2>
<p>This is the third JavaScript program I've attempted to write.
    One of the things I quickly learned was that providing unit tests to exercise the code as it was being written was vital.
    The only way to know if your JavaScript works (or is even syntactically valid) is to run it.
    Having working unit tests means that I could verify that the code I'd just written by (re)loading the web page Tests.html in unitTest folder. i.e. Clicking refresh in Chrome.
    I didn't need to manually drive the extension's UI. Which got very tedious after the 200th time.</p>
<ul>
    <li>The <a href="http://qunitjs.com/intro/">qunit framework</a> is used to do the testing. This is a light, easy to use framework created and used by jQuery.</li>
    <li>As the plug-in's primary task is to parse HTML, most of the tests involved loading a known HTML file, calling functions to parse the HTML and checking the functions returned the correct results.</li>
    <li>So, for your testing your parsers, you will probably want to downloaded sample web pages and save them to disk for testing.</li>
    <li>By default, Chrome won't allow extensions to access files on the disk, so you need to start Chrome with the "--allow-file-access-from-files" flag. Warning, you must not have any instances of Chrome running when you try starting Chrome with this flag.</li>
</ul>

<h2>How to add a parser for a site you like.</h2>
<p>If you've gotten this far, I'm going to assume you want to modify this extension to save files from a site you like.  So I'll give you some tips.</p>
<ul>
    <li>The file ArchiveOfOurOwnParser.js is the one that does all the parsing. So, to handle a different site you'd just need to modify this file.  Or take a copy of it and modify the copy.</li>
    <li>ArchiveOfOurOwnParser.js has 3 functions that are called by the rest of the extension, the rest of the functions in the class just implement the 3 "interface" functions.</li>
    <li>So, to create your own parser, you need to implement these 3 functions. They are:
        <ul>
            <li>getEpubMetaInfo().  This takes a DOM and returns an EpubMetaInfo. Basically, the story's Author, Title, language and URL.</li>
            <li>getChapterUrls().  Takes a DOM and returns and array of chapterInfo objects.</li>
            <li>extractContent().  Takes a DOM and returns the elements of the DOM holding the chapter's text.</li>
        </ul>
    </li>
</ul>
<h2>Miscellaneous stuff</h2>
<ul>
    <li>I'd like to thank my co-workers, Paul, SeanO and Ross for their assistance in preparing this article:</li>
    <li>This article is licensed under <a href="http://www.codeproject.com/info/cpol10.aspx" rel="license">The Code Project Open License (CPOL)</a></li>
    <li>The code for the plug-in itself is licensed under GPL v3.</li>
    <li>The latest version of the extension's code can be found on <a href="https://github.com/dteviot">GitHub</a>.</li>
</ul>
</BODY>
</HTML>

================================================
FILE: doc/License.html
================================================

<?xml version='1.0' encoding='utf-8' ?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" dir="ltr" class="client-js" xml:lang="en-GB">
<head>
    <title>License</title>
</head>
<body>
    <h1>License</h1>
    <p>WebToEpub - A Chrome plug-in that packs a story from the "Archive of Our Own" into an EPUB.</p>
    <p>(c) 2015 David Teviotdale</p>
    <p>Dual licenced under the MIT license or GPLv3.</p>
    <p></p>
    <p>WebToEpub uses the following libraries:
        <ul>
            <li>zip.js library: <a href="https://gildas-lormeau.github.io/zip.js/">https://gildas-lormeau.github.io/zip.js/</a>, which is licensed with BSD-3-Clause license.</li>
            <li>quint: <a href="http://qunitjs.com/">http://qunitjs.com/</a>, licensed under MIT license.</li>
        </ul>
    </p>
</body>
</html>

================================================
FILE: doc/ToDo.htm
================================================

<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" dir="ltr" class="client-js" xml:lang="en-GB">
  <head>
    <title>ToDo List</title>
</head>
<body>
<h2>ToDo List for HtmlToEpub Chrome App</h2>
<h3>Steps to create EPUB Phase one (no image file support)</h3>
<ul>
<li>Specify working directory and URL to download</li>
<li>Fetch initial file from web.  Investigate WebView.</li>
<li><strike>Parse file for content (chapter) URLs</strike></li>
<li><strike>Fetch the chapter HTML documents</strike></li>
<li><strike>Extract wanted text from documents and repackage. Strip javascript, comments, stylesheets</strike></li>
<li><strike>Phase 1, strip &lt;img&gt; tags</strike></li>
<li><strike>Generate content.opf</strike></li>
<li><strike>Generate Nested ToC</strike></li>
<li><strike>Add correct author to content.opf</strike></li>
<li><strike>Fixup footnotes</strike></li>
<li><strike>Pack epub</strike></li>
</ul>

<h3>Steps to create EPUB Phase two (image support)</h3>
<ul>
<li><strike>May want to split content</strike></li>
<li><strike>Locate images.  Download images and update &lt;img&gt; tags</strike></li>
<li>Adjust UI dynamically, depending on web page being viewed</li>
<li><strike>Move fetching additional content files (XHTML or image) into parser class.</strike></li>
<li><strike>Add images to content.opf and the zip</strike></li>
<li>Rework gallery and inline image tags in HTML files</li>
<li>Fixup any text that appears before or after the gallery image table.</li>
<li><strike>Add cover (does it make sense to add cover to content and ToC, then delelete if not present?</strike></li>
<li>Handle Gallery image different to inline?</li>
<li><strike>Add Style (for images) to XHTML header</strike></li>
</ul>

<h3>Side Tasks</h3>
<ul>
<li>Get code inspected</li>
<li>Check all // ToDo comments have been done.</li>
<li>Figure out cleanest way to add cover + fixup content.opf for cover</li>
<li>Get a better icon</li>
<li>When fix footnotes, Hyperlink can be hash only.</li>
<li>Replace Developer Stuff buttons "Pack Raw Chapters" and "Fetch Chapters" with single "Fetch and Save Raw".</li>
<li>Improve HTML to XHTML conversion and packaging to ePUB.
<ul>
<li>Detect and fix up hypterlinks to same page.</li>
<li>Remove any id attributes that are no longer needed</li>
</ul></li>
<li>fate:zero chapter 3, generates a lot of epubcheck warnings. Looks like it may have different formatting for translator notes.</li>
</ul>

<h3>Immediate Tasks</h3>
<ul>
<li>Check if still need to append "?view_adult=true" to URLs.</li>
<li>Check cookies associated with XMLHttpRequest</li>
<li>Investigate onmouseout event for saving settings</li>
</ul>

<h3>Finished Tasks</h3>
<ul>
<li><strike>Figure out how to load file resources synchronously for unit testing</strike></li>
<li><strike>Convert into Chrome extension.  Need to look into how to do fetch.</strike></li>
<li><strike>Remove the images part of UI for time being</strike></li>
<li><strike>Parse title and author out of document</strike></li>
<li><strike>Add language to epub properties</strike></li>
<li><strike>Download process: Give error message on failure</strike></li>
<li><strike>Update progress downloading chapters</strike></li>
<li><strike>Check if Zip/Download can handle files > 10 Mbyte</strike></li>
<li><strike>For Fetch, read URL from web page.</strike></li>
<li><strike>Parse title and author out of document</strike></li>
<li><strike>How to correctly add XML comment to start of X(HT)ML files.</strike></li>
<li><strike>Create Icon.</strike></li>
<li><strike>Extract just the bits I need out of FileSaver.js.</strike></li>
<li><strike>Get Icon</strike></li>
<li><strike>Document Licenses</strike></li>
<li><strike>Add a git link to github?</strike></li>
<li><strike>Move "Fetch Chapters" and "Fetch Images" buttons to diagnostics.  Fetch chapters/images as part of clicking "Pack EPUB"</strike></li>
<li><strike>What to do for Baka-Tsuki with no images?  e.g. https://www.baka-tsuki.org/project/index.php?title=Anohana:Part_1</strike></li>
<li><strike>Cover image needs to be packaged as SVG image element</strike></li>
<li><strike>Baka-Tsuki, needs to check for &lt;img&gt; elements that were not processed.  See: https://www.baka-tsuki.org/project/index.php?title=Gekkou </strike></li>
<li><strike>Rework ParserFactory class, to be Map based.  (May make testing easier?)</strike></li>
<li><strike>Get BakaTsukiEpubItemSupplier ctor to call EpubItemSupplier ctor?</strike></li>
<li></strike>Unify EpubItemSupplier (which uses chapters) and BakaTsukiItemSupplier (which uses EpubItem). Get EpubItemSupplier to use EpubItem.  Also EpubItem/BaskTsukiEpubItem</strike></li>
<li><strike>Update instructions</strike></li>
<li><strike>Rework Parser.fetchChapters() should really load the images associated with each page after relevant page, rather than all at the end. Although this leaves question of when to fetch cover image, if one is wanted.</strike></li>
<li><strike>Strip iframe elements</strike></li>
<li><strike>Replace &lt;center&gt; tags, they're not legal XHTML.</strike></li>
<li><strike>EpubPacker.save() needs to get rid of object created by createObjectURL() when we're done with it.</strike></li>
<li><strike></strike></li>
<li><strike></strike></li>
</ul>

<h3>Links</h3>
<ul>
<li>XMLHttpRequest
<ul>
<li>https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</li>
<li>https://developer.mozilla.org/en-US/docs/HTML_in_XMLHttpRequest</li>
<li>https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data</li>
<li>https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Monitoring_progress</li>
</ul>
<li>FileSystem
<ul>
<li>https://developer.chrome.com/apps/fileSystem</li>
<li>https://github.com/GoogleChrome/chrome-app-samples/tree/master/samples/filesystem-access</li>
<li>https://developer.mozilla.org/en-US/docs/Web/API/FileEntry</li>
<li>http://www.html5rocks.com/en/tutorials/file/filesystem/</li>
<li></li>
</ul>
<li>Javascript Zip library
<ul>
<li>https://stuk.github.io/jszip/</li>
</ul>
<li>Saving file to downloads
<ul>
<li>https://github.com/eligrey/FileSaver.js/</li>
</ul>
</ul>

<h3>Notes</h3>
<ul>
<li>https://github.com/GoogleChrome/chrome-app-samples/tree/master/samples/messaging</li>
<li>First chapter may have some text before the opening title.</li>
<li>Not all images appear in the text.</li>
<li>Image tag not being closed because HtmlNode._ownerdocument not set for inner nodes.</li>
<li>For our purposes, EPUB only has two file types, XHTML files, and image files
<ul>
    <li>The HTML files are in reading order (i.e. Appear in same order as spine, and table of contents)</li>
    <li>First image, (if there are any) will be the cover image</li>
</ul>
<li>use --allow-file-access-from-files for unit testing in Chrome, note, close all instances of Chrome before running with this flag.</li>
</li>
</ul>

<h3>Question</h3>
<ul>
<li>How to validate image tags?</li>
</ul>

</body></html>

================================================
FILE: eslint/pack.js
================================================

// simple node.js script to pack the files making up WebToEpub into single file
"use strict";

var fs = require("fs");
var zipjs = require("../node_modules/@zip.js/zip.js/index.cjs");
var DOMParser = require("@xmldom/xmldom").DOMParser;

var extractFileListFromHtml = function(htmlAsString) {
    let dom = new DOMParser().parseFromString(htmlAsString, "text/html");
    if (dom != null) {
        return Array.from(dom.getElementsByTagName("script"))
            .map(e => e.getAttribute("src"));
    }
    return [];
}

var getFileList = function(fileName) {
    return readFilePromise(fileName).then(function(data) {
        return extractFileListFromHtml(data.toString());
    });
}

var adjustedFileListForEslint = function(fileList) {
    return fileList
        .filter(e => e !== "@zip.js/zip.js/dist/zip-no-worker.min.js")
        .filter(e => e !== "dompurify/dist/purify.min.js")
        .map(f => "../plugin/" + f);
}

// wrap readFile in a promise
var readFilePromise = function(fileName) {
    return new Promise(function(resolve, reject) {
        console.log("reading file: " + fileName);
        fs.readFile(fileName, function (err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

var writeFilePromise = function(fileName, buffer) {
    return new Promise(function(resolve, reject) {
        console.log("writing file: " + fileName);
        fs.writeFile(fileName, new Buffer(buffer), function (err) {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// package geting all the files
var readAllFiles = function(fileList, loadedFiles) {
    return fileList.reduce(function(sequence, fileName) {
        return sequence.then(function () {
            return readFilePromise(fileName);
        }).then(function(data) {
            console.log("saving file:  " + fileName);
            loadedFiles.push({
                fileName: fileName,
                text:     data.toString()
            });
        });
    }, Promise.resolve());
}

var countLines = function(fileText) {
    return fileText.split("\n").filter(s => s != "").length;
}

var makeIndexLine = function(fileName, startIndex, count) {
    return "\"" + fileName + "\", " + (startIndex + 1) + ", " + (startIndex + count) + "\r\n";
}

//=================================================================
// pack source into packed.js  So its easy to be examined with eslint
// just run eslint against packed.js

var loadedFiles = [];
getFileList("../plugin/popup.html").then(function(fileList) {
    fileList =  adjustedFileListForEslint(fileList);
    console.log(fileList);
    return readAllFiles(fileList, loadedFiles);
}).then(function (data) {
    let temp = "";
    let lineCount = 0;
    let index = "";
    for(let f of loadedFiles) {
        temp += f.text;
        let count = countLines(f.text);
        index +=  makeIndexLine(f.fileName, lineCount, count);
        lineCount += count;
    }
    fs.writeFileSync("packed.js", temp);
    fs.writeFileSync("index.csv", index);
}).catch(function (err) {
    console.log(err);
});

//=================================================================
// This is bit where we pack the extension into a zip & xpi files.

var addToZipFile = function(zip, nameInZip, filePath) {
    return readFilePromise(filePath).then(function (data) {
        zip.add(nameInZip, new zipjs.Uint8ArrayReader(data));
    });
}

var writeZipToDisk = function(zip, filePath) {
    console.log("writeZipToDisk " + filePath);
    return zip.close().then(function (buffer) {
        buffer.arrayBuffer().then(function (arraybuffer) {
            return writeFilePromise(filePath, arraybuffer);
        })
    });
}

var addFilesToZip = function(zip, fileList) {
    return fileList.reduce(function(sequence, fileName) {
        return sequence.then(function () {
            return addToZipFile(zip, fileName, "../plugin/" + fileName);
        });
    }, Promise.resolve());
}

var getLocaleFilesNames = function() {
    return new Promise(function(resolve, reject) {
        fs.readdir("../plugin/_locales", function (err, files) {
            if (err) {
                reject(err);
            } else {
                resolve(files.map(f => "_locales/" + f + "/messages.json"));
            }
        });
    });
}

var addPopupHtmlToZip = function(zip) {
    return readFilePromise("../plugin/popup.html")
        .then(function (data) {
            let htmlAsString = data.toString()
                .split("\r")
                .filter(s => !s.includes("/experimental/"))
                .join("\r");
            zip.add("popup.html", new zipjs.TextReader(htmlAsString));
        })
}

var addBinaryFileToZip = function(zip, fileName, nameInZip) {
    return readFilePromise(fileName)
        .then(function(data) {
            zip.add(nameInZip, new zipjs.Uint8ArrayReader(data));
        });
}

var addImageFileToZip = function(zip, fileName) {
    let dest = "images/" + fileName;
    return addBinaryFileToZip(zip, "../plugin/" + dest, dest);
}

var addCssFileToZip = function(zip, fileName) {
    let dest = "css/" + fileName;
    return addBinaryFileToZip(zip, "../plugin/" + dest, dest);
}

var packNonManifestExtensionFiles = function(zip, packedFileName) {
    return addBinaryFileToZip(zip, "../plugin/book128.png", "book128.png")
        .then(function () {
            return addImageFileToZip(zip, "ChapterStateDownloading.svg");
        }).then(function () {
            return addImageFileToZip(zip, "ChapterStateLoaded.svg");
        }).then(function () {
            return addImageFileToZip(zip, "ChapterStateNone.svg");
        }).then(function () {
            return addImageFileToZip(zip, "ChapterStateSleeping.svg");
        }).then(function () {
            return addImageFileToZip(zip, "FileEarmarkCheck.svg");
        }).then(function () {
            return addImageFileToZip(zip, "FileEarmarkCheckFill.svg");
        }).then(function () {
            return addCssFileToZip(zip, "default.css");
        }).then(function () {
            return addCssFileToZip(zip, "alwaysDark.css");
        }).then(function () {
            return addCssFileToZip(zip, "autoDark.css");
        }).then(function () {
            return getFileList("../plugin/popup.html");
        }).then(function(fileList) {
            return getLocaleFilesNames().then(function(localeNames) {
                return ["js/ContentScript.js"].concat(localeNames)
                    .concat(fileList.filter(n => !n.includes("/experimental/")));
            });
        }).then(function (fileList) {
            return addFilesToZip(zip, fileList);
        }).then(function () {
            return addPopupHtmlToZip(zip);
        }).then(function() {
            return writeZipToDisk(zip, packedFileName);
        }).then(function() {
            console.log("Wrote Zip to disk");
        }).catch(function (err) {
            console.log(err);
        });
}

var makeManifestForFirefox = function(data) {
    let manifest = JSON.parse(data.toString());
    delete(manifest.incognito);
    manifest.manifest_version = 2;

    // fix permissions/host_permissions
    let permissions = manifest.permissions;
    permissions = permissions.filter(p => p != "scripting");
    // Add webRequestBlocking for Firefox
    if (permissions.includes("webRequest") && !permissions.includes("webRequestBlocking")) {
        permissions.push("webRequestBlocking");
    }
    manifest.permissions = permissions.concat(manifest.host_permissions);
    delete manifest.host_permissions;
    
    // rename action => browser_action
    manifest.browser_action = manifest.action;
    delete manifest.action;
    return manifest;    
}

var makeManifestForChrome = function(data) {
    let manifest = JSON.parse(data.toString());
    delete(manifest.browser_specific_settings);
    delete(manifest.action.browser_style);
    manifest.permissions = manifest.permissions
        .filter(p => !p.startsWith("webRequest"));
    return manifest;
}

var packExtension = function(manifest, fileExtension) {
    let zipFileWriter = new zipjs.BlobWriter("application/epub+zip");
    let zipWriter = new zipjs.ZipWriter(zipFileWriter, {useWebWorkers: false,compressionMethod: 8, extendedTimestamp: false});
    zipWriter.add("manifest.json", new zipjs.TextReader(JSON.stringify(manifest)));
    return packNonManifestExtensionFiles(zipWriter, "WebToEpub" + manifest.version + fileExtension);
}

// pack the extensions for Chrome and firefox
readFilePromise("../plugin/manifest.json")
    .then(function (data) {
        packExtension(makeManifestForFirefox(data), ".xpi");
        packExtension(makeManifestForChrome(data), ".zip");
    }).catch(function (err) {
        console.log(err);
    });

================================================
FILE: eslint/release.js
================================================

"use strict";

var fs = require("fs");
var { execSync } = require("child_process");

let version = JSON.parse(fs.readFileSync("plugin/manifest.json", "utf-8")).version;
let isDraft = process.argv.includes("draft");
let isPrerelease = process.argv.includes("pre");
let commitHash = execSync("git rev-parse --short HEAD").toString().trim();
let commitLongHash = execSync("git rev-parse HEAD").toString().trim();
let nameVersion = isPrerelease ? `${version}.pre-${commitHash}` : version;
let branch = execSync("git rev-parse --abbrev-ref HEAD");
let masterCommitHash = execSync("git rev-parse origin/master").toString().trim();

if (!isPrerelease) {
    if (branch != "master") {
        throw new Error("Can not make a full release: not on master branch");
    }
    if (commitLongHash != masterCommitHash) {
        throw new Error("Can not make a full release: master is not pushed to remote");
    }
}

execSync("npm run lint");

let chromeName = `./eslint/WebToEpub${version}.zip`;
let firefoxName = `./eslint/WebToEpub${version}.xpi`;
let chromeCopyName = `./eslint/WebToEpub.chrome.${nameVersion}.zip`
let firefoxCopyName = `./eslint/WebToEpub.firefox.${nameVersion}.zip`;

fs.copyFileSync(chromeName, chromeCopyName);
// make firefox version a zip for user to unzip, because unsigned xpis can't be installed
fs.copyFileSync(firefoxName, firefoxCopyName);

let command = `
gh release create
 ${version}${isPrerelease ? ".pre-" + commitHash : ""}
 --title ${version}${isPrerelease ? ".pre-" + commitHash : ""}
 ${chromeCopyName}
 ${firefoxCopyName}
 --target ${isPrerelease ? commitLongHash : "master"}
 --notes ""
 ${isPrerelease ? "--prerelease" : ""}
 ${isDraft ? "--draft" : ""}
`.replace(/\n\t?/g, " ").trim();

console.log(command)
execSync(command, {stdio: "inherit"});

================================================
FILE: eslint/.eslintrc.js
================================================

module.exports = {
    "env": {
        "browser": true,
        "es6": true,
        "webextensions": true,
    },
    "parserOptions": {
        "ecmaVersion": 2022
    },
    "extends": "eslint:recommended",
    "rules": {
        "indent": [
            "error",
            4,
            { "SwitchCase": 1 }
        ],
        "linebreak-style": "off",
        "no-extra-semi": [
            "error"
        ],
        "quotes": [
            "error",
            "double"
        ],
        "semi": [
            "error",
            "always"
        ],
        "no-undef": "error",
        "no-unused-vars": "error",
        // needed to avoid no-redeclare errors for our project globals below
        "no-redeclare": ["error", { "builtinGlobals": false }],
        "space-before-blocks": ["error", "always"],
        "space-before-function-paren": ["error", {
            "anonymous": "never",    // function() {}
            "named": "never",        // function foo() {}
            "asyncArrow": "always"   // async () => {}
        }],
        // Space around keywords (if, for, etc.)
        "keyword-spacing": ["error", {
            "before": true,
            "after": true
        }],
    },
    "globals": {
        // Third-party libraries
        "DOMPurify": "readonly",
        "zip": "readonly",

        // Project globals
        "BakaTsukiImageCollector": "readonly",
        "BakaTsukiParser": "readonly",
        "BakaTsukiSeriesPageParser": "readonly",
        "BlockedHostNames": "readonly",
        "BlogspotParser": "readonly",
        "ChapterEpubItem": "readonly",
        "ChapterUrlsUI": "readonly",
        "CoverImageUI": "readonly",
        "DefaultParser": "readonly",
        "DefaultParserSiteSettings": "readonly",
        "DefaultParserUI": "readonly",
        "Download": "readonly",
        "EpubItem": "readonly",
        "EpubItemSupplier": "readonly",
        "EpubMetaInfo": "readonly",
        "EpubPacker": "readonly",
        "ErrorLog": "readonly",
        "FetchCache": "readonly",
        "FetchErrorHandler": "readonly",
        "FetchImageErrorHandler": "readonly",
        "Firefox": "readonly",
        "FootnoteExtractor": "readonly",
        "HttpClient": "readonly",
        "ImageCollector": "readonly",
        "ImageInfo": "readonly",
        "Imgur": "readonly",
        "Library": "readonly",
        "MadaraParser": "readonly",
        "main": "readonly",
        "NovelfullParser": "readonly",
        "Parser": "readonly",
        "parserFactory": "readonly",
        "ProgressBar": "readonly",
        "ReadingList": "readonly",
        "RoyalRoadParser": "readonly",
        "UIText": "readonly",
        "UserPreferences": "readonly",
        "util": "readonly",
        "VariableSizeImageCollector": "readonly",
        "WordpressBaseParser": "readonly"
    }
};

================================================
FILE: plugin/manifest.json
================================================

{
  "manifest_version": 3,
  "name": "WebToEpub",
  "version": "1.0.11.7",
  "default_locale": "en",
  "icons": {
    "128": "book128.png"
  },
  "permissions": [
    "cookies",
    "downloads",
    "webRequest",
    "declarativeNetRequest",
    "scripting",
    "storage",
    "unlimitedStorage"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "action": {
    "browser_style": false,
    "default_title": "",
    "default_icon": "book128.png",
    "default_popup": "popup.html"
  },
  "incognito": "split",
  "browser_specific_settings": {
    "gecko": {
      "id": "<WebToEpub@Baka-tsuki.org>",
      "data_collection_permissions": {
        "required": [
          "browsingActivity",
          "websiteContent"
        ],
        "optional": []
      },
      "strict_min_version": "142.0"
    }
  },
  "minimum_chrome_version": "120"
}

================================================
FILE: plugin/_locales/en/messages.json
================================================

{
 "**MSG_button_Advanced_Options**": {
  "message": "Advanced Options",
  "description": "Label on button to toggle showing 'Advanced Options'"
 },
 "**MSG_button_Lib_Library**": {
  "message": "Library",
  "description": "Label on button to toggle show 'Library'"
 },
 "**MSG_label_Lib_Show_Advanced_Library_Options**": {
  "message": "Show Advanced Library Options",
  "description": "Label for checkbox to Show Advanced Library Options"
 },
 "**MSG_label_Lib_Compact_View**": {
  "message": "Show Library in Compact Layout",
  "description": "Label for checkbox to Show Advanced Library Options"
 },
 "**MSG_label_Lib_Download_Epub_After_Update**": {
  "message": "Download Epubs after new Chapter got added automatically.",
  "description": "Label for checkbox to Download Epubs after update"
 },
 "**MSG_label_Lib_Warning_In_Progress**_": {
  "message": "In Progress....",
  "description": "Label for Library loading in local storage in progress"
 },
 "**MSG_button_Lib_Template_Clear_Library**": {
  "message": "Clear Library",
  "description": "Label on button to clear Local Storage"
 },
 "**MSG_button_Lib_Template_Export_Library**": {
  "message": "Export Library",
  "description": "Label on button to export Library in json format"
 },
 "**MSG_button_Lib_Template_Import_Library**": {
  "message": "Import Library",
  "description": "Label on button to import Library in json format"
 },
 "**MSG_button_Lib_Template_Upload_Epub**": {
  "message": "Upload Epub",
  "description": "Label on button to Upload Epub in Library"
 },
 "**MSG_button_Lib_Template_Add_List_To_Library**": {
  "message": "Add novels to Library",
  "description": "Label on button to Add novels to Library in Library"
 },
 "**MSG_button_Lib_Template_Update_All**": {
  "message": "Update all",
  "description": "Label on button to Update all Epubs"
 },
 "**MSG_button_Lib_Template_Delete_EPUB**": {
  "message": "Delete EPUB",
  "description": "Label on button to Delete EPUB"
 },
 "**MSG_button_Lib_Template_Search_new_Chapters**": {
  "message": "Search new Chapters",
  "description": "Label on button to Search new Chapters"
 },
 "**MSG_button_Lib_Template_Update_new_Chapters**": {
  "message": "Update",
  "description": "Label on button to Update new Chapters"
 },
 "**MSG_button_Lib_Template_Download_EPUB**": {
  "message": "Download EPUB",
  "description": "Label on button to Download EPUB"
 },
 "**MSG_button_Lib_Template_Add_Chapter_from_different_EPUB**": {
  "message": "Add Chapter from different EPUB",
  "description": "Label on button to Add Chapter from different EPUB"
 },
 "**MSG_button_Lib_Template_Edit_Metadata**": {
  "message": "Edit Metadata",
  "description": "Label on button to show edit options for metadata"
 },
 "**MSG_label_Lib_Template_Library_uses**": {
  "message": "Library uses: ",
  "description": "Label in front of the Bytes used in local Storage"
 },
 "**MSG_label_Lib_Template_New_Chapter**": {
  "message": " new chapter",
  "description": "Label of x new chapter"
 },
 "**MSG_label_Lib_Template_Story_URL**": {
  "message": "Story URL",
  "description": "Label in front of 'Story URL' input"
 },
 "**MSG_label_Lib_Template_Filename**": {
  "message": "Filename",
  "description": "Label in front of 'Filename' input"
 },
 "**MSG_label_Lib_Template_Warning_URL_Change**": {
  "message": "Warning: Change URL only if you know what you are doing.",
  "description": "Label for Warning if user changes URL in Library"
 },
 "**MSG_label_Lib_Template_Upload_Epub_File_Label**": {
  "message": "Upload an Epub File to the Library.",
  "description": "Label for Upload Epub file in Library"
 },
 "__MSG_button_Lib_Template_": {
  "message": "Invisible Button",
  "description": "Label on button to "
 },
 "**MSG_button_Apply_Changes**": {
  "message": "Apply Changes",
  "description": "Label on button to end manually editing list of URLs to fetch"
 },
 "**MSG_button_Clear_Url**": {
  "message": "Clear URL",
  "description": "Label on button to erase the Cover Image URL text"
 },
 "**MSG_button_Close_ReadingList**": {
  "message": "Close",
  "description": "Label on button to stop showing the Reading List"
 },
 "**MSG_button_Copy_Urls_To_Clipboard**": {
  "message": "Copy URLs to Clipboard",
  "description": "Label on button that copies selected chapter URLs to clipboard"
 },
 "**MSG_button_Edit_Chapter_Urls**": {
  "message": "Edit Chapter URLs",
  "description": "Label on button to allow manually editing list of URLs to fetch"
 },
 "**MSG_button_error_Cancel**": {
  "message": "Cancel",
  "description": "Label on 'Cancel' button when show error"
 },
 "**MSG_button_error_Skip**": {
  "message": "Skip",
  "description": "Label on 'Skip' button when show error"
 },
 "**MSG_button_error_OK**": {
  "message": "OK",
  "description": "Label on 'OK' button when show error"
 },
 "**MSG_button_error_Retry**": {
  "message": "Retry",
  "description": "Label on 'Retry' button when show error"
 },
 "**MSG_button_error_Open_URL**": {
  "message": "Open URL for Captcha",
  "description": "Label on 'Open URL for Captcha' button when show error HTTP 403"
 },
 "**MSG_button_error_Block_URL**": {
  "message": "Block Website for future requests",
  "description": "Label on 'Block Website for future requests' button when show error HTTP 403"
 },
 "**MSG_button_finished_default_parser**": {
  "message": "Apply",
  "description": "Label on button to finish configuring default parser"
 },
 "**MSG_button_Help**": {
  "message": "Help...",
  "description": "Label on button launch help page"
 },
 "**MSG_button_load_and_analyse**": {
  "message": "Load and Analyse",
  "description": "Label on button to try loading url given by 'Starting URL'"
 },
 "**MSG_button_load_Metadata**": {
  "message": "Load Additional Metadata",
  "description": "Label on button to toggle Load and Analyse Additional Metadata"
 },
 "**MSG_button_Pack_EPUB**": {
  "message": "Pack EPUB",
  "description": "Label on button to create the EPUB"
 },
 "**MSG_button_Add_to_Library**": {
  "message": "Add to Library",
  "description": "Label on button to create the EPUB and Add it to the Library"
 },
 "**MSG_button_Pause_to_Library**": {
  "message": "Pause to Library",
  "description": "Label on button to Pause the download"
 },
 "**MSG_button_Reset**": {
  "message": "Reset",
  "description": "Label on button that clears the dialog"
 },
 "**MSG_button_Reload**": {
  "message": "Reload",
  "description": "Label on 'Reload' button under 'Developer Stuff'"
 },
 "**MSG_button_Remove**": {
  "message": "Remove",
  "description": "Label on button to remove an entry from Reading List"
 },
 "**MSG_button_Reset_stylesheet**": {
  "message": "Reset stylesheet to default",
  "description": "Label on button to remove all changes to stylesheet and set to default value"
 },
 "**MSG_button_Reverse_Chapter_Urls_Order**": {
  "message": "Reverse Chapter URLs Order",
  "description": "Label on button to change order of chapters from last to first"
 },
 "**MSG_button_Select_All**": {
  "message": "Select All",
  "description": "Label on button to set all chapters to selected"
 },
 "**MSG_button_test_default_parser**": {
  "message": "Test",
  "description": "Label on button to test default parser settings"
 },
 "**MSG_button_Unselect_All**": {
  "message": "Unselect All",
  "description": "Label on button to unselect all chapters"
 },
 "**MSG_button_View_Filters**": {
  "message": "Filters",
  "description": "Label on button and header to show available filters"
 },
 "**MSG_button_View_Reading_List**": {
  "message": "View Reading List",
  "description": "Label on button to show Reading List"
 },
 "**MSG_button_Write_Options_to_file**": {
  "message": "Write Options to file",
  "description": "Label on button to write options to a file"
 },
 "**MSG_column_Include**": {
  "message": "Include?",
  "description": "The 'include this chapter' checkbox column in the table of chapters."
 },
 "**MSG_column_Title**": {
  "message": "Title",
  "description": "The 'name of chapter' column in the table of chapters."
 },
 "**MSG_column_URL**": {
  "message": "URL",
  "description": "The 'URL to get chapter from' column in the table of chapters."
 },
 "**MSG_label_Add_Information_Page_To_Epub**": {
  "message": "Add Information page to Epub",
  "description": "Label for checkbox to add 'Information' page at beginning of Epub"
 },
 "**MSG_label_Advanced_Options_Visible_By_Default**": {
  "message": "Advanced Options Visible by Default",
  "description": "Label for checkbox to make Advanced Options visible when UI opens"
 },
 "**MSG_label_Author**": {
  "message": "Author",
  "description": "Label in front input for novel's Author"
 },
 "**MSG_label_Auto_Parser_Select_Includes_Baka_Tsuki_Series_Page_Parser**": {
  "message": "Automatic parser select includes Baka-Tsuki Series Page Parser",
  "description": "Label for checkbox to toggle logic that picks parser to use for a web page to include the Baka-Tsuki Series Page Parser"
 },
 "**MSG_label_Chapter_Count**": {
  "message": "Chapter Count:",
  "description": "Label for number of chapters in range"
 },
 "**MSG_label_Chapters_Page_In_Chapters_List**": {
  "message": "Add Page with Chapters to Chapters List",
  "description": "Label for checkbox to toggle adding the page with chapters to list of pages to fetch"
 },
 "**MSG_label_Compress_Images**": {
  "message": "Compress Images",
  "description": "Label for checkbox and value to compress images to a certain size"
 },
 "**MSG_label_Compress_Images_JPG_Cover**": {
  "message": "Restrict Cover Image to JPEG",
  "description": "Label for JPEG cover restriction checkbox"
 },
 "**MSG_label_Compress_Images_Format**": {
  "message": "Compressed Image Format",
  "description": "Label for mime type of compressed image"
 },
 "**MSG_label_Compress_Images_Resolution**": {
  "message": "Compressed Resolution",
  "description": "Label for number input for maximum dimension size of pixel height or width in image"
 },
 "**MSG_label_Cover_from_URL**": {
  "message": "Cover from URL:",
  "description": "Label for checkbox to toggle between picking cover image from list or with a URL"
 },
 "**MSG_label_Cover_Image_URL**": {
  "message": "Cover Image URL:",
  "description": "Label for input to give cover image as URL"
 },
 "**MSG_label_Create_Epub_3**": {
  "message": "Create EPUB 3",
  "description": "Label for checkbox to choose between EPUB 2 and 3"
 },
 "**MSG_label_File_Author_as**": {
  "message": "File Author as",
  "description": "Label in front of input for author's name should be filed (in Advanced settings)."
 },
 "**MSG_label_Default_Parser_Chapter_Title_CSS**": {
  "message": "CSS selector for element holding Title of Chapter:",
  "description": "Label in front of input for CSS selector to find element holding title of a chapter"
 },
 "**MSG_label_Default_Parser_Content_CSS**": {
  "message": "(required) CSS selector for element holding content to put into EPUB:",
  "description": "Label in front of input for CSS selector to find element holding content to put into EPUB"
 },
 "**MSG_label_Default_Parser_HostName**": {
  "message": "Hostname:",
  "description": "Label in front of input for hostname in URL to use these settings for."
 },
 "**MSG_label_Default_Parser_Test_Chapter_Url**": {
  "message": "URL of first chapter:",
  "description": "Label in front of input for URL to test default parser settings."
 },
 "**MSG_label_Default_Parser_Unwanted_Elements_CSS**": {
  "message": "CSS selector for element(s) to remove:",
  "description": "Label in front input for CCS selector for elements to remove"
 },
 "**MSG_label_Edit_URLs_Hint**": {
  "message": "You can edit the URLs in html format or as a simple URL list (one URL per line).",
  "description": "Label in Edit Chapter URLs to help the user."
 },
 "**MSG_label_Element_With_Chapter_Content**": {
  "message": "Element with Chapter Content:",
  "description": "Label in front input for type of element holding each chapter's content"
 },
 "**MSG_label_Filename**": {
  "message": "Filename",
  "description": "Label in front input for file to save EPUB as"
 },
 "**MSG_label_Developer_Stuff**": {
  "message": "Developer Stuff:",
  "description": "Label for checkbox to show/hide buttons for developer testing (in Advanced settings)."
 },
 "**MSG_label_Fetch_Highest_Resolution_Images**": {
  "message": "Fetch Highest Resolution Images",
  "description": "Label for checkbox to get EPUB to include highest resolution images available (in Advanced settings)."
 },
 "**MSG_label_Include_in_Reading_List**": {
  "message": "Include in Reading List",
  "description": "Label for checkbox to add/remove title from Reading List of tracked titles."
 },
 "**MSG_label_Include_URL_of_Images**": {
  "message": "Include URL of Images",
  "description": "Label for checkbox to record source URL of images into EPUB (in Advanced settings)."
 },
 "**MSG_label_Language**": {
  "message": "Language",
  "description": "Label in front input for language EPUB will be in"
 },
 "**MSG_label_no_additional_metadata**": {
  "message": "no Additional Metadata",
  "description": "No tags and description in metadata"
 },
 "**MSG_label_auto_search_metadata**": {
  "message": "auto search Metadata on novelupdates (long loading time)",
  "description": "auto search Metadata on novelupdates"
 },
 "**MSG_label_less_tags**": {
  "message": "less tags",
  "description": "Only extract genre"
 },
 "**MSG_label_Show_More_Metadata_Options**": {
  "message": "Show more Metadata options",
  "description": "Show more Metadata options to user"
 },
 "**MSG_label_Manual_Delay_Per_Chapter**": {
  "message": "Delay per chapter in ms",
  "description": "Delay per chapter in ms"
 },
 "**MSG_label_Manually_Select_Parser**": {
  "message": "Manually Select Parser:",
  "description": "Label for menu to change parser (in advanced options section)"
 },
 "**MSG_label_Max_chapters_per_epub**": {
  "message": "Max chapters per EPUB",
  "description": "Label for control to set max chapters to put in single EPUB"
 },
 "**MSG_label_Max_pages_to_fetch_simultaneously**": {
  "message": "Max web pages to fetch simultaneously",
  "description": "Label for drop down for maximum number of web pages to request at same time"
 },
 "**MSG_label_Metadata_description**": {
  "message": "Epub description",
  "description": "Preview description from the epub in Calibre"
 },
 "**MSG_label_Custom_Filename**": {
  "message": "Custom Filename",
  "description": "Custom Filename input"
 },
 "**MSG_label_Metadata_subject**": {
  "message": "Tags",
  "description": "Tags for epub"
 },
 "**MSG_label_Metadata_Save**": {
  "message": "Save Metadata",
  "description": "Label on button to Save Metadata"
 },
 "**MSG_label_Metadata_URL**": {
  "message": "Additional Metadata URL",
  "description": "Additional Metadata URL"
 },
 "**MSG_label_Override_Default_Minimum_Delay**": {
  "message": "Override Delay per chapter Value (where applicable)",
  "description": "Override Delay per chapter Value (where applicable)"
 },
 "**MSG_label_Overwrite_Epub_When_Filename_Duplicte**": {
  "message": "Overwrite existing EPUB file with same name",
  "description": "Label for checkbox to toggle between 'overwrite existing Epub files' and 'make names unique'"
 },
 "**MSG_label_Password**": {
  "message": "Password",
  "description": "Label for textbox to collect password needed for site"
 },
 "**MSG_label_Range_End_Chapter**": {
  "message": "Last Chapter",
  "description": "Label in front of drop down for selecting last chapter to include in epub"
 },
 "**MSG_label_Range_Start_Chapter**": {
  "message": "First Chapter",
  "description": "Label in front of drop down for selecting first chapter to include in epub"
 },
 "**MSG_label_Read_Options_from_file**": {
  "message": "Read Options from file:",
  "description": "Label in front of button to read Options from a file"
 },
 "**MSG_label_Remove_Author_Notes**": {
  "message": "Remove Author Notes",
  "description": "Label for checkbox to remove Author Notes from chapters"
 },
 "**MSG_label_Remove_Chapter_Number**": {
  "message": "Remove Chapter Numbers",
  "description": "Label for checkbox to remove Chapter Numbers from chapter titles"
 },
 "**MSG_label_Remove_Original**": {
  "message": "Remove Original/Raw Text",
  "description": "Label for checkbox to remove Original text from chapters"
 },
 "**MSG_label_Select_Translation_Google**": {
  "message": "Download raw (no login)",
  "description": "Label for radio checkbox Google"
 },
 "**MSG_label_Select_Retry_Longer**": {
  "message": "Retry Chapter for up to 1h (it looks like WebToEpub is stuck)",
  "description": "Label for Retry longer"
 },
 "**MSG_label_Remove_Translated**": {
  "message": "Remove Translated Text",
  "description": "Label for checkbox to remove Translated text from chapters"
 },
 "**MSG_label_Remove_Duplicate_Images**": {
  "message": "Remove Duplicate Images:",
  "description": "Label for checkbox to remove duplicate images from gallery (in cover images section)"
 },
 "**MSG_label_Remove_Superscript_From_Alternate_Translations**": {
  "message": "Remove superscript from alternate translations",
  "description": "Label for checkbox to convert superscripted alternate translations into inline text"
 },
 "**MSG_label_Series**": {
  "message": "Series",
  "description": "Label in front input for series Novel is part of"
 },
 "**MSG_label_Show_Chapter_Urls**": {
  "message": "Show URLs of Chapters",
  "description": "Label for checkbox to toggle First and Last Chapter selectors between URLs and Titles"
 },
 "**MSG_label_Skip_Images**": {
  "message": "Skip Images",
  "description": "Label for checkbox to not include images in EPUB"
 },
 "**MSG_label_Starting_URL**": {
  "message": "Starting URL",
  "description": "Label in front of 'URL' input"
 },
 "**MSG_label_Skip_Chapters_That_Fail_Fetch**": {
  "message": "Skip chapters that return HTTP 404 error",
  "description": "Label in front of checkbox for skipping chapters that can't be fetched"
 },
 "**MSG_label_Stylesheet**": {
  "message": "Stylesheet:",
  "description": "Label in front of edit field for setting the stylesheet (in Advanced settings)."
 },
 "**MSG_label_Theme**": {
  "message": "Theme",
  "description": "Label for drop down list to select theme colour."
 },
 "**MSG_label_Title**": {
  "message": "Title",
  "description": "Label in front of input for Novel's title."
 },
 "**MSG_label_Translator**": {
  "message": "Translator",
  "description": "Label in front of input for Translator (in Advanced settings)."
 },
 "**MSG_label_Use_Full_Title_As_File_Name**": {
  "message": "Use full title as file name",
  "description": "Label in front of checkbox to choose if Epub's filename will be truncated or not."
 },
 "**MSG_label_Use_SVG_for_Images**": {
  "message": "Use <svg> for images",
  "description": "Label in front of checkbox to choose between <img> and <svg> elements for images."
 },
 "**MSG_label_Remove_Next_and_Previous_Chapter_Hyperlinks**": {
  "message": "Remove Next and Previous Chapter Hyperlinks",
  "description": "Remove hyperlinks to the previous and next chapter that may appear in chapter pages."
 },
 "**MSG_label_Using_Default_Parser**": {
  "message": "No parser found for this URL.  Default Parser will be used. Please specify how to obtain content from each web page.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "**MSG_label_Volume**": {
  "message": "Volume",
  "description": "Label in front of input for novel's position in series."
 },
 "**MSG_label_No_Download_Popup**": {
  "message": "Don't popup 'SaveAs' dialog when save Epub",
  "description": "Label for checkbox to download the final epub without a popup"
 },
    "**MSG_label_Disable_Shift_Click_Alert**": {
      "message": "Disable Shift+Click Selection Alert",
      "description": "Label for checkbox to disable the alert shown when user shift-clicks to select multiple chapters"
    },
    "**MSG_label_Disable_Image_Res_Error**": {
      "message": "Disable High Resolution Image Fetch Failure Warning",
      "description": "Label for checkbox to disable warnings when high resolution image fetch fails and lower resolution is used instead"
    },
    "**MSG_label_Disable_Webp_Image_Format_Error**": {
      "message": "Disable WebP Image Format Compatibility Warning",
      "description": "Label for checkbox to disable warnings that WebP format images may not render in epub viewers"
    },
 "**MSG_label_Write_Error_History_To_File**": {
  "message": "Write error messages to file",
  "description": "Label for checkbox to write recent error messages to file"
 },
 "**MSG_More_than_max_chapters_selected**": {
  "message": "Caution: $selectedCount$ chapters have been selected to include in EPUB.  Click 'OK' if you want all of them included.  Click 'Cancel' if you want only the first $maxChapters$ included",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "selectedCount": {
       "content": "$1"
   },
   "maxChapters": {
       "content": "$2"
   }
  }
 },
 "**MSG_option_Class_Is**": {
  "message": "Class is",
  "description": "Content is element of specified class."
 },
 "**MSG_option_Class_Starts_With**": {
  "message": "Class Starts With",
  "description": "Content is element having a class name starting with."
 },
 "**MSG_option_First_Found**": {
  "message": "First Found",
  "description": "Content is first element of specified type found."
 },
 "**MSG_option_ID_Is**": {
  "message": "ID is",
  "description": "Content is element with specified ID."
 },
 "**MSG_option_ID_Starts_With**": {
  "message": "ID Starts With",
  "description": "Content is element having an ID starting with."
 },
 "**MSG_option_ID_Theme_Always_Dark**": {
  "message": "Always Dark Mode",
  "description": "GUI will always use dark mode theme."
 },
 "**MSG_option_ID_Theme_Always_Light**": {
  "message": "Always Light Mode",
  "description": "GUI will always use light mode theme."
 },
 "**MSG_option_ID_Theme_OS_Selection**": {
  "message": "Use current OS selection",
  "description": "GUI will use OS's selection of light or dark mode."
 },
 "**MSG_Searching_For_URLs_Please_Wait**": {
  "message": "Searching for URLs.  Please wait.",
  "description": "Message shown while looking for list of Chapter URLs."
 },
 "**MSG_option_value_auto**": {
  "message": "auto",
  "description": "Generic option text for 'automatic'"
 },
 "**MSG_Shift_Click**": {
  "message": "You can select or unselect a range of chapters by clicking on the checkbox for the first chapter, then  hold down the shift key and click the last chapter in the range.",
  "description": "Tell user how to shift-click to multiselect."
 },
 "**MSG_Tooltip_chapter_downloading**": {
  "message": "Downloading chapter",
  "description": "Tooltip for chapter download status icon: chapter is currently downloading"
 },
 "**MSG_Tooltip_chapter_downloaded**": {
  "message": "Downloaded",
  "description": "Tooltip for chapter download status icon: chapter download succeeded"
 },
 "**MSG_Tooltip_chapter_sleeping**": {
  "message": "Waiting for chapter delay time to elapse",
  "description": "Tooltip for chapter download status icon: waiting for chapter delay time to elapse"
 },
 "**MSG_Tooltip_chapter_previously_downloaded**": {
  "message": "Chapter previously downloaded",
  "description": "Tooltip for chapter download status icon: chapter has been downloaded before."
 },
 "chapterPlaceholderMessage": {
  "message": "This is a placeholder.  Attempt to fetch chapter from '$url$' failed with error: \r\n $error$",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "url": {
       "content": "$1"
   },
   "error": {
       "content": "$2"
   }
  }
 },
 "convertToXhtmlWarning": {
  "message": "Warning, unable to convert chapter '$chapter$' from '$url$' to valid XHTML. Your epub viewer may fail when viewing that chapter. You may need to fix the chapter manually with Calibre. \r\nConversion error message was: ($error$)",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "chapter": {
       "content": "$1"
   },
   "url": {
       "content": "$2"
   },
   "error": {
       "content": "$3"
   }
  }
 },
 "defaultAuthor": {
  "message": "No author supplied",
  "description": "Default author value to use when one is not supplied"
 },
 "defaultTitle": {
  "message": "No title supplied",
  "description": "Default UUID value to use when one is not supplied"
 },
 "defaultUUID": {
  "message": "No UUID supplied",
  "description": "Default UUID value to use when one is not supplied"
 },
 "errorEditMetadata": {
  "message": "An error occurred during the editing of the Metadata. Couldn't find the string to replace in  OEBPS/content.opf",
  "description": "Error message when regex can't find the string to replace in OEBPS/content.opf"
 },
 "errorAddToLibraryLibraryAddPageWithChapters": {
  "message": "\"Add to Library\" doesn't work with Advanced Option \"Add Page with Chapters to Chapters List\" enabled.",
  "description": "Error message when user tries to Add to Library if Add Page with Chapters to Chapters List is enabled"
 },
 "errorContentNotFound": {
  "message": "Could not find content element for web page '$url$'.",
  "description": "Warning message when can't find content element for a web page",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "errorIllegalFileName": {
  "message": "Filename '$filename$' must not contain the following characters: $illegalCharacters$",
  "description": "Warning message when filename isn't legal",
  "placeholders": {
   "filename": {
       "content": "$1"
   },
   "illegalCharacters": {
       "content": "$2"
   }
  }
 },
 "gotHtmlExpectedImageWarning": {
  "message": "Attempt to fetch high resolution version of image from '$url$' failed.  Using lower resolution image instead.",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "httpFetchCanRetry": {
  "message": "This is an intermittent error. If you retry in a few minutes, it may succeed.",
  "description": "Added message that retrying HTTP operation may succeed."
 },
 "htmlFetchFailed": {
  "message": "Fetch of URL '$url$' failed with network error $err$.",
  "description": "Error message when fetch of a web page fails.",
  "placeholders": {
   "url": {
       "content": "$1"
   },
   "err": {
       "content": "$2"
   }
  }
 },
 "imageFetchFailed": {
  "message": "Fetch of image '$imageUrl$' for page '$pageUrl$' failed with network error $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "imgurFetchFailed": {
  "message": "Warning: Attempt to fetch imgur image(s) '$imageUrl$' for page '$pageUrl$' failed with network error $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "noChaptersFound": {
  "message": "No chapters found. This may not be the novel's detail page.",
  "description": "Warning message when parser can't find list of chapters."
 },
 "informationPageTitle": {
  "message": "Information",
  "description": "Title of page that gives information on epub."
 },
 "noChaptersFoundAndFetchClicked": {
  "message": "No chapters found.",
  "description": "Warning message.  Developer has clicked 'Fetch Chapters' when there are none."
 },
 "noImagesFound": {
  "message": "No images found.",
  "description": "Warning message.  Developer has clicked 'Fetch Images' when there are none."
 },
 "noImagesFoundLabel": {
  "message": "No images found",
  "description": "Text put in images table when no images are found."
 },
 "noParserFound": {
  "message": "No parser found for this URL.  Default parser will be used.  You will need to specify how to obtain content for each chapter.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "parserDisabledNotification": {
  "message": "Support for this site has been disabled at the request of site owners.",
  "description": "Warning message when user tries to process disabled parser."
 },
 "setCover": {
  "message": "Set Cover",
  "description": "Label for checkboxes used to select the cover image."
 },
 "tableOfContentsUrl": {
  "message": "Table of Contents URL: ",
  "description": "Label on information page for URL where Table of Contents came from."
 },
 "unhandledFieldTypeError": {
  "message": "ERROR: Unhandled field type.",
  "description": "Internal message for developer."
 },
 "warning403ErrorResponse": {
  "message": "WARNING: Site '$host$' has sent an Access Denied (403) error.\nYou may need to logon to site, or browse site normally\nuntil you get a Cloudflare \"Are you a human\" page or satisfy some other CAPTCHA\nbefore WebToEpub can continue.\nThis happens if you are downloading to fast try to increase 'Advanced Options -> Delay per chapter in ms'\n",
  "description": "Warning message for user when site sends a 403 response.",
  "placeholders": {
   "host": {
    "content": "$1"
   }
  }
 },
 "wait403ErrorResponse": {
  "message": "Wait until you cleared cloudflare or login.",
  "description": "Wait message for user when site sends a 403 response."
 },
 "warning429ErrorResponse": {
  "message": "WARNING: Site '$host$' has requested WebToEpub to slow down rate of chapter requests.  WebToEpub will wait until site allows requesting chapters again.  However, if this does not work, you may need to adjust manually.  Under 'Advanced Options' -> increase 'Delay per chapter in ms'",
  "description": "Warning message for user when site sends a 429 response.",
  "placeholders": {
   "host": {
    "content": "$1"
   }
  }
 },
 "warningNoChapterUrl": {
  "message": "ERROR: No Chapter URL supplied to test against.",
  "description": "Warning message when user tries to test the Default Parser without supplying a Chapter URL to test against."
 },
 "warningNoVisibleContent": {
  "message": "Warning, content element for web page '$url$' has no visible content.",
  "description": "Warning message when content element for a page has nothing viewable",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "warningWebpImage": {
  "message": "Warning: image file '$filename$' is in webp format.  Your epub viewer may not be able to render it.",
  "description": "Warning message when downloaded image is in webp format",
  "placeholders": {
   "filename": {
       "content": "$1"
   }
  }
 }
}

================================================
FILE: plugin/_locales/ru/messages.json
================================================

{
 "**MSG_button_Advanced_Options**": {
  "message": "Расширенные настройки",
  "description": "Label on button to toggle showing 'Advanced Options'"
 },
 "**MSG_button_Apply_Changes**": {
  "message": "Применить изменения",
  "description": "Label on button to end manually editing list of URLs to fetch"
 },
 "**MSG_button_Clear_Url**": {
  "message": "Очистить адрес",
  "description": "Label on button to erase the Cover Image URL text"
 },
 "**MSG_button_Close_ReadingList**": {
  "message": "Закрыть",
  "description": "Label on button to stop showing the Reading List"
 },
 "**MSG_button_Copy_Urls_To_Clipboard**": {
  "message": "Копировать ссылки",
  "description": "Label on button that copies selected chapter URLs to clipboard"
 },
 "**MSG_button_Edit_Chapter_Urls**": {
  "message": "Править список ссылок",
  "description": "Label on button to allow manually editing list of URLs to fetch"
 },
 "**MSG_button_error_Cancel**": {
  "message": "Отмена",
  "description": "Label on 'Cancel' button when show error"
 },
 "**MSG_button_error_Skip**": {
  "message": "Пропустить",
  "description": "Label on 'Skip' button when show error"
 },
 "**MSG_button_error_OK**": {
  "message": "OK",
  "description": "Label on 'OK' button when show error"
 },
 "**MSG_button_error_Retry**": {
  "message": "Повторить",
  "description": "Label on 'Retry' button when show error"
 },
 "**MSG_button_finished_default_parser**": {
  "message": "Применить",
  "description": "Label on button to finish configuring default parser"
 },
 "**MSG_button_Help**": {
  "message": "Справка...",
  "description": "Label on button launch help page"
 },
 "**MSG_button_load_and_analyse**": {
  "message": "Загрузить и анализировать",
  "description": "Label on button to try loading url given by 'Starting URL'"
 },
 "**MSG_button_Pack_EPUB**": {
  "message": "Упаковать EPUB",
  "description": "Label on button to create the EPUB"
 },
 "**MSG_button_Reset**": {
  "message": "Сброс",
  "description": "Label on button that clears the dialog"
 },
 "**MSG_button_Reload**": {
  "message": "Перезагрузить",
  "description": "Label on 'Reload' button under 'Developer Stuff'"
 },
 "**MSG_button_Remove**": {
  "message": "Удалить",
  "description": "Label on button to remove an entry from Reading List"
 },
 "**MSG_button_Reset_stylesheet**": {
  "message": "Сбросить стили к первоначальным",
  "description": "Label on button to remove all changes to stylesheet and set to default value"
 },
 "**MSG_button_Reverse_Chapter_Urls_Order**": {
  "message": "Изменить порядок ссылок на главы",
  "description": "Label on button to change order of chapters from last to first"
 },
 "**MSG_button_Select_All**": {
  "message": "Выбрать всё",
  "description": "Label on button to set all chapters to selected"
 },
 "**MSG_button_test_default_parser**": {
  "message": "Тест",
  "description": "Label on button to test default parser settings"
 },
 "**MSG_button_Unselect_All**": {
  "message": "Сбросить выделение",
  "description": "Label on button to unselect all chapters"
 },
 "**MSG_button_View_Reading_List**": {
  "message": "Просмотр Списка для чтения",
  "description": "Label on button to show Reading List"
 },
 "**MSG_button_Write_Options_to_file**": {
  "message": "Сохранить настройки в файл",
  "description": "Label on button to write options to a file"
 },
 "**MSG_column_Include**": {
  "message": "Включать?",
  "description": "The 'include this chapter' checkbox column in the table of chapters."
 },
 "**MSG_column_Title**": {
  "message": "Название:",
  "description": "The 'name of chapter' column in the table of chapters."
 },
 "**MSG_column_URL**": {
  "message": "Адрес:",
  "description": "The 'URL to get chapter from' column in the table of chapters."
 },
 "**MSG_label_Advanced_Options_Visible_By_Default**": {
  "message": "Расширенные настройки видны по умолчанию",
  "description": "Label for checkbox to make Advanced Options visible when UI opens"
 },
 "**MSG_label_Author**": {
  "message": "Автор:",
  "description": "Label in front input for novel's Author"
 },
 "**MSG_label_Auto_Parser_Select_Includes_Baka_Tsuki_Series_Page_Parser**": {
  "message": "Автоматический подбор парсера будет пробовать Baka-Tsuki Series Page Parser",
  "description": "Label for checkbox to toggle logic that picks parser to use for a web page to include the Baka-Tsuki Series Page Parser"
 },
 "**MSG_label_Chapter_Count**": {
  "message": "Количество глав:",
  "description": "Label for number of chapters in range"
 },
 "**MSG_label_Chapters_Page_In_Chapters_List**": {
  "message": "Добавить в оглавление страницу со списком глав",
  "description": "Label for checkbox to toggle adding the page with chapters to list of pages to fetch"
 },
 "**MSG_label_Cover_from_URL**": {
  "message": "Загрузить другую обложку:",
  "description": "Label for checkbox to toggle between picking cover image from list or with a URL"
 },
 "**MSG_label_Cover_Image_URL**": {
  "message": "Адрес для загрузки обложки:",
  "description": "Label for input to give cover image as URL"
 },
 "**MSG_label_Create_Epub_3**": {
  "message": "Создать EPUB 3",
  "description": "Label for checkbox to choose between EPUB 2 and 3"
 },
 "**MSG_label_File_Author_as**": {
  "message": "Автор:",
  "description": "Label in front of input for author's name should be filed (in Advanced settings)."
 },
 "**MSG_label_Default_Parser_Chapter_Title_CSS**": {
  "message": "CSS-селектор элемента, в котором содержится название главы:",
  "description": "Label in front of input for CSS selector to find element holding title of a chapter"
 },
 "**MSG_label_Default_Parser_Content_CSS**": {
  "message": "(обязательно) CSS-селектор элемента, содержимое которого будет помещено в EPUB:",
  "description": "Label in front of input for CSS selector to find element holding content to put into EPUB"
 },
 "**MSG_label_Default_Parser_HostName**": {
  "message": "Домен сайта:",
  "description": "Label in front of input for hostname in URL to use these settings for."
 },
 "**MSG_label_Default_Parser_Test_Chapter_Url**": {
  "message": "Адрес первой главы:",
  "description": "Label in front of input for URL to test default parser settings."
 },
 "**MSG_label_Default_Parser_Unwanted_Elements_CSS**": {
  "message": "CSS-селектор элемента(ов), которые будут удалены:",
  "description": "Label in front input for CCS selector for elements to remove"
 },
 "**MSG_label_Element_With_Chapter_Content**": {
  "message": "Элемент с содержимым главы:",
  "description": "Label in front input for type of element holding each chapter's content"
 },
 "**MSG_label_Filename**": {
  "message": "Имя файла:",
  "description": "Label in front input for file to save EPUB as"
 },
 "**MSG_label_Developer_Stuff**": {
  "message": "Инструменты разработчика:",
  "description": "Label for checkbox to show/hide buttons for developer testing (in Advanced settings)."
 },
 "**MSG_label_Fetch_Highest_Resolution_Images**": {
  "message": "Отдавать предпочтение изображениям с высоким разрешением",
  "description": "Label for checkbox to get EPUB to include highest resolution images available (in Advanced settings)."
 },
 "**MSG_label_Include_in_Reading_List**": {
  "message": "Добавить в Список для чтения",
  "description": "Label for checkbox to add/remove title from Reading List of tracked titles."
 },
 "**MSG_label_Include_URL_of_Images**": {
  "message": "Включить адреса изображений",
  "description": "Label for checkbox to record source URL of images into EPUB (in Advanced settings)."
 },
 "**MSG_label_Language**": {
  "message": "Язык:",
  "description": "Label in front input for language EPUB will be in"
 },
 "**MSG_label_Manually_Select_Parser**": {
  "message": "Выбрать парсер вручную:",
  "description": "Label for menu to change parser (in advanced options section)"
 },
 "**MSG_label_Max_pages_to_fetch_simultaneously**": {
  "message": "Максимальное кол-во страниц, загружаемых одновременно",
  "description": "Label for drop down for maximum number of web pages to request at same time"
 },
 "**MSG_label_Range_End_Chapter**": {
  "message": "Последняя глава:",
  "description": "Label in front of drop down for selecting last chapter to include in epub"
 },
 "**MSG_label_Range_Start_Chapter**": {
  "message": "Первая глава:",
  "description": "Label in front of drop down for selecting first chapter to include in epub"
 },
 "**MSG_label_Read_Options_from_file**": {
  "message": "Загрузить настройки из файла:",
  "description": "Label in front of button to read Options from a file"
 },
 "**MSG_label_Remove_Author_Notes**": {
  "message": "Удалить авторские заметки",
  "description": "Label for checkbox to remove Author Notes from chapters"
 },
 "**MSG_label_Remove_Original**": {
  "message": "Удалить оригинальный (необработанный) текст",
  "description": "Label for checkbox to remove Original text from chapters"
 },
 "**MSG_label_Remove_Duplicate_Images**": {
  "message": "Удалить дубликаты изображений:",
  "description": "Label for checkbox to remove duplicate images from gallery (in cover images section)"
 },
 "**MSG_label_Remove_Superscript_From_Alternate_Translations**": {
  "message": "Удалить из текста альтернативные варианты перевода",
  "description": "Label for checkbox to convert superscripted alternate translations into inline text"
 },
 "**MSG_label_Series**": {
  "message": "Серия:",
  "description": "Label in front input for series Novel is part of"
 },
 "**MSG_label_Starting_URL**": {
  "message": "Начальный адрес:",
  "description": "Label in front of 'URL' input"
 },
 "**MSG_label_Stylesheet**": {
  "message": "Стили:",
  "description": "Label in front of edit field for setting the stylesheet (in Advanced settings)."
 },
 "**MSG_label_Title**": {
  "message": "Название:",
  "description": "Label in front of input for Novel's title."
 },
 "**MSG_label_Translator**": {
  "message": "Переводчик:",
  "description": "Label in front of input for Translator (in Advanced settings)."
 },
 "**MSG_label_Use_SVG_for_Images**": {
  "message": "Использовать <svg> для изображений",
  "description": "Label in front of checkbox to choose between <img> and <svg> elements for images."
 },
 "**MSG_label_Using_Default_Parser**": {
  "message": "Не удалось подобрать парсер. Используется парсер по-умолчанию. Пожалуйста, укажите, как именно получать содержимое страниц.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "**MSG_label_Volume**": {
  "message": "Том в серии:",
  "description": "Label in front of input for novel's position in series."
 },
 "**MSG_label_No_Download_Popup**": {
  "message": "Сохранение epub в фоновом режиме",
  "description": "Label for checkbox to download the final epub without a popup"
 },
 "**MSG_label_Disable_Shift_Click_Alert**": {
  "message": "Отключить предупреждение при Shift+клик выборе",
  "description": "Label for checkbox to disable the alert shown when user shift-clicks to select multiple chapters"
 },
 "**MSG_label_Disable_Image_Res_Error**": {
  "message": "Отключить предупреждения о сбое высокого разрешения изображений",
  "description": "Label for checkbox to disable warnings when high resolution image fetch fails and lower resolution is used instead"
 },
 "**MSG_label_Disable_Webp_Image_Format_Error**": {
  "message": "Отключить предупреждения о совместимости формата WebP",
  "description": "Label for checkbox to disable warnings that WebP format images may not render in epub viewers"
 },
 "**MSG_label_Write_Error_History_To_File**": {
  "message": "Записывать ошибки в файл",
  "description": "Label for checkbox to write recent error messages to file"
 },
 "**MSG_option_Class_Is**": {
  "message": "Class является",
  "description": "Content is element of specified class."
 },
 "**MSG_option_Class_Starts_With**": {
  "message": "Class начинается с",
  "description": "Content is element having a class name starting with."
 },
 "**MSG_option_First_Found**": {
  "message": "Первый найденный",
  "description": "Content is first element of specified type found."
 },
 "**MSG_option_ID_Is**": {
  "message": "ID является",
  "description": "Content is element with specified ID."
 },
 "**MSG_option_ID_Starts_With**": {
  "message": "ID начинается с",
  "description": "Content is element having an ID starting with."
 },
 "**MSG_Searching_For_URLs_Please_Wait**": {
  "message": "Поиск адресов. Пожалуйста, подождите.",
  "description": "Message shown while looking for list of Chapter URLs."
 },
 "**MSG_Shift_Click**": {
  "message": "Вы можете выделить несколько глав следующим образом: отметьте первую желаемую главу, зажмите клавишу Shift и отметьте последнюю желаемую главу.",
  "description": "Tell user how to shift-click to multiselect."
 },
 "convertToXhtmlWarning": {
  "message": "Внимание: не получилось конвертировать главу '$chapter$' по адресу '$url$' в валидный XHTML. Ваша EPUB-читалка может не прочитать эту главу. Возможно, вам придётся исправить эту главу вручную в Calibre. \r\nОшибки конвертации: ($error$)",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "chapter": {
       "content": "$1"
   },
   "url": {
       "content": "$2"
   },
   "error": {
       "content": "$3"
   }
  }
 },
 "defaultAuthor": {
  "message": "Автор не задан",
  "description": "Default author value to use when one is not supplied"
 },
 "defaultTitle": {
  "message": "Название не задано",
  "description": "Default UUID value to use when one is not supplied"
 },
 "defaultUUID": {
  "message": "UUID не задано",
  "description": "Default UUID value to use when one is not supplied"
 },
 "errorContentNotFound": {
  "message": "Не найден элемент с содержимым на странице '$url$'.",
  "description": "Warning message when can't find content element for a web page",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "errorIllegalFileName": {
  "message": "Имя файла '$filename$' не должно содержать следующие символы: $illegalCharacters$",
  "description": "Warning message when filename isn't legal",
  "placeholders": {
   "filename": {
       "content": "$1"
   },
   "illegalCharacters": {
       "content": "$2"
   }
  }
 },
 "gotHtmlExpectedImageWarning": {
  "message": "По адресу '$url$' получена HTML-страница, но ожидалось изображение.",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "httpFetchCanRetry": {
  "message": "Внезапно возникла ошибка. Попробуйте ещё раз.",
  "description": "Added message that retrying HTTP operation may succeed."
 },
 "htmlFetchFailed": {
  "message": "Попытка загрузки адреса '$url$' завершилась с ошибкой сети: $err$.",
  "description": "Error message when fetch of a web page fails.",
  "placeholders": {
   "url": {
       "content": "$1"
   },
   "err": {
       "content": "$2"
   }
  }
 },
 "imageFetchFailed": {
  "message": "Попытка загрузки изображения '$imageUrl$' для страницы '$pageUrl$' завершилась с ошибкой сети: $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "imgurFetchFailed": {
  "message": "Внимание: попытка загрузить IMGUR-изображение '$imageUrl$' для страницы '$pageUrl$' завершилась с ошибкой сети: $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "noChaptersFound": {
  "message": "Главы не найдены. Возможно, это — не адрес титульной страницы новеллы.",
  "description": "Warning message when parser can't find list of chapters."
 },
 "informationPageTitle": {
  "message": "Информация",
  "description": "Title of page that gives information on epub."
 },
 "noChaptersFoundAndFetchClicked": {
  "message": "Главы не найдены.",
  "description": "Warning message.  Developer has clicked 'Fetch Chapters' when there are none."
 },
 "noImagesFound": {
  "message": "Изображения не найдены.",
  "description": "Warning message.  Developer has clicked 'Fetch Images' when there are none."
 },
 "noImagesFoundLabel": {
  "message": "Изображений не найдено",
  "description": "Text put in images table when no images are found."
 },
 "noParserFound": {
  "message": "Не удалось подобрать парсер. Используется парсер по-умолчанию. Пожалуйста, укажите, как именно получать содержимое глав.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "setCover": {
  "message": "Выбрать обложку",
  "description": "Label for checkboxes used to select the cover image."
 },
 "tableOfContentsUrl": {
  "message": "Адрес содержания:",
  "description": "Label on information page for URL where Table of Contents came from."
 },
 "unhandledFieldTypeError": {
  "message": "ERROR: Unhandled field type.",
  "description": "Internal message for developer."
 },
 "warningNoChapterUrl": {
  "message": "ОШИБКА: Не указан адрес главы для теста.",
  "description": "Warning message when user tries to test the Default Parser without supplying a Chapter URL to test against."
 },
 "warningNoVisibleContent": {
  "message": "Внимание: указанный элемент для страницы '$url$' не имеет видимого содержимого.",
  "description": "Warning message when content element for a page has nothing viewable",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "warningWebpImage": {
  "message": "Внимание: изображение '$filename$' является изображением в формате WEBP. Ваша EPUB-читалка может иметь проблемы с его показом.",
  "description": "Warning message when downloaded image is in webp format",
  "placeholders": {
   "filename": {
       "content": "$1"
   }
  }
 }
}

================================================
FILE: plugin/_locales/uk/messages.json
================================================

{
 "**MSG_button_Advanced_Options**": {
  "message": "Розширені налаштування",
  "description": "Label on button to toggle showing 'Advanced Options'"
 },
 "**MSG_button_Apply_Changes**": {
  "message": "Застосувати зміни",
  "description": "Label on button to end manually editing list of URLs to fetch"
 },
 "**MSG_button_Clear_Url**": {
  "message": "Стерти адресу",
  "description": "Label on button to erase the Cover Image URL text"
 },
 "**MSG_button_Close_ReadingList**": {
  "message": "Закрити",
  "description": "Label on button to stop showing the Reading List"
 },
 "**MSG_button_Copy_Urls_To_Clipboard**": {
  "message": "Копіювати адреси",
  "description": "Label on button that copies selected chapter URLs to clipboard"
 },
 "**MSG_button_Edit_Chapter_Urls**": {
  "message": "Редагувати список адрес",
  "description": "Label on button to allow manually editing list of URLs to fetch"
 },
 "**MSG_button_error_Cancel**": {
  "message": "Скасувати",
  "description": "Label on 'Cancel' button when show error"
 },
 "**MSG_button_error_Skip**": {
  "message": "Пропустити",
  "description": "Label on 'Skip' button when show error"
 },
 "**MSG_button_error_OK**": {
  "message": "OK",
  "description": "Label on 'OK' button when show error"
 },
 "**MSG_button_error_Retry**": {
  "message": "Повторити",
  "description": "Label on 'Retry' button when show error"
 },
 "**MSG_button_finished_default_parser**": {
  "message": "Застосувати",
  "description": "Label on button to finish configuring default parser"
 },
 "**MSG_button_Help**": {
  "message": "Довідка...",
  "description": "Label on button launch help page"
 },
 "**MSG_button_load_and_analyse**": {
  "message": "Завантажити та аналізувати",
  "description": "Label on button to try loading url given by 'Starting URL'"
 },
 "**MSG_button_Pack_EPUB**": {
  "message": "Упаковати EPUB",
  "description": "Label on button to create the EPUB"
 },
 "**MSG_button_Reset**": {
  "message": "Очистити",
  "description": "Label on button that clears the dialog"
 },
 "**MSG_button_Reload**": {
  "message": "Перезавантажити",
  "description": "Label on 'Reload' button under 'Developer Stuff'"
 },
 "**MSG_button_Remove**": {
  "message": "Видалити",
  "description": "Label on button to remove an entry from Reading List"
 },
 "**MSG_button_Reset_stylesheet**": {
  "message": "Скинути стилі до початкових",
  "description": "Label on button to remove all changes to stylesheet and set to default value"
 },
 "**MSG_button_Reverse_Chapter_Urls_Order**": {
  "message": "Змінити порядок посилань на глави",
  "description": "Label on button to change order of chapters from last to first"
 },
 "**MSG_button_Select_All**": {
  "message": "Вибрати все",
  "description": "Label on button to set all chapters to selected"
 },
 "**MSG_button_test_default_parser**": {
  "message": "Тест",
  "description": "Label on button to test default parser settings"
 },
 "**MSG_button_Unselect_All**": {
  "message": "Скасувати виділення",
  "description": "Label on button to unselect all chapters"
 },
 "**MSG_button_View_Reading_List**": {
  "message": "Перегляд Списка читання",
  "description": "Label on button to show Reading List"
 },
 "**MSG_button_Write_Options_to_file**": {
  "message": "Зберегти налаштування у файл",
  "description": "Label on button to write options to a file"
 },
 "**MSG_column_Include**": {
  "message": "Включати?",
  "description": "The 'include this chapter' checkbox column in the table of chapters."
 },
 "**MSG_column_Title**": {
  "message": "Назва:",
  "description": "The 'name of chapter' column in the table of chapters."
 },
 "**MSG_column_URL**": {
  "message": "Адреса:",
  "description": "The 'URL to get chapter from' column in the table of chapters."
 },
 "**MSG_label_Advanced_Options_Visible_By_Default**": {
  "message": "Розширені налаштування видно за замовчунням",
  "description": "Label for checkbox to make Advanced Options visible when UI opens"
 },
 "**MSG_label_Author**": {
  "message": "Автор:",
  "description": "Label in front input for novel's Author"
 },
 "**MSG_label_Auto_Parser_Select_Includes_Baka_Tsuki_Series_Page_Parser**": {
  "message": "Автоматичний підбір парсеру спробує Baka-Tsuki Series Page Parser",
  "description": "Label for checkbox to toggle logic that picks parser to use for a web page to include the Baka-Tsuki Series Page Parser"
 },
 "**MSG_label_Chapter_Count**": {
  "message": "Кількість глав:",
  "description": "Label for number of chapters in range"
 },
 "**MSG_label_Chapters_Page_In_Chapters_List**": {
  "message": "Додати у зміст сторінку зі списком глав",
  "description": "Label for checkbox to toggle adding the page with chapters to list of pages to fetch"
 },
 "**MSG_label_Cover_from_URL**": {
  "message": "Завантажити іншу обкладинку:",
  "description": "Label for checkbox to toggle between picking cover image from list or with a URL"
 },
 "**MSG_label_Cover_Image_URL**": {
  "message": "Адреса для завантаження обкладинки:",
  "description": "Label for input to give cover image as URL"
 },
 "**MSG_label_Create_Epub_3**": {
  "message": "Створювати EPUB 3",
  "description": "Label for checkbox to choose between EPUB 2 and 3"
 },
 "**MSG_label_File_Author_as**": {
  "message": "Автор:",
  "description": "Label in front of input for author's name should be filed (in Advanced settings)."
 },
 "**MSG_label_Default_Parser_Chapter_Title_CSS**": {
  "message": "CSS-селектор елементу, що містить назву глави:",
  "description": "Label in front of input for CSS selector to find element holding title of a chapter"
 },
 "**MSG_label_Default_Parser_Content_CSS**": {
  "message": "(обов’язково) CSS-селектор елементу, чий вміст буде додано до EPUB:",
  "description": "Label in front of input for CSS selector to find element holding content to put into EPUB"
 },
 "**MSG_label_Default_Parser_HostName**": {
  "message": "Домен сайту:",
  "description": "Label in front of input for hostname in URL to use these settings for."
 },
 "**MSG_label_Default_Parser_Test_Chapter_Url**": {
  "message": "Адреса першої глави:",
  "description": "Label in front of input for URL to test default parser settings."
 },
 "**MSG_label_Default_Parser_Unwanted_Elements_CSS**": {
  "message": "CSS-селектор елементу (елементів), що будуть видалені:",
  "description": "Label in front input for CCS selector for elements to remove"
 },
 "**MSG_label_Element_With_Chapter_Content**": {
  "message": "Елемент, що містить главу:",
  "description": "Label in front input for type of element holding each chapter's content"
 },
 "**MSG_label_Filename**": {
  "message": "Ім’я файлу:",
  "description": "Label in front input for file to save EPUB as"
 },
 "**MSG_label_Developer_Stuff**": {
  "message": "Інструменти розробника:",
  "description": "Label for checkbox to show/hide buttons for developer testing (in Advanced settings)."
 },
 "**MSG_label_Fetch_Highest_Resolution_Images**": {
  "message": "Надавати перевагу зображенням покращенної якості",
  "description": "Label for checkbox to get EPUB to include highest resolution images available (in Advanced settings)."
 },
 "**MSG_label_Include_in_Reading_List**": {
  "message": "Додати у Список читання",
  "description": "Label for checkbox to add/remove title from Reading List of tracked titles."
 },
 "**MSG_label_Include_URL_of_Images**": {
  "message": "Включити адреси зображень",
  "description": "Label for checkbox to record source URL of images into EPUB (in Advanced settings)."
 },
 "**MSG_label_Language**": {
  "message": "Мова:",
  "description": "Label in front input for language EPUB will be in"
 },
 "**MSG_label_Manually_Select_Parser**": {
  "message": "Обрати парсер:",
  "description": "Label for menu to change parser (in advanced options section)"
 },
 "**MSG_label_Max_pages_to_fetch_simultaneously**": {
  "message": "Максимальна кількість сторінок, що завантажуються водночас",
  "description": "Label for drop down for maximum number of web pages to request at same time"
 },
 "**MSG_label_Range_End_Chapter**": {
  "message": "Остання глава:",
  "description": "Label in front of drop down for selecting last chapter to include in epub"
 },
 "**MSG_label_Range_Start_Chapter**": {
  "message": "Перша глава:",
  "description": "Label in front of drop down for selecting first chapter to include in epub"
 },
 "**MSG_label_Read_Options_from_file**": {
  "message": "Завантажити налаштування з файлу:",
  "description": "Label in front of button to read Options from a file"
 },
 "**MSG_label_Remove_Author_Notes**": {
  "message": "Видалити авторські замітки",
  "description": "Label for checkbox to remove Author Notes from chapters"
 },
 "**MSG_label_Remove_Original**": {
  "message": "Видалити оригінальний (необроблений) текст",
  "description": "Label for checkbox to remove Original text from chapters"
 },
 "**MSG_label_Remove_Duplicate_Images**": {
  "message": "Видалити дублікати зображень:",
  "description": "Label for checkbox to remove duplicate images from gallery (in cover images section)"
 },
 "**MSG_label_Remove_Superscript_From_Alternate_Translations**": {
  "message": "Видалити з тексту альтернативні варіанти перекладу",
  "description": "Label for checkbox to convert superscripted alternate translations into inline text"
 },
 "**MSG_label_Series**": {
  "message": "Серія:",
  "description": "Label in front input for series Novel is part of"
 },
 "**MSG_label_Starting_URL**": {
  "message": "Початкова адреса:",
  "description": "Label in front of 'URL' input"
 },
 "**MSG_label_Stylesheet**": {
  "message": "Стилі:",
  "description": "Label in front of edit field for setting the stylesheet (in Advanced settings)."
 },
 "**MSG_label_Title**": {
  "message": "Назва:",
  "description": "Label in front of input for Novel's title."
 },
 "**MSG_label_Translator**": {
  "message": "Перекладач:",
  "description": "Label in front of input for Translator (in Advanced settings)."
 },
 "**MSG_label_Use_SVG_for_Images**": {
  "message": "Використовувати <svg> для зображень",
  "description": "Label in front of checkbox to choose between <img> and <svg> elements for images."
 },
 "**MSG_label_Using_Default_Parser**": {
  "message": "Не вдалося підібрати парсер. Використовується парсер за замовчунням. Будь ласка, вкажіть, як потрібно отримувати вміст сторінок.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "**MSG_label_Volume**": {
  "message": "Том у серії:",
  "description": "Label in front of input for novel's position in series."
 },
 "**MSG_label_No_Download_Popup**": {
  "message": "Зберегти epub у фоновому режимі",
  "description": "Label for checkbox to download the final epub without a popup"
 },
 "**MSG_label_Disable_Shift_Click_Alert**": {
  "message": "Вимкнути попередження про Shift+клік вибір",
  "description": "Label for checkbox to disable the alert shown when user shift-clicks to select multiple chapters"
 },
 "**MSG_label_Disable_Image_Res_Error**": {
  "message": "Вимкнути попередження про невдачі високої роздільності зображень",
  "description": "Label for checkbox to disable warnings when high resolution image fetch fails and lower resolution is used instead"
 },
 "**MSG_label_Disable_Webp_Image_Format_Error**": {
  "message": "Вимкнути попередження про сумісність формату WebP",
  "description": "Label for checkbox to disable warnings that WebP format images may not render in epub viewers"
 },
 "**MSG_label_Write_Error_History_To_File**": {
  "message": "Зберігати помилки у файл",
  "description": "Label for checkbox to write recent error messages to file"
 },
 "**MSG_option_Class_Is**": {
  "message": "Class з’являється",
  "description": "Content is element of specified class."
 },
 "**MSG_option_Class_Starts_With**": {
  "message": "Class починається з",
  "description": "Content is element having a class name starting with."
 },
 "**MSG_option_First_Found**": {
  "message": "Перший знайдений",
  "description": "Content is first element of specified type found."
 },
 "**MSG_option_ID_Is**": {
  "message": "ID з’являється",
  "description": "Content is element with specified ID."
 },
 "**MSG_option_ID_Starts_With**": {
  "message": "ID починається з",
  "description": "Content is element having an ID starting with."
 },
 "**MSG_Searching_For_URLs_Please_Wait**": {
  "message": "Пошук адрес. Будь ласка, зачекайте.",
  "description": "Message shown while looking for list of Chapter URLs."
 },
 "**MSG_Shift_Click**": {
  "message": "Ви можете виділити декілька глав наступним чином: відмітьте першу бажану главу, затисніть клавішу Shift та відмітьте останню обрану главу.",
  "description": "Tell user how to shift-click to multiselect."
 },
 "convertToXhtmlWarning": {
  "message": "Увага: не вдалося конвертувати главу '$chapter$' за адресою '$url$' у дійсний XHTML. Ваша EPUB-читалка можливо буде неспроможна прочитати цю главу. Можливо вам доведеться виправити цю главу вручну у Calibre. \r\nПомилки конвертації: ($error$)",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "chapter": {
       "content": "$1"
   },
   "url": {
       "content": "$2"
   },
   "error": {
       "content": "$3"
   }
  }
 },
 "defaultAuthor": {
  "message": "Автор не заданий",
  "description": "Default author value to use when one is not supplied"
 },
 "defaultTitle": {
  "message": "Назва не задана",
  "description": "Default UUID value to use when one is not supplied"
 },
 "defaultUUID": {
  "message": "UUID не задано",
  "description": "Default UUID value to use when one is not supplied"
 },
 "errorContentNotFound": {
  "message": "Не знайдено елемент з вмістом на сторінці '$url$'.",
  "description": "Warning message when can't find content element for a web page",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "errorIllegalFileName": {
  "message": "Ім’я файлу '$filename$' не може містити наступні символи: $illegalCharacters$",
  "description": "Warning message when filename isn't legal",
  "placeholders": {
   "filename": {
       "content": "$1"
   },
   "illegalCharacters": {
       "content": "$2"
   }
  }
 },
 "gotHtmlExpectedImageWarning": {
  "message": "За адресою '$url$' отримана HTML-сторінка, але очікувалося зображення.",
  "description": "Warning message when try to fetch an image and instead get HTML",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "httpFetchCanRetry": {
  "message": "Раптово виникла помилка. Будь ласка, спробуйте ще раз.",
  "description": "Added message that retrying HTTP operation may succeed."
 },
 "htmlFetchFailed": {
  "message": "Спроба завантаження адреси '$url$' скінчилася помилкою мережі: $err$.",
  "description": "Error message when fetch of a web page fails.",
  "placeholders": {
   "url": {
       "content": "$1"
   },
   "err": {
       "content": "$2"
   }
  }
 },
 "imageFetchFailed": {
  "message": "Спроба завантаження зображення '$imageUrl$' для сторінки '$pageUrl$' скінчилася помилкою мережі: $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "imgurFetchFailed": {
  "message": "Увага: спроба завантаження IMGUR-зображення '$imageUrl$' для сторінки '$pageUrl$' скінчилася помилкою мережі: $err$.",
  "description": "Error message when fetch of an image file fails.",
  "placeholders": {
   "imageUrl": {
       "content": "$1"
   },
   "pageUrl": {
       "content": "$2"
   },
   "err": {
       "content": "$3"
   }
  }
 },
 "noChaptersFound": {
  "message": "Глави не знайдено. Можливо, це не є адресою титульною сторінки новели.",
  "description": "Warning message when parser can't find list of chapters."
 },
 "informationPageTitle": {
  "message": "Інформація",
  "description": "Title of page that gives information on epub."
 },
 "noChaptersFoundAndFetchClicked": {
  "message": "Глави не знайдено.",
  "description": "Warning message.  Developer has clicked 'Fetch Chapters' when there are none."
 },
 "noImagesFound": {
  "message": "Зображень не знайдено.",
  "description": "Warning message.  Developer has clicked 'Fetch Images' when there are none."
 },
 "noImagesFoundLabel": {
  "message": "Зображень не знайдено",
  "description": "Text put in images table when no images are found."
 },
 "noParserFound": {
  "message": "Не вдалося підібрати парсер. Використовується парсер за замовчунням. Будь ласка, вкажіть, як потрібно отримувати вміст глав.",
  "description": "Warning message when can't figure out how to extract info from web page."
 },
 "setCover": {
  "message": "Обрати обкладинку",
  "description": "Label for checkboxes used to select the cover image."
 },
 "tableOfContentsUrl": {
  "message": "Адреса змісту:",
  "description": "Label on information page for URL where Table of Contents came from."
 },
 "unhandledFieldTypeError": {
  "message": "ERROR: Unhandled field type.",
  "description": "Internal message for developer."
 },
 "warningNoChapterUrl": {
  "message": "ПОМИЛКА: Не вказано адресу глави для тесту.",
  "description": "Warning message when user tries to test the Default Parser without supplying a Chapter URL to test against."
 },
 "warningNoVisibleContent": {
  "message": "Увага: вказаний елемент для сторінки '$url$' не має наявного вмісту.",
  "description": "Warning message when content element for a page has nothing viewable",
  "placeholders": {
   "url": {
       "content": "$1"
   }
  }
 },
 "warningWebpImage": {
  "message": "Увага: зображення '$filename$' з’являється зображенням у форматі WEBP. Ваша EPUB-читалка може мати проблеми з його показом.",
  "description": "Warning message when downloaded image is in webp format",
  "placeholders": {
   "filename": {
       "content": "$1"
   }
  }
 }
}

================================================
FILE: plugin/_locales/vi/messages.json
================================================

{
    "**MSG_button_Advanced_Options**": {
        "message": "Tùy Chọn Nâng Cao",
        "description": ""
    },
    "**MSG_button_Apply_Changes**": {
        "message": "Áp Dụng Thay Đổ",
        "description": ""
    },
    "**MSG_button_Clear_Url**": {
        "message": "Xóa Đường Dẫn",
        "description": ""
    },
    "**MSG_button_Edit_Chapter_Urls**": {
        "message": "Chỉnh sửa Đường dẫn của Chương",
        "description": ""
    },
    "**MSG_button_error_Cancel**": {
        "message": "Ngưng",
        "description": ""
    },
    "**MSG_button_error_Skip**": {
        "message": "Bỏ qua",
        "description": ""
    },
    "**MSG_button_error_OK**": {
        "message": "OK",
        "description": ""
    },
    "**MSG_button_error_Retry**": {
        "message": "Thử lại",
        "description": ""
    },
    "**MSG_button_Help**": {
        "message": "Trợ giúp...",
        "description": ""
    },
    "**MSG_button_load_and_analyse**": {
        "message": "Tải và Phân Tích",
        "description": ""
    },
    "**MSG_button_Pack_EPUB**": {
        "message": "Đóng gói EPUB",
        "description": ""
    },
    "**MSG_button_Reset**": {
        "message": "Cài đặt về ban đầu",
        "description": ""
    },
    "**MSG_button_Reload**": {
        "message": "Tải Lại",
        "description": ""
    },
    "**MSG_button_Reset_stylesheet**": {
        "message": "Thiết đặt stylesheet về mặc định",
        "description": ""
    },
    "**MSG_button_Reverse_Chapter_Urls_Order**": {
        "message": "Đảo Ngược Vị Trí Đường Dẫn Chương",
        "description": ""
    },
    "**MSG_button_Select_All**": {
        "message": "Chọn Tất Cả",
        "description": ""
    },
    "**MSG_button_Unselect_All**": {
        "message": "Bỏ Chọn Tất Cả",
        "description": ""
    },
    "**MSG_column_Include**": {
        "message": "Bao gồm?",
        "description": ""
    },
    "**MSG_column_Title**": {
        "message": "Tiêu đề",
        "description": ""
    },
    "**MSG_column_URL**": {
        "message": "Đường dẫn",
        "description": ""
    },
    "**MSG_label_Advanced_Options_Visible_By_Default**": {
        "message": "Mặc Định Hiển Thị Tùy Chọn Nâng Cao",
        "description": ""
    },
    "**MSG_label_Author**": {
        "message": "Tác Giả",
        "description": ""
    },
    "**MSG_label_Auto_Parser_Select_Includes_Baka_Tsuki_Series_Page_Parser**": {
        "message": "Tự động lựa chọn parser bao gồm Parser dành cho các bộ truyện trên Baka-Tsuki",
        "description": ""
    },
    "**MSG_label_Chapter_Count**": {
        "message": "Tổng Số Chương:",
        "description": ""
    },
    "**MSG_label_Chapters_Page_In_Chapters_List**": {
        "message": "Thêm Trang vào Danh Sách Chương",
        "description": ""
    },
    "**MSG_label_Cover_from_URL**": {
        "message": "Ảnh bìa từ đường dẫn:",
        "description": ""
    },
    "**MSG_label_Cover_Image_URL**": {
        "message": "Đường dẫn ảnh bìa:",
        "description": ""
    },
    "**MSG_label_Create_Epub_3**": {
        "message": "Tạo EPUB 3",
        "description": ""
    },
    "**MSG_label_File_Author_as**": {
        "message": "Tên tác giả cho tập tin",
        "description": ""
    },
    "**MSG_label_Element_With_Chapter_Content**": {
        "message": "Phần Tử chứa Nội dung Chương:",
        "description": ""
    },
    "**MSG_label_Filename**": {
        "message": "Tên tập tin",
        "description": ""
    },
    "**MSG_label_Developer_Stuff**": {
        "message": "Dành Cho Lập Trình Viên:",
        "description": ""
    },
    "**MSG_label_Fetch_Highest_Resolution_Images**": {
        "message": "Tải Ảnh Độ Phân Giải Cao Nhất",
        "description": ""
    },
    "**MSG_label_Include_URL_of_Images**": {
        "message": "Bao gồm Đường dẫn của Ảnh",
        "description": ""
    },
    "**MSG_label_Language**": {
        "message": "Ngôn Ngữ",
        "description": ""
    },
    "**MSG_label_Manually_Select_Parser**": {
        "message": "Chọn Parser Bằng Tay",
        "description": ""
    },
    "**MSG_label_Max_pages_to_fetch_simultaneously**": {
        "message": "Lượng trang tối đa tải về đồng thời",
        "description": ""
    },
    "**MSG_label_Range_End_Chapter**": {
        "message": "Chương Cuối",
        "description": ""
    },
    "**MSG_label_Range_Start_Chapter**": {
        "message": "Chương Đầu",
        "description": ""
    },
    "**MSG_label_Remove_Author_Notes**": {
        "message": "Xóa Ghi Chú Tác Giả",
        "description": ""
    },
    "**MSG_label_Remove_Original**": {
        "message": "Loại bỏ Chữ Bản Gốc/Raw",
        "description": ""
    },
    "**MSG_label_Remove_Duplicate_Images**": {
        "message": "Loại Bỏ Ảnh Trùng Lặp:",
        "description": ""
    },
    "**MSG_label_Remove_Superscript_From_Alternate_Translations**": {
        "message": "Loại Bỏ Ký Tự Trên Khỏi Từ",
        "description": ""
    },
    "**MSG_label_Series**": {
        "message": "Bộ Truyện",
        "description": ""
    },
    "**MSG_label_Starting_URL**": {
        "message": "Đường Dẫn Bắt Đầu",
        "description": ""
    },
    "**MSG_label_Stylesheet**": {
        "message": "Stylesheet:",
        "description": ""
    },
    "**MSG_label_Title**": {
        "message": "Tiêu đề",
        "description": ""
    },
    "**MSG_label_Translator**": {
        "message": "Dịch Giả",
        "description": ""
    },
    "**MSG_label_Use_SVG_for_Images**": {
        "message": "Sử dụng <svg> cho hình ảnh",
        "description": ""
    },
    "**MSG_label_Volume**": {
        "message": "Tập",
        "description": ""
    },
    "**MSG_label_No_Download_Popup**": {
        "message": "Lưu epub trong nền",
        "description": "Label for checkbox to download the final epub without a popup"
    },
    "**MSG_label_Disable_Shift_Click_Alert**": {
        "message": "Tắt thông báo chọn bằng Shift+Click",
        "description": "Label for checkbox to disable the alert shown when user shift-clicks to select multiple chapters"
    },
    "**MSG_label_Disable_Image_Res_Error**": {
        "message": "Tắt cảnh báo lỗi hình ảnh độ phân giải cao",
        "description": "Label for checkbox to disable warnings when high resolution image fetch fails and lower resolution is used instead"
    },
    "**MSG_label_Disable_Webp_Image_Format_Error**": {
        "message": "Tắt cảnh báo tương thích định dạng WebP",
        "description": "Label for checkbox to disable warnings that WebP format images may not render in epub viewers"
    },
    "**MSG_label_Write_Error_History_To_File**": {
        "message": "Ghi các thông báo lỗi gần đây vào tập tin",
        "description": ""
    },
    "**MSG_option_Class_Is**": {
        "message": "Class là",
        "description": ""
    },
    "**MSG_option_Class_Starts_With**": {
        "message": "Class Bắt Đầu Vớ",
        "description": ""
    },
    "**MSG_option_First_Found**": {
        "message": "Đầu Tiên Tìm Thấy",
        "description": ""
    },
    "**MSG_option_ID_Is**": {
        "message": "ID là",
        "description": ""
    },
    "**MSG_option_ID_Starts_With**": {
        "message": "ID Bắt Đầu Với",
        "description": ""
    },
    "**MSG_Searching_For_URLs_Please_Wait**": {
        "message": "Đang Truy Tìm Các Đường Dẫn. Vui lòng đợi.",
        "description": ""
    },
    "**MSG_Shift_Click**": {
        "message": "Bạn có thể chọn hoặc bỏ chọn một dải nhiều chương bằng việc chọn vào ô chọn cho phần chương đầu, sau đó giữ phím Shift và chọn phần chương cuối trong dải chương.",
        "description": ""
    },
    "convertToXhtmlWarning": {
        "message": "Cảnh báo, không thể chuyển đổi chương '$chapter$' từ '$url$' sang XHTML chuẩn. Trình xem Epub của bạn có thể gặp lỗi khi hiển thị chương này. Bạn có thể cần phải tự sửa chương này bằng tay bằng phần mềm Calibre. \r\nTin nhắn báo lỗi khi chuyển đổi: ($error$)",
        "description": "",
        "placeholders": {
            "chapter": {
                "content": "$1"
            },
            "url": {
                "content": "$2"
            },
            "error": {
                "content": "$3"
            }
        }
    },
    "defaultAuthor": {
        "message": "Tên Tác Giả Không Được Cấp",
        "description": ""
    },
    "defaultTitle": {
        "message": "Tiêu Đề Không Được Cấp",
        "description": ""
    },
    "defaultUUID": {
        "message": "UUID Không Được Cấp",
        "description": ""
    },
    "errorContentNotFound": {
        "message": "Không thể tìm thấy nội dung trang cho trang web '$url$'",
        "description": "",
        "placeholders": {
            "url": {
                "content": "$1"
            }
        }
    },
    "errorIllegalFileName": {
        "message": "Tên tập tin '$filename$' không được phép chứa các ký tự sau: $illegalCharacters$",
        "description": "",
        "placeholders": {
            "filename": {
                "content": "$1"
            },
            "illegalCharacters": {
                "content": "$2"
            }
        }
    },
    "gotHtmlExpectedImageWarning": {
        "message": "Tải trang từ đường dẫn '$url$' trả kết quả lại là HTML, có thể chỉ là hình ảnh",
        "description": "",
        "placeholders": {
            "url": {
                "content": "$1"
            }
        }
    },
    "httpFetchCanRetry": {
        "message": "Bị lỗi gián đoạn. Thử lại có thể thành công.",
        "description": ""
    },
    "htmlFetchFailed": {
        "message": "Tải trang từ đường dẫn '$url$' bị lỗi do lỗi mạng $err$",
        "description": "",
        "placeholders": {
            "url": {
                "content": "$1"
            },
            "err": {
                "content": "$2"
            }
        }
    },
    "imageFetchFailed": {
        "message": "Sự cố khi lấy hình ảnh '$imageUrl$' cho trang '$pageUrl$' do lỗi mạng $err$.",
        "description": "",
        "placeholders": {
            "imageUrl": {
                "content": "$1"
            },
            "pageUrl": {
                "content": "$2"
            },
            "err": {
                "content": "$3"
            }
        }
    },
    "imgurFetchFailed": {
        "message": "Cảnh Báo: Cố lấy ảnh imgur '$imageUrl$' cho trang '$pageUrl$' bị lỗi do lỗi mạng $err$.",
        "description": "",
        "placeholders": {
            "imageUrl": {
                "content": "$1"
            },
            "pageUrl": {
                "content": "$2"
            },
            "err": {
                "content": "$3"
            }
        }
    },
    "noChaptersFound": {
        "message": "Không tìm thấy chương. Có thể đây không phải một trang thuộc bộ truyện.",
        "description": ""
    },
    "informationPageTitle": {
        "message": "Thông Tin",
        "description": ""
    },
    "noChaptersFoundAndFetchClicked": {
        "message": "Không tìm thấy chương.",
        "description": ""
    },
    "noImagesFound": {
        "message": "Không tìm thấy ảnh.",
        "description": ""
    },
    "noImagesFoundLabel": {
        "message": "Không tìm thấy ảnh",
        "description": ""
    },
    "noParserFound": {
        "message": "Không tìm thấy parser nào cho đường dẫn này.  Parser mặc định sẽ được sử dụng.  Bạn sẽ cần phải tự xác định cách thức lấy nội dung trang cho từng chương.",
        "description": ""
    },
    "setCover": {
        "message": "Đăt Ảnh Bìa",
        "description": ""
    },
    "tableOfContentsUrl": {
        "message": "Đường Dẫn/URL Mục Lục: ",
        "description": ""
    },
    "unhandledFieldTypeError": {
        "message": "Lỗi: Unhandled field type.",
        "description": ""
    },
    "warningNoVisibleContent": {
        "message": "Cảnh báo, nội dung trang cho trang web '$url$' không có nội dung nào có thể nhìn thấy.",
        "description": "",
        "placeholders": {
            "url": {
                "content": "$1"
            }
        }
    },
    "warningWebpImage": {
        "message": "Cảnh báo: tệp hình ảnh '$filename$' ở định dạng webp. Trình xem epub của bạn có thể không dựng được hình ảnh đó.",
        "description": "",
        "placeholders": {
            "filename": {
                "content": "$1"
            }
        }
    }
}

================================================
FILE: plugin/css/alwaysDark.css
================================================

body {
    background: #2f2f2f;
    color: #eee;
}

input, button, select, progress, textarea {
    background: #2b2b2b;
    color: #eee;
}

    button:hover {
        color: #222222;
    }

================================================
FILE: plugin/css/autoDark.css
================================================

@media (prefers-color-scheme: dark) {
    body {
        background: #2f2f2f;
        color: #eee;
    }

    input, button, select, progress, textarea {
        background: #2b2b2b;
        color: #eee;
    }

        button:hover {
            color: #222222;
        }
}

================================================
FILE: plugin/css/default.css
================================================

.expandedButton {
    padding: 5px 10px;
}

.warning {
    color: #ff0000;
    font-size: 2em;
    font-weight: bold;
}

.scrollingtable {
    overflow: scroll;
    height: 300px;
}

# progressString {

    width: 36px;
    display: inline-block;
    position: absolute;
    left: 46%;
    color: white;
    z-index: 1000;
    font-weight: bolder;
    margin-top: 7px;
}

# advancedOptionsSection {

    margin-top: 3px;
    margin-bottom: 20px;
    border-bottom: 1px #CCC solid;
}

progress {
    width: 56%;
    height: 31px;
    margin: 0;
    padding: 0;
    border-radius: 5px;
    margin-left: 4px;
    margin-right: 4px;
}

    progress::-webkit-progress-bar {
        border: 0;
        height: 31px;
        border-radius: 5px;
    }

    progress::-webkit-progress-value {
        border: 0;
        height: 31px;
        border-radius: 8px;
    }

    progress::-moz-progress-bar {
        border: 0;
        height: 31px;
        border-radius: 5px;
    }

[hidden] {
    display: none;
}

table.chapterList {
    width: 100%;
}

section.minWidth {
    min-width: 600px;
}

.withBorder {
    border: 1px solid black;
}

.withMargin {
    margin-left: 5px;
}

td.disabled {
    opacity: 0.5;
}

button:disabled {
    opacity: 0.5;
}

/_----------------------------------------------------_/

.container {
    border: 1px #CCC solid;
    display: table;
    padding: 10px;
    margin: auto;
    border-radius: 5px;
    position:relative;
}

input[type=text], input[type=url], textarea, select, #manualDelayPerChapterTag {
    padding: 4px;
    border: 1px #CCC solid;
    border-radius: 3px;
    max-width: 400px;
    min-width: 356px;
}

# advancedOptionsSection textarea, #advancedOptionsSection select, #manualDelayPerChapterTag {

    min-width: inherit !important;
}

textarea.allSpace {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    max-width: none;
}

# inputSection input {

    width: 69%;
}

# inputSection table, #chapterUrlsTable {

    width: 100%;
}

    #chapterUrlsTable input[type=checkbox],
    #chapterUrlsTable img,
    #chapterUrlsTable .tooltip {
        float: left;
    }

    img.downloadState {
        height: 1em;
        margin-top: 3px;
    }

    .downloadStateDiv {
        position: relative;
        display: inline-block;
    }

    .downloadStateDiv .tooltipText {
        visibility: hidden;
        width: 120px;
        background-color: #808080;
        color: white;
        text-align: center;
        padding: 5px;
        border-radius: 5px;
        position: absolute;
        z-index: 1;
        top: -5px;
        left: 105%;
    }

    .downloadStateDiv:hover .tooltipText {
        visibility: visible;
    }

    #chapterUrlsTable input[type=text] {
        width: 101.5%;
        position: relative;
        left: -16px;
        max-width: 580px;
    }

    #chapterUrlsTable tbody > tr > th {
        text-align: center;
        border-bottom: 1px #CCC solid;
        padding: 0;
    }

# inputSection tbody > tr > td:first-child {

    width: 75px;
}

# chapterUrlsTable > tr > td:first-child, #chapterUrlsTable > tbody > tr > td:nth-child(2) {

    width: 3px;
}

button {
    box-shadow: inset 0px 1px 0px 0px #ffffff;
    background: linear-gradient(to bottom, #ffffff 5%, #f6f6f6 100%);
    background-color: #ffffff;
    border-radius: 6px;
    border: 1px solid #dcdcdc;
    display: inline-block;
    cursor: pointer;
    color: #666666;
    font-family: Arial;
    font-size: 12px;
    padding: 4px 8px;
    text-decoration: none;
    max-height: 30px;
}

    button:hover {
        background: linear-gradient(to bottom, #f6f6f6 5%, #ffffff 100%);
        background-color: #f6f6f6;
    }

    button:active {
        position: relative;
        top: 1px;
    }

.progressSection {
    width: 94%;
    position: relative;
    display: flex;
    height: 60px;
    border: 1px #CCC solid;
    padding-top: 30px;
    padding-left: 39px;
    border-radius: 8px;
    max-width: 648px;
}

# coverUrlSection img {

    max-height: 142px;
    max-width: 106.5px;
    position: absolute;
    top: 14px;
    right: 7%;
}

.LibCover {
    max-height: 115.5px;
    max-width: 106.5px;
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.LibCoverCompact {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.HiddenButtonSection {
    position: relative;
    display: flex;
  justify-content: center;
    border-radius: 8px;
}

.sidebar {
    background-color:rgba(40, 40, 40, 0.85);
    float:left;
    margin-right:5px;
    height: 100%;
    width: 0px;
    position: fixed;
    z-index: 1;
    top: 0;
    right: 0;
    overflow-x: hidden;
    box-sizing: border-box;
    margin: 0 auto;
    transition: 0.25s;
  }

    .sidebar.sidebarOpen {
        width: 30%;
        min-width: 300px;
    }
    
    .sidebar .closebtn {
        width: calc(100% - 10px);
        padding-top: 5px;
        padding-bottom: 5px;
        border: 2px;
        border-color: #dcdcdc75;
        border-style: solid;
        border-radius: 10px;
        text-align: center;
    }
    .sidebar .closebtn:hover {
        background-color: #cccccc75;
    }

    .sidebar th {
        text-align: center;
    }
    
    .sidebar input.exclude {
        accent-color: #bb0000;
    }
    .sidebar input[type=text], .sidebar input[type=url], .sidebar textarea, .sidebar select {
        padding: 4px;
        border: 1px #CCC solid;
        border-radius: 3px;
        max-width: 100%;
        min-width: 100px;
    }
    .sidebar label {
        display: block;
        width: 100%;
        font-size: 16px;
        padding-bottom: 5px;
        user-select: none;
    }
    .sidebar tr label:hover {
        background-color:rgba(40, 40, 40);
    }
    #sbFilters {
        max-height: calc(50% - 30px);
        overflow-y: scroll;
    }
    #sbFilters input[type=text], #sbFilters input[type=url], #sbFilters textarea, #sbFilters select {
        width: calc(100% - 15px);
    }

================================================
FILE: plugin/js/ChapterUrlsUI.js
================================================

"use strict";

/** Class that handles UI for selecting (chapter) URLs to fetch */
class ChapterUrlsUI {
    constructor(parser) {
        this.parser = parser;
        ChapterUrlsUI.getPleaseWaitMessageRow().hidden = false;
        if (this.parser)
        {
            let nameElement = document.getElementById("spanParserName");
            if (nameElement) nameElement.textContent = this.parser.constructor.name;

            let delayMsElement = document.getElementById("spanDelayMs");
            if (delayMsElement) delayMsElement.textContent = `${this.parser.getRateLimit()} ms`;
        }

        let formElement = document.getElementById("sbFiltersForm");
        if (formElement) {
            document.getElementById("sbFiltersForm").onsubmit = (event) => {
                event.preventDefault();
            };
        }
    }

    connectButtonHandlers() {
        document.getElementById("selectAllUrlsButton").onclick = ChapterUrlsUI.setAllUrlsSelectState.bind(null, true);
        document.getElementById("unselectAllUrlsButton").onclick = ChapterUrlsUI.setAllUrlsSelectState.bind(null, false);
        document.getElementById("reverseChapterUrlsOrderButton").onclick = this.reverseUrls.bind(this);
        document.getElementById("editChaptersUrlsButton").onclick = this.setEditInputMode.bind(this);
        document.getElementById("copyUrlsToClipboardButton").onclick = this.copyUrlsToClipboard.bind(this);
        document.getElementById("showChapterUrlsCheckbox").onclick = this.toggleShowUrlsForChapterRanges.bind(this);
        ChapterUrlsUI.modifyApplyChangesButtons(button => button.onclick = this.setTableMode.bind(this));
    }

    populateChapterUrlsTable(chapters) {
        ChapterUrlsUI.getPleaseWaitMessageRow().hidden = true;
        ChapterUrlsUI.clearChapterUrlsTable();
        let linksTable = ChapterUrlsUI.getChapterUrlsTable();
        let index = 0;
        let rangeStart = ChapterUrlsUI.getRangeStartChapterSelect();
        let rangeEnd = ChapterUrlsUI.getRangeEndChapterSelect();
        let memberForTextOption = ChapterUrlsUI.textToShowInRange();
        chapters.forEach((chapter) => {
            let row = document.createElement("tr");
            ChapterUrlsUI.appendCheckBoxToRow(row, chapter);
            ChapterUrlsUI.appendInputTextToRow(row, chapter);
            chapter.row = row;
            ChapterUrlsUI.appendColumnDataToRow(row, chapter.sourceUrl);
            linksTable.appendChild(row);
            ChapterUrlsUI.appendOptionToSelect(rangeStart, index, chapter, memberForTextOption);
            ChapterUrlsUI.appendOptionToSelect(rangeEnd, index, chapter, memberForTextOption);
            ++index;
        });
        ChapterUrlsUI.setRangeOptionsToFirstAndLastChapters();
        this.showHideChapterUrlsColumn();
        ChapterUrlsUI.resizeTitleColumnToFit(linksTable);
    }

    showTocProgress(chapters) {
        let linksTable = ChapterUrlsUI.getChapterUrlsTable();
        chapters.forEach((chapter) => {
            let row = document.createElement("tr");
            linksTable.appendChild(row);
            row.appendChild(document.createElement("td"));
            let col = document.createElement("td");
            col.className = "disabled";
            col.appendChild(document.createTextNode(chapter.title));
            row.appendChild(col);
            row.appendChild(document.createElement("td"));
        });
    }

    static showDownloadState(row, state) {
        if (row != null) {
            let downloadStateDiv = row.querySelector(".downloadStateDiv");
            ChapterUrlsUI.updateDownloadStateImage(downloadStateDiv, state);
        }
    }

    static updateDownloadStateImage(downloadStateDiv, state) {
        let img = downloadStateDiv.querySelector("img");
        if (img) {
            img.src = ChapterUrlsUI.ImageForState[state];

            // Update tooltip
            let tooltipText = ChapterUrlsUI.TooltipForSate[state];
            let tooltipTextSpan = downloadStateDiv.querySelector(".tooltipText");

            if (tooltipText && !tooltipTextSpan) {
                tooltipTextSpan = document.createElement("span");
                tooltipTextSpan.className = "tooltipText";
                tooltipTextSpan.textContent = tooltipText;
                downloadStateDiv.appendChild(tooltipTextSpan);
            } else if (tooltipText) {
                tooltipTextSpan.textContent = tooltipText;
            } else if (tooltipTextSpan) {
                // Remove tooltip text if there is no text to display
                downloadStateDiv.removeChild(tooltipTextSpan);
            }
        }
    }

    static resetDownloadStateImages() {
        let linksTable = ChapterUrlsUI.getChapterUrlsTable();
        let prevDownload = ChapterUrlsUI.ImageForState[ChapterUrlsUI.DOWNLOAD_STATE_PREVIOUS];
        let downloaded = ChapterUrlsUI.ImageForState[ChapterUrlsUI.DOWNLOAD_STATE_LOADED];

        for (let downloadStateDiv of linksTable.querySelectorAll(".downloadStateDiv")) {
            let state = ChapterUrlsUI.DOWNLOAD_STATE_NONE;
            let imgSrc = downloadStateDiv.querySelector("img")?.src;
            if (imgSrc) {
                const imagesIndex = imgSrc.indexOf("images/");
                if (imagesIndex !== -1) {
                    imgSrc = imgSrc.substring(imagesIndex);
                }
            }
            if (imgSrc === prevDownload || imgSrc === downloaded) {
                state = ChapterUrlsUI.DOWNLOAD_STATE_PREVIOUS;
            }
            ChapterUrlsUI.updateDownloadStateImage(downloadStateDiv, state);
        }
    }

    static clearChapterUrlsTable() {
        util.removeElements(ChapterUrlsUI.getTableRowsWithChapters());
        util.removeElements([...ChapterUrlsUI.getRangeStartChapterSelect().options]);
        util.removeElements([...ChapterUrlsUI.getRangeEndChapterSelect().options]);
    }

    static limitNumOfChapterS(maxChapters) {
        let max = util.isNullOrEmpty(maxChapters) ? 10000 : parseInt(maxChapters.replace(",", ""));
        let selectedRows = [...ChapterUrlsUI.getChapterUrlsTable().querySelectorAll("[type='checkbox'")]
            .filter(c => c.checked)
            .map(c => c.parentElement.parentElement);
        if (max< selectedRows.length ) {
            let message = UIText.Chapter.maxChaptersSelected(selectedRows.length, max);
            if (confirm(message) === false) {
                for (let row of selectedRows.slice(max)) {
                    ChapterUrlsUI.setRowCheckboxState(row, false);
                }
            }
        }
    }

    /** @private */
    static setRangeOptionsToFirstAndLastChapters()
    {
        let rangeStart = ChapterUrlsUI.getRangeStartChapterSelect();
        let rangeEnd = ChapterUrlsUI.getRangeEndChapterSelect();

        rangeStart.onchange = null;
        rangeEnd.onchange = null;
        
        rangeStart.selectedIndex = 0;
        rangeEnd.selectedIndex = rangeEnd.length - 1;
        ChapterUrlsUI.setChapterCount(rangeStart.selectedIndex, rangeEnd.selectedIndex);
        
        rangeStart.onchange = ChapterUrlsUI.onRangeChanged;
        rangeEnd.onchange = ChapterUrlsUI.onRangeChanged;
    }
 
    /** @private */
    static onRangeChanged() {
        let startIndex = ChapterUrlsUI.selectionToRowIndex(ChapterUrlsUI.getRangeStartChapterSelect());
        let endIndex = ChapterUrlsUI.selectionToRowIndex(ChapterUrlsUI.getRangeEndChapterSelect());
        let rc = new ChapterUrlsUI.RangeCalculator();

        for (let row of ChapterUrlsUI.getTableRowsWithChapters()) {
            let inRange = rc.rowInRange(row);
            ChapterUrlsUI.setRowCheckboxState(row, rc.rowInRange(row));
            row.hidden = !inRange;
        }
        ChapterUrlsUI.setChapterCount(startIndex, endIndex);
    }

    static selectionToRowIndex(selectElement) {
        let selectedIndex = selectElement.selectedIndex;
        return selectedIndex + 1;
    }

    /** @private */
    static setChapterCount(startIndex, endIndex) {
        let count = Math.max(0, 1 + endIndex - startIndex);
        document.getElementById("spanChapterCount").textContent = count;
    }
    
    /** 
    * @private
    */
    static getChapterUrlsTable() {
        return document.getElementById("chapterUrlsTable");
    }

    /** @private */
    static getRangeStartChapterSelect() {
        return document.getElementById("selectRangeStartChapter");
    }

    /** @private */
    static getRangeEndChapterSelect() {
        return document.getElementById("selectRangeEndChapter");
    }

    /** @private */
    static textToShowInRange() {
        return document.getElementById("showChapterUrlsCheckbox").checked
            ? "sourceUrl"
            : "title";
    }

    /** 
    * @private
    */
    static modifyApplyChangesButtons(mutator) {
        mutator(document.getElementById("applyChangesButton"));
        mutator(document.getElementById("applyChangesButton2"));
    }

    /** 
    * @private
    */
    static getEditChaptersUrlsInput() {
        return document.getElementById("editChaptersUrlsInput");
    }

    /** @private */
    static getPleaseWaitMessageRow() {
        return document.getElementById("findingChapterUrlsMessageRow");
    }

    /** @private */
    static setAllUrlsSelectState(select) {
        for (let row of ChapterUrlsUI.getTableRowsWithChapters()) {
            ChapterUrlsUI.setRowCheckboxState(row, select);
            row.hidden = false;
        }
        ChapterUrlsUI.setRangeOptionsToFirstAndLastChapters();
    }

    /** @private */
    static setRowCheckboxState(row, checked) {
        let input = row.querySelector("input[type='checkbox']");
        if (input.checked !== checked) {
            input.checked = checked;
            input.onclick();
        }
    }

    static getTableRowsWithChapters() {
        let linksTable = ChapterUrlsUI.getChapterUrlsTable();
        return [...linksTable.querySelectorAll("tr")]
            .filter(r => r.querySelector("th") === null);
    }

    /** 
    * @private
    */
    static appendCheckBoxToRow(row, chapter) {
        chapter.isIncludeable = chapter.isIncludeable ?? true;
        chapter.previousDownload = chapter.previousDownload ?? false;

        const col = document.createElement("td");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = chapter.isIncludeable;
        checkbox.onclick = (event) => { 
            chapter.isIncludeable = checkbox.checked;
            if (!event) return;

            ChapterUrlsUI.tellUserAboutShiftClick(event, row);

            if (event.shiftKey && (ChapterUrlsUI.lastSelectedRow !== null)) {
                ChapterUrlsUI.updateRange(ChapterUrlsUI.lastSelectedRow, row.rowIndex, checkbox.checked);
            } else {
                ChapterUrlsUI.lastSelectedRow = row.rowIndex;
            }
        };
        col.appendChild(checkbox);
        ChapterUrlsUI.addDownloadStateToCheckboxColumn(col, chapter.previousDownload);
        row.appendChild(col);
    }

    static addDownloadStateToCheckboxColumn(col, previousDownload) {
        let downloadStateDiv = document.createElement("div");
        downloadStateDiv.className = "downloadStateDiv";
        let img = document.createElement("img");
        img.className = "downloadState";

        downloadStateDiv.appendChild(img);
        ChapterUrlsUI.updateDownloadStateImage(downloadStateDiv,
            previousDownload ? ChapterUrlsUI.DOWNLOAD_STATE_PREVIOUS : ChapterUrlsUI.DOWNLOAD_STATE_NONE
        );
        col.appendChild(downloadStateDiv);
    }

    /** 
    * @private
    */
    static appendInputTextToRow(row, chapter) {
        let col = document.createElement("td");
        let input = document.createElement("input");
        input.type = "text";
        input.value = chapter.title;
        input.className = "fullWidth";
        input.addEventListener("blur", () => { chapter.title = input.value; },  true);
        col.appendChild(input);
        row.appendChild(col);
    }

    static appendOptionToSelect(select, value, chapter, memberForTextOption) {
        let option = new Option(chapter[memberForTextOption], value);
        select.add(option);
    }

    /** @private */
    static resizeTitleColumnToFit(linksTable) {
        let inputs = [...linksTable.querySelectorAll("input[type='text']")];
        let width = inputs.reduce((acc, element) => Math.max(acc, element.value.length), 0);
        if (0 < width) {
            inputs.forEach(i => i.size = width); 
        }
    }

    /** 
    * @private
    */
    static appendColumnDataToRow(row, textData) {
        let col = document.createElement("td");
        col.innerText = textData;
        col.style.whiteSpace = "nowrap";
        row.appendChild(col);
        return col;
    }

    /** 
    * @public
    */
    static setVisibleUI(toTable) {
        // toggle mode
        ChapterUrlsUI.getEditChaptersUrlsInput().hidden = toTable;
        ChapterUrlsUI.getChapterUrlsTable().hidden = !toTable;
        document.getElementById("inputSection").hidden = !toTable;
        document.getElementById("coverUrlSection").hidden = !toTable;
        document.getElementById("chapterSelectControlsDiv").hidden = !toTable;
        ChapterUrlsUI.modifyApplyChangesButtons(button => button.hidden = toTable);
        document.getElementById("editURLsHint").hidden = toTable;
    }

    /** 
    * @private
    */
    setTableMode() {
        try {
            let inputvalue = ChapterUrlsUI.getEditChaptersUrlsInput().value;
            let chapters;
            let lines = inputvalue.split("\n");
            lines = lines.filter(a => a.trim() != "").map(a => a.trim());
            if (URL.canParse(lines[0])) {
                chapters = this.URLsToChapters(lines);
            } else {
                chapters = this.htmlToChapters(inputvalue);
            }
            this.parser.setPagesToFetch(chapters);
            this.populateChapterUrlsTable(chapters);
            this.usingTable = true;
            ChapterUrlsUI.setVisibleUI(this.usingTable);
        } catch (err) {
            ErrorLog.showErrorMessage(err);
        }
    }

    /** @private */
    reverseUrls() {
        try {
            let chapters = [...this.parser.getPagesToFetch().values()];
            chapters.reverse();
            this.populateChapterUrlsTable(chapters);
            this.parser.setPagesToFetch(chapters);
        } catch (err) {
            ErrorLog.showErrorMessage(err);
        }
    }

    /** 
    * @private
    */
    htmlToChapters(innerHtml) {
        let html = "<html><head><title></title><body>" + innerHtml + "</body></html>";
        let doc = util.sanitize(html);
        return [...doc.body.querySelectorAll("a")].map(a => util.hyperLinkToChapter(a));
    }

    /** 
    * @private
    */
    URLsToChapters(URLs) {
        let returnchapters = URLs.map(e => ({
            sourceUrl: e,
            title: "[placeholder]"
        }));
        return returnchapters;
    }

    /** @private */
    copyUrlsToClipboard() {
        let text = this.chaptersToHTML([...this.parser.getPagesToFetch().values()]);
        navigator.clipboard.writeText(text);
    }

    /** @private */
    toggleShowUrlsForChapterRanges() {
        let chapters = [...this.parser.getPagesToFetch().values()];
        this.toggleShowUrlsForChapterRange(ChapterUrlsUI.getRangeStartChapterSelect(), chapters);
        this.toggleShowUrlsForChapterRange(ChapterUrlsUI.getRangeEndChapterSelect(), chapters);
        this.showHideChapterUrlsColumn();
    }
    
    showHideChapterUrlsColumn() {
        let hidden = !document.getElementById("showChapterUrlsCheckbox").checked;
        let table = ChapterUrlsUI.getChapterUrlsTable();
        for (let t of table.querySelectorAll("th:nth-of-type(3), td:nth-of-type(3)")) {
            t.hidden = hidden;
        }
    }

    toggleShowUrlsForChapterRange(select, chapters) {
        
        select.onchange = null;
        let memberForTextOption = ChapterUrlsUI.textToShowInRange();
        for (let o of [...select.querySelectorAll("Option")]) {
            o.text = chapters[o.index][memberForTextOption];
        }
        let selectedIndex = select.selectedIndex;
        select.selectedIndex = selectedIndex;
        select.onchange = ChapterUrlsUI.onRangeChanged;
    }

    /** 
    * @private
    */
    setEditInputMode() {
        this.usingTable = false;
        ChapterUrlsUI.setVisibleUI(this.usingTable);
        let input = ChapterUrlsUI.getEditChaptersUrlsInput();
        input.rows = Math.max(this.parser.getPagesToFetch().size, 20);
        input.value = this.chaptersToHTML([...this.parser.getPagesToFetch().values()]);
    }

    chaptersToHTML(chapters) {
        let doc = util.sanitize("<html><head><title></title><body></body></html>");
        for (let chapter of chapters.filter(c => c.isIncludeable)) {
            doc.body.appendChild(this.makeLink(doc, chapter));
            doc.body.appendChild(doc.createTextNode("\r"));
        }
        return doc.body.innerHTML;
    }

    makeLink(doc, chapter) {
        let link = doc.createElement("a");
        link.href = chapter.sourceUrl;
        link.appendChild(doc.createTextNode(chapter.title));
        return link;
    }

    /** @private */
    static updateRange(startRowIndex, endRowIndex, state) {
        let direction = startRowIndex < endRowIndex ? 1 : -1;
        let linkTable = ChapterUrlsUI.getChapterUrlsTable();
        for (let rowIndex = startRowIndex; rowIndex != endRowIndex; rowIndex += direction) {
            let row = linkTable.rows[rowIndex];
            ChapterUrlsUI.setRowCheckboxState(row, state);
        }
    }

    /** @private */
    static getTargetRow(target) {
        while ((target.tagName.toLowerCase() !== "tr") && (target.parentElement !== null)) {
            target = target.parentElement;
        }
        return target;
    }

    /** @private */
    static tellUserAboutShiftClick(event, row) {
        let userPreferences = main.getUserPreferences();
        if (userPreferences?.disableShiftClickAlert?.value) {
            return;
        }
        if (event.shiftKey || (ChapterUrlsUI.lastSelectedRow === null)) {
            return;
        }
        if (ChapterUrlsUI.ConsecutiveRowClicks == 5) {
            return;
        }
        let distance = Math.abs(row.rowIndex - ChapterUrlsUI.lastSelectedRow);
        if (distance !== 1) {
            ChapterUrlsUI.ConsecutiveRowClicks = 0;
            return;
        }
        ++ChapterUrlsUI.ConsecutiveRowClicks;
        if (ChapterUrlsUI.ConsecutiveRowClicks == 5) {
            alert(UIText.Chapter.shiftClickMessage);
        }
    }

    static Filters = {
        filterTermsFrequency: {},
        chapterList: {},
        init() {
            let rc = new ChapterUrlsUI.RangeCalculator();
            var filterTermsFrequency = {};
            let constantTerms = false; // To become a collection of all terms used in every link.
            var chapterList = ChapterUrlsUI.getTableRowsWithChapters().filter(item => rc.rowInRange(item)).map(item => {
                let filterObj = 
                { 
                    row: item, 
                    values: Array.from(item.querySelectorAll("td")).map(item => item.innerText).join("/").split("/"),
                    valueString: ""
                };
                filterObj.values.push(item.querySelector("input[type='text']").value);
                filterObj.values = filterObj.values.filter(item => item.length > 3 && !item.startsWith("http"));
                filterObj.valueString = filterObj.values.join(" ");
                
                let recordFilterTerms = filterObj.valueString.toLowerCase().split(" ");
                recordFilterTerms.forEach(item => {
                    filterTermsFrequency[item] = (parseInt(filterTermsFrequency[item]) || 0) + 1;
                });

                if (!constantTerms)
                {
                    constantTerms = recordFilterTerms;
                }
                else
                {
                    constantTerms.filter(item => recordFilterTerms.indexOf(item) == -1).forEach(item =>{
                        constantTerms.splice(constantTerms.indexOf(item), 1);
                    });
                }

                return filterObj;
            });
            let minFilterTermCount = Math.min( 3, chapterList.length * 0.10 );
            filterTermsFrequency = Object.keys(filterTermsFrequency)
                .filter(key => constantTerms.indexOf(key) == -1 && filterTermsFrequency[key] > minFilterTermCount)
                .map(key => ({ key: key, value: filterTermsFrequency[key] } ));

            var calcValue = (filterTerm) => { return filterTerm.value * filterTerm.key.length; };

            this.filterTermsFrequency = filterTermsFrequency.sort((a, b) => {
                var hasHigherValue = calcValue(a) < calcValue(b);
                var hasEqualValue = calcValue(a) == calcValue(b);
                return hasHigherValue ? 1 : hasEqualValue ? 0 : -1;
            });
            this.chapterList = chapterList;
        },
        Filter() {
            let rc = new ChapterUrlsUI.RangeCalculator();
            let formResults = Object.fromEntries(new FormData(document.getElementById("sbFiltersForm")));
            let formKeys = Object.keys(formResults);
            formResults = formKeys.filter(key => key.indexOf("Hidden") == -1)
                .map(key => {
                    return {
                        key: key,
                        searchType: formResults[key],
                        value: formResults[`${key}Hidden`]
                    };
                });

            let includeChaps = null;
            let excludeChaps = null;
            if (formResults.filter(item => item.searchType == 1).length > 0)
            {
                includeChaps = new RegExp(formResults.filter(item => item.searchType == 1).map(item => item.value).join("|"), "i");
            }
            if (formResults.filter(item => item.searchType == -1).length > 0)
            {
                excludeChaps = new RegExp(formResults.filter(item => item.searchType == -1).map(item => item.value).join("|"), "i");
            }

            ChapterUrlsUI.Filters.chapterList.forEach(item =>{
                let showChapter = rc.rowInRange(item.row);
                if (includeChaps)
                {
                    showChapter = showChapter && includeChaps.test(item.valueString);
                }
                if (excludeChaps)
                {
                    showChapter = showChapter && !excludeChaps.test(item.valueString);
                }
                ChapterUrlsUI.setRowCheckboxState(item.row, showChapter);
                item.row.hidden = !showChapter;
            });
            document.getElementById("spanChapterCount").textContent = ChapterUrlsUI.Filters.chapterList.filter(item => !item.row.hidden).length;
        },
        generateFiltersTable() {
            let retVal = document.createElement("table");

            let onClickEvent = (event) => {
                if (event == undefined || event == null) {
                    return;
                }

                if (event.target.classList.contains("exclude"))
                {
                    event.target.checked = false;
                    event.target.classList.remove("exclude");
                    event.target.value = 1;
                }
                else if (!event.target.indeterminate && !event.target.checked)
                {
                    event.target.value = -1;
                    event.target.checked = true;
                    event.target.indeterminate = true;
                    event.target.classList.add("exclude");
                }

                ChapterUrlsUI.Filters.Filter();
            };

            let row = document.createElement("tr");
            let col = document.createElement("td");
            let checkboxId = "chkFilterText";
            let el = document.createElement("input");
            el.type = "checkbox";
            el.name = checkboxId;
            el.id = checkboxId;
            el.value = 1;
            el.onclick = onClickEvent;
            el.onchange = (event) => {
                if (event == undefined || event == null) {
                    return;
                }
                event.target.parentElement.nextElementSibling.firstChild.disabled = !event.target.checked;
                ChapterUrlsUI.Filters.Filter();
            };
            col.appendChild(el);
            row.appendChild(col);
            col = document.createElement("td");
            el = document.createElement("input");
            el.type = "text";
            el.disabled = true;
            el.id = checkboxId + "Text";
            el.onchange = (event) => { event.target.nextElementSibling.value = event.target.value; ChapterUrlsUI.Filters.Filter(); };
            col.appendChild(el);
            el = document.createElement("input");
            el.type = "hidden";
            el.id = checkboxId + "Hidden";
            el.name = checkboxId + "Hidden";
            col.appendChild(el);
            row.appendChild(col);

            retVal.appendChild(row);

            ChapterUrlsUI.Filters.filterTermsFrequency.forEach((value, id) => {
                row = document.createElement("tr");
                col = document.createElement("td");
                col.setAttribute("width", "10px");
                
                checkboxId = "chkFilter" + id;
                let el = document.createElement("input");
                el.type = "checkbox";
                el.name = checkboxId;
                el.id = checkboxId;
                el.value = 1;
                el.onclick = onClickEvent;
                col.appendChild(el);
                
                el = document.createElement("input");
                el.type = "hidden";
                el.name = checkboxId+"Hidden";
                el.value = RegExp.escape(value.key);
                col.appendChild(el);
                row.appendChild(col);

                col = document.createElement("td");
                el = document.createElement("label");
                el.innerText = value.key;
                el.id = checkboxId + "Label";
                el.setAttribute("for", checkboxId);
                el.setAttribute("width", "100%");
                col.appendChild(el);
                row.appendChild(col);

                retVal.appendChild(row);
            });
            retVal.setAttribute("width", "100%");
            return retVal;
        }
    };
}
ChapterUrlsUI.RangeCalculator = class {
    constructor()
    {
        this.startIndex = ChapterUrlsUI.selectionToRowIndex(ChapterUrlsUI.getRangeStartChapterSelect());
        this.endIndex = ChapterUrlsUI.selectionToRowIndex(ChapterUrlsUI.getRangeEndChapterSelect());
    }
    rowInRange(row) {
        let index = row.rowIndex;
        return (this.startIndex <= index) && (index <= this.endIndex);
    }
};

ChapterUrlsUI.DOWNLOAD_STATE_NONE = 0;
ChapterUrlsUI.DOWNLOAD_STATE_DOWNLOADING = 1;
ChapterUrlsUI.DOWNLOAD_STATE_LOADED = 2;
ChapterUrlsUI.DOWNLOAD_STATE_SLEEPING = 3;
ChapterUrlsUI.DOWNLOAD_STATE_PREVIOUS = 4;
ChapterUrlsUI.ImageForState = [
    "images/ChapterStateNone.svg",
    "images/ChapterStateDownloading.svg",
    "images/FileEarmarkCheckFill.svg",
    "images/ChapterStateSleeping.svg",
    "images/FileEarmarkCheck.svg"
];
ChapterUrlsUI.TooltipForSate = [
    null,
    UIText.Chapter.tooltipChapterDownloading,
    UIText.Chapter.tooltipChapterDownloaded,
    UIText.Chapter.tooltipChapterSleeping,
    UIText.Chapter.tooltipChapterPreviouslyDownloaded
];

ChapterUrlsUI.lastSelectedRow = null;
ChapterUrlsUI.ConsecutiveRowClicks = 0;

================================================
FILE: plugin/js/ContentScript.js
================================================

/*
  Javascript that is injected into active tab.
  Returns the DOM of the window's contents
*/
"use strict";

var parseResults = {
    messageType: "ParseResults",
    document: document.all[0].outerHTML,
    url: document.URL
};
chrome.runtime.sendMessage(parseResults);

================================================
FILE: plugin/js/CoverImageUI.js
================================================

"use strict";

/** Class that handles UI for selecting cover image */
class CoverImageUI { // eslint-disable-line no-unused-vars
    constructor() {
    }

    static getImageTableElement() {
        return document.getElementById("imagesTable");
    }

    /** return URL of image to use for cover, or NULL if no cover
    */
    static getCoverImageUrl() {
        let url = CoverImageUI.getCoverImageUrlInput().value;
        return util.isNullOrEmpty(url) ? null : url;
    }

    /** toggle visibility of the Cover Image URL input control
     * @param {bool} visible - show/hide control
    */
    static showCoverImageUrlInput(visible) {
        document.getElementById("coverUrlSection").hidden = !visible;
        document.getElementById("imagesTableDiv").hidden = visible;
    }

    /** clear all UI elements associated with selecting the Cover Image */
    static clearUI() {
        CoverImageUI.clearImageTable();
        CoverImageUI.setCoverImageUrl("");
    }

    /** remove all images from the table of images to pick from */
    static clearImageTable() {
        let imagesTable = CoverImageUI.getImageTableElement();
        while (imagesTable.children.length > 0) {
            imagesTable.removeChild(imagesTable.children[imagesTable.children.length - 1]);
        }
    }

    /** create table of images for user to pick from 
    * @param {array of ImageInfo} images to populate table with
    */
    static populateImageTable(images) {
        CoverImageUI.clearImageTable();
        let imagesTable = CoverImageUI.getImageTableElement();
        let checkBoxIndex = 0;
        if (0 === images.length) {
            imagesTable.parentElement.appendChild(document.createTextNode(UIText.CoverImage.noImagesFoundLabel));
        }
        else {
            images.forEach((imageInfo) => {
                let row = document.createElement("tr");
        
                // add checkbox
                let checkbox = CoverImageUI.createCheckBoxAndLabel(imageInfo.sourceUrl, checkBoxIndex);
                CoverImageUI.appendColumnToRow(row, checkbox);

                // add image
                let img = document.createElement("img");
                img.setAttribute("style", "max-height: 120px; width: auto; ");
                img.src = imageInfo.sourceUrl;
                CoverImageUI.appendColumnToRow(row, img);
                imagesTable.appendChild(row);

                ++checkBoxIndex;
            });
        }
    }

    /** adds row to the images table 
    * @private
    */
    static createCheckBoxAndLabel(sourceUrl, checkBoxIndex) {
        let label = document.createElement("label");
        let checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = "setCoverCheckBox" + checkBoxIndex;
        checkbox.onclick = () => { CoverImageUI.onImageClicked(checkbox.id, sourceUrl); };
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(UIText.CoverImage.setCover));

        // default to first image as cover image
        if (checkBoxIndex === 0) {
            CoverImageUI.setCoverImageUrl(sourceUrl);
            checkbox.checked = true;
        }
        return label;
    }

    /** user has selected/unselected an image for cover
    * @private
    */
    static onImageClicked(checkboxId, sourceUrl) {
        let checkbox = document.getElementById(checkboxId);
        if (checkbox.checked === true) {
            CoverImageUI.setCoverImageUrl(sourceUrl);

            // uncheck any other checked boxes
            let imagesTable = CoverImageUI.getImageTableElement();
            for (let box of imagesTable.querySelectorAll("input")) {
                if (box.id !== checkboxId) {
                    box.checked = false;
                }
            }
        } else {
            CoverImageUI.setCoverImageUrl(null);
        }
    } 

    /**
    * @private
    */
    static appendColumnToRow(row, element) {
        let col = document.createElement("td");
        col.appendChild(element);
        col.style.whiteSpace = "nowrap";
        row.appendChild(col);
        return col;
    }

    /**
    * @private
    * @todo  this should be moved to Baka-Tsuki, this logic is specific to B-T
    */
    static onCoverFromUrlClick(enable, images) {
        if (enable) {
            CoverImageUI.setCoverImageUrl(null);
            CoverImageUI.clearImageTable();
            CoverImageUI.showCoverImageUrlInput(true);
        } else {
            CoverImageUI.showCoverImageUrlInput(false);
            CoverImageUI.populateImageTable(images);
        }
    }

    /** user has selected/unselected an image for cover
    * @private
    */
    static getCoverImageUrlInput() {
        return document.getElementById("coverImageUrlInput");
    }

    /** @private */
    static getSampleCoverImg() {
        return document.getElementById("sampleCoverImg");
    }

    /** set URL of image to use for cover, or NULL if no cover
    * @public
    */
    static setCoverImageUrl(url) {
        let inputUrl = CoverImageUI.getCoverImageUrlInput();
        if (inputUrl.onchange == null) {
            inputUrl.onchange = CoverImageUI.showSampleImg;
        }
        inputUrl.value = url;
        CoverImageUI.getSampleCoverImg().src = url;
    }

    /** @private */
    static showSampleImg() {
        let url = CoverImageUI.getCoverImageUrlInput().value;
        let sampleImg = CoverImageUI.getSampleCoverImg();
        sampleImg.src = url;
    }
}

================================================
FILE: plugin/js/DebugUtil.js
================================================

"use strict";

/** Functions to help debugging.  Not included in release product */
class DebugUtil { // eslint-disable-line no-unused-vars
    constructor() {
    }

    static byteToHex(e) {
        let temp = "0" + e.toString(16);
        return temp.substring(temp.length - 2);
    }

    static bufToHex(buf) {
        return new Uint8Array(buf)
            .reduce((p, c) => p + DebugUtil.byteToHex(c), "");
    }
}

================================================
FILE: plugin/js/DefaultParserUI.js
================================================

"use strict";

/** Keep track of how to user tells us to parse different sites */
class DefaultParserSiteSettings {
    constructor() {
        this.loadSiteConfigs();
    }

    /** @private */
    loadSiteConfigs() {
        let config = window.localStorage.getItem(DefaultParserSiteSettings.storageName);
        this.configs = new Map();
        if (config != null) {
            for (let e of JSON.parse(config)) {
                let selectors = e[1];
                if (DefaultParserSiteSettings.isConfigValid(selectors)) {
                    this.configs.set(e[0], selectors);
                }
            }
        }
    }

    static isConfigValid(selectors) {
        return (selectors.contentCss !== undefined)
            && !util.isNullOrEmpty(selectors.contentCss);
    }

    saveSiteConfig(hostname, contentCss, titleCss, removeCss, testUrl) {
        if (this.isConfigChanged(hostname, contentCss, titleCss, removeCss, testUrl)) {
            this.configs.set(
                hostname, { 
                    contentCss: contentCss, 
                    titleCss: titleCss, 
                    removeCss: removeCss,
                    testUrl: testUrl 
                }
            );
            let serialized = JSON.stringify(Array.from(this.configs.entries()));
            window.localStorage.setItem(DefaultParserSiteSettings.storageName, serialized);
        }
    }

    /** @private */
    isConfigChanged(hostname, contentCss, titleCss, removeCss, testUrl) {
        let config = this.configs.get(hostname);
        return (config === undefined) || 
            (contentCss !== config.contentCss) ||
            (titleCss !== config.titleCss) || 
            (removeCss !== config.removeCss) ||
            (testUrl !== config.testUrl);
    }

    getConfigForSite(hostname) {
        return this.configs.get(hostname);
    }

    constructFindContentLogicForSite(hostname) {
        let logic = {
            findContent: dom => dom.querySelector("body"),
            findChapterTitle: () => null,
            removeUnwanted: () => null
        };
        let config = this.getConfigForSite(hostname);
        if (config != null) {
            logic.findContent = dom => dom.querySelector(config.contentCss);
            if (!util.isNullOrEmpty(config.titleCss))
            {
                logic.findChapterTitle = dom => dom.querySelector(config.titleCss);
            }
            if (!util.isNullOrEmpty(config.removeCss))
            {
                logic.removeUnwanted = (element) => {
                    for (let e of element.querySelectorAll(config.removeCss)) {
                        e.remove();
                    }
                };
            }
        }
        return logic;
    }
}
DefaultParserSiteSettings.storageName = "DefaultParserConfigs";

/** Class that handles UI for configuring the Default Parser */
class DefaultParserUI { // eslint-disable-line no-unused-vars
    constructor() {
    }

    static setupDefaultParserUI(hostname, parser) {
        DefaultParserUI.copyInstructions();
        DefaultParserUI.setDefaultParserUiVisibility(true);
        DefaultParserUI.populateDefaultParserUI(hostname, parser);
        document.getElementById("testDefaultParserButton").onclick = DefaultParserUI.testDefaultParser.bind(null, parser);
        document.getElementById("finisheddefaultParserButton").onclick = DefaultParserUI.onFinishedClicked.bind(null, parser);
    }

    static onFinishedClicked(parser) {
        DefaultParserUI.AddConfiguration(parser);
        DefaultParserUI.setDefaultParserUiVisibility(false);
    }

    static AddConfiguration(parser) {
        let hostname = DefaultParserUI.getDefaultParserHostnameInput().value;
        let contentCss = DefaultParserUI.getContentCssInput().value;
        let titleCss = DefaultParserUI.getChapterTitleCssInput().value;
        let removeCss = DefaultParserUI.getUnwantedElementsCssInput().value.trim();
        let testUrl = DefaultParserUI.getTestChapterUrlInput().value.trim();

        parser.siteConfigs.saveSiteConfig(hostname, contentCss, titleCss, removeCss, testUrl);
    }

    static populateDefaultParserUI(hostname, parser) {
        DefaultParserUI.getDefaultParserHostnameInput().value = hostname;

        DefaultParserUI.getContentCssInput().value = "body";
        DefaultParserUI.getChapterTitleCssInput().value = "";
        DefaultParserUI.getUnwantedElementsCssInput().value = "";
        DefaultParserUI.getTestChapterUrlInput().value = "";

        let config = parser.siteConfigs.getConfigForSite(hostname);
        if (config != null) {
            DefaultParserUI.getContentCssInput().value = config.contentCss;
            DefaultParserUI.getChapterTitleCssInput().value = config.titleCss;
            DefaultParserUI.getUnwantedElementsCssInput().value = config.removeCss;
            DefaultParserUI.getTestChapterUrlInput().value = config.testUrl;
        }
    }

    static setDefaultParserUiVisibility(isVisible) {
        // toggle mode
        ChapterUrlsUI.setVisibleUI(!isVisible);
        if (isVisible) {
            ChapterUrlsUI.getEditChaptersUrlsInput().hidden = true;
            ChapterUrlsUI.modifyApplyChangesButtons(button => button.hidden = true);
            document.getElementById("editURLsHint").hidden = true;
        }
        document.getElementById("defaultParserSection").hidden = !isVisible;
    }

    static async testDefaultParser(parser) {
        DefaultParserUI.AddConfiguration(parser);
        let hostname = DefaultParserUI.getDefaultParserHostnameInput().value;
        let config = parser.siteConfigs.getConfigForSite(hostname);
        if (util.isNullOrEmpty(config.testUrl))
        {
            alert(UIText.Warning.warningNoChapterUrl);
            return;
        }
        try {
            let xhr = await HttpClient.wrapFetch(config.testUrl);
            let webPage = { rawDom: util.sanitize(xhr.responseXML.querySelector("*")) };
            let content = parser.findContent(webPage.rawDom);
            if (content === null) {
                let errorMsg = UIText.Error.errorContentNotFound(config.testUrl);
                throw new Error(errorMsg);
            }
            parser.removeUnwantedElementsFromContentElement(content);
            parser.addTitleToContent(webPage, content);
            DefaultParserUI.showResult(content);
        } catch (err) {
            ErrorLog.showErrorMessage(err);
        }
    }

    static cleanResults() {
        let resultElement = DefaultParserUI.getResultViewElement();
        let children = resultElement.childNodes;
        while (0 < children.length) {
            children[children.length - 1].remove();
        }
    }

    static copyInstructions() {
        let content = document.getElementById("defaultParserInstructions");
        DefaultParserUI.showResult(content);
    }

    static showResult(content) {
        DefaultParserUI.cleanResults();
        if (content != null) {
            let resultElement = DefaultParserUI.getResultViewElement();
            util.moveChildElements(content, resultElement);
        }
    }

    static getDefaultParserHostnameInput() {
        return document.getElementById("defaultParserHostName");
    }

    static getContentCssInput() {
        return document.getElementById("defaultParserContentCss");
    }

    static getChapterTitleCssInput() {
        return document.getElementById("defaultParserChapterTitleCss");
    }

    static getUnwantedElementsCssInput() {
        return document.getElementById("defaultParserUnwantedElementsCss");
    }

    static getTestChapterUrlInput() {
        return document.getElementById("defaultParserTestChapterUrl");
    }

    static getResultViewElement() {
        return document.getElementById("defaultParserVewResult");
    }
}

================================================
FILE: plugin/js/Download.js
================================================

"use strict";

class Download {
    constructor() {
    }

    static init() {
        Download.saveOn = util.isFirefox() ? Download.saveOnFirefox : Download.saveOnChrome;
        if (util.isFirefox()) {
            Download.saveOn = Download.saveOnFirefox;
            browser.downloads.onChanged.addListener(Download.onChanged);
        } else {
            Download.saveOn = Download.saveOnChrome;
            chrome.downloads.onChanged.addListener(Download.onChanged);
        }
    }

    static isFileNameIllegalOnWindows(fileName) {
        for (let c of Download.illegalWindowsFileNameChars) {
            if (fileName.includes(c)) {
                return true;
            }
        }
        if (fileName.trim() == "") {
            return true;
        }
        return false;
    }

    static CustomFilename() {
        let CustomFilename = document.getElementById("CustomFilenameInput").value;
        let ToReplace = {
            "%URL_hostname%": (new URL(document.getElementById("startingUrlInput").value))?.hostname,
            "%Title%": document.getElementById("titleInput").value,
            "%Author%": document.getElementById("authorInput").value,
            "%Language%": document.getElementById("languageInput").value,
            "%Chapters_Count%":  document.getElementById("spanChapterCount").innerHTML,
            "%Chapters_Downloaded%":  document.getElementById("fetchProgress").value-1,
            "%Filename%": document.getElementById("fileNameInput").value,
        };
        for (const [key, value] of Object.entries(ToReplace)) {
            CustomFilename = CustomFilename.replaceAll(key, value);
        }
        if (Download.isFileNameIllegalOnWindows(CustomFilename)) {
            ErrorLog.showErrorMessage(UIText.Error.errorIllegalFileName(CustomFilename, Download.illegalWindowsFileNameChars));
            return EpubPacker.addExtensionIfMissing("IllegalFileName");
        }
        return EpubPacker.addExtensionIfMissing(CustomFilename);
    }

    /** write blob to "Downloads" directory */
    static save(blob, fileName, overwriteExisting, backgroundDownload) {
        let options = {
            url: URL.createObjectURL(blob),
            filename: fileName,
            saveAs: !backgroundDownload
        };
        if (overwriteExisting) {
            options.conflictAction = "overwrite";
        }
        let cleanup = () => { URL.revokeObjectURL(options.url); };
        return Download.saveOn(options, cleanup);
    }

    static saveOnChrome(options, cleanup) {
        // on Chrome call to download() will resolve when "Save As" dialog OPENS
        // so need to delay return until after file is actually saved
        // Otherwise, we get multiple Save As Dialogs open.
        return new Promise((resolve,reject) => {
            chrome.downloads.download(options, 
                downloadId => Download.downloadCallback(downloadId, cleanup, resolve, reject)
            );
        });
    }

    static downloadCallback(downloadId, cleanup, resolve, reject) {
        if (downloadId === undefined) {
            reject(new Error(chrome.runtime.lastError.message));
        } else {
            Download.onDownloadStarted(downloadId, 
                () => { 
                    const tenSeconds = 10 * 1000;
                    setTimeout(cleanup, tenSeconds);
                    resolve();
                }
            );
        }
    }

    static saveOnFirefox(options, cleanup) {
        return browser.runtime.getPlatformInfo().then(platformInfo => {
            if (Download.isAndroid(platformInfo)) {
                Download.saveOnFirefoxForAndroid(options, cleanup);
            } else {
                return browser.downloads.download(options).then(
                    // on Firefox, resolves when "Save As" dialog CLOSES, so no
                    // need to delay past this point.
                    downloadId => Download.onDownloadStarted(downloadId, cleanup)
                );
            }
        }).catch(cleanup);
    }

    static saveOnFirefoxForAndroid(options, cleanup) {
        options.saveAs = false;

        // `browser.downloads.download` isn't implemented in
        // "Firefox for Android" yet, so we starts downloads
        // the same way any normal web page would do it:
        const link = document.createElement("a");
        link.style.display = "hidden";

        link.href = options.url;
        link.download = options.filename;

        document.body.appendChild(link);
        try {
            link.click();
        } finally {
            document.body.removeChild(link);
        }
        cleanup();
    }

    static isAndroid(platformInfo) {
        return platformInfo.os.toLowerCase().includes("android");
    }

    static onChanged(delta) {
        if ((delta.state != null) && (delta.state.current === "complete")) {
            let action = Download.toCleanup.get(delta.id);
            if (action != null) {
                Download.toCleanup.delete(delta.id);
                action();
            }
        }
    }

    static onDownloadStarted(downloadId, action) {
        if (downloadId === undefined) {
            action();
        } else {
            Download.toCleanup.set(downloadId, action);
        }
    }
}

Download.toCleanup = new Map();
Download.illegalWindowsFileNameChars = "~/?<>\\:*|\"";
Download.init();

================================================
FILE: plugin/js/EpubItem.js
================================================

/*
  An item (file) that will go into an EPUB
  It has the following properties
      type:  XHTML or image
      sourceUrl: where the html came from
      id:  the id value in the content.opf file

      optional members:
      nodes:  list of nodes that make up the content (if it's XHTML content)
*/
"use strict";

class EpubItem {
    constructor(sourceUrl) {
        this.sourceUrl = sourceUrl;
        this.isInSpine = true;
        this.chapterTitle = null;
    }

    setIndex(index) {
        this.index = index;
    }

    // name of the item in the zip.
    getZipHref() {
        return util.makeStorageFileName("OEBPS/Text/", this.index, this.chapterTitle, "xhtml");
    }

    getId() {
        return "xhtml" + util.zeroPad(this.index);
    }

    getMediaType() {
        return "application/xhtml+xml";
    }

    hasSvg() {
        if (this.nodes != null) {
            for (let n of this.nodes) {
                if ((n.nodeType === Node.ELEMENT_NODE) &&
                    (n.querySelector("svg") !== null)) {
                    return true;
                }
            }
        }
        return false;
    }

    fileContentForEpub(emptyDocFactory, contentValidator) {
        let xml = util.xmlToString(this.makeChapterDoc(emptyDocFactory));
        let errorMessage = contentValidator(xml);
        if (errorMessage) {
            let errorMsg = UIText.Error.convertToXhtmlWarning(this.chapterTitle, this.sourceUrl, errorMessage);
            ErrorLog.log(errorMsg);
        }
        return xml;
    }

    packInEpub(zipWriter, emptyDocFactory, contentValidator) {
        let content = this.fileContentForEpub(emptyDocFactory, contentValidator);
        zipWriter.add(this.getZipHref(), new zip.TextReader(content));
    }

    makeChapterDoc(emptyDocFactory) {
        let doc = emptyDocFactory();
        let body = doc.getElementsByTagName("body")[0];
        for (let node of this.nodes) {
            let clean = util.sanitizeNode(node);
            if (clean) {
                body.appendChild(clean);
            }
        }
        this.populateTitle(doc, body);
        delete(this.nodes);
        return doc;
    }

    populateTitle(doc, body) {
        let title = doc.querySelector("title");
        let h1 = body.querySelector("h1");
        if (util.isNullOrEmpty(title.textContent) && (h1 !== null)) {
            title.textContent = h1.textContent;
        }
    }

    // convert type of heading element to nesting depth on Table of Contents
    // H1 = 0, H2 = 1, etc
    tagNameToTocDepth(tagName) {
        // ToDo: assert that tagName in range <h1> ... <h4>
        return tagName[1] - "1";
    }

    *chapterInfo() {
        for (let element of this.nodes) {
            if (util.isHeaderTag(element)) {
                yield {
                    depth: this.tagNameToTocDepth(element.tagName),
                    title: element.textContent,
                    src: this.getZipHref()
                };
            }
        }
    }

    getHyperlinks() {
        let links = [];
        for (let element of this.nodes) {
            if (element.nodeType === Node.ELEMENT_NODE) {
                if (element.tagName.toLowerCase() === "a") {
                    links.push(element);
                }
                for (let link of element.querySelectorAll("a")) {
                    links.push(link);
                }
            }
        }
        return links;
    }
}

//==============================================================
// Construct an Epub item from source where each chapter
// was a separate HTML file.
class ChapterEpubItem extends EpubItem { // eslint-disable-line no-unused-vars
    constructor(chapter, content, index) {
        super(chapter.sourceUrl);
        super.setIndex(index);
        this.nodes = Array.from(content.childNodes);
        this.chapterTitle = chapter.title;
        this.newArc = chapter.newArc;
    }

    *chapterInfo() {
        let isStartOfNewArc = ((this.newArc !== null) && (this.newArc !== undefined));
        if (isStartOfNewArc) {
            yield {
                depth: 0,
                title: this.newArc,
                src: this.getZipHref()
            };
        }

        if (typeof (this.chapterTitle) !== "undefined") {
            yield {
                depth: 1,
                title: this.chapterTitle,
                src: this.getZipHref()
            };
        }
    }
}

//==============================================================
/*
    Details of an image in BakaTsuki web page
    wrappingUrl :  URL of <a> tag that wraps the <img> (For Baka-Tsuki, is a web page that holds list of versions of the image)
    sourceUrl : URL of actual image  (initially, image on page)
    mediaType: jpeg, png, etc.
    arrayBuffer: the image bytes
    isCover :  use this as the cover image?
    height: "full size" image height
    width: "full size" image width
*/
class ImageInfo extends EpubItem { // eslint-disable-line no-unused-vars
    constructor(wrappingUrl, index, sourceUrl, dataOrigFileUrl) {
        super(sourceUrl);
        super.index = index;
        super.isInSpine = false;
        this.wrappingUrl = wrappingUrl;
        this.mediaType = "image/jpeg";
        this.isCover = false;
        this.isOutsideGallery = false;
        this.arraybuffer = null;
        this.height = null;
        this.width = null;
        this.dataOrigFileUrl = dataOrigFileUrl;
        this.queuedForFetch = false;
    }

    getZipHref() {
        let suffix = util.getDefaultExtensionByMime(this.mediaType) || this.findImageSuffix(this.wrappingUrl);
        return util.makeStorageFileName("OEBPS/Images/", this.index, this.getImageName(this.wrappingUrl), suffix);
    }

    getBase64(maxLength) {
        var binary = "";
        var bytes = new Uint8Array(this.arraybuffer);
        var len = bytes.byteLength;
        if (maxLength > 0) len = Math.min(len, maxLength);
        for (var i = 0; i < len; i++)
        {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa( binary );
    }

    getId() {
        if (this.isCover) {
            return "cover-image";
        } else {
            return "image" + util.zeroPad(this.index);
        }
    }

    getMediaType() {
        return this.mediaType;
    }

    packInEpub(zipWriter) {
        zipWriter.add(this.getZipHref(),
            new zip.BlobReader(new Blob([this.arraybuffer])));
    }

    findImageSuffix(wrappingUrl) {
        let suffix = "";
        let fileName = this.extractImageFileNameFromUrl(wrappingUrl);
        if (fileName != null) {
            let index = fileName.lastIndexOf(".");
            suffix = fileName.substring(index + 1);
        }

        // if can't find suffix from file, use the media type
        if (fileName == null) {
            let split = this.mediaType.split("/");
            suffix = split[split.length - 1];

            // special case
            if (suffix === "svg+xml") {
                suffix = "svg";
            }
        }
        return suffix;
    }

    // assume image URL looks like one one of the following
    // https://www.baka-tsuki.org/project/index.php?title=File:HSDxD_v01_cover.jpg
    // https://www.baka-tsuki.org/project/thumb.php?f=HSDxD_v01_cover.gif&width=427
    // https://www.baka-tsuki.org/project/images/7/76/HSDxD_v01_cover.jpg

    // http://sonako.wikia.com/wiki/File:Date4_000c.png
    // http://vignette2.wikia.nocookie.net/sonako/images/d/db/Date4_000c.png/revision/latest?cb=20140821053052
    // http://vignette2.wikia.nocookie.net/sonako/images/d/db/Date4_000c.png/revision/latest/scale-to-width-down/332?cb=20140821053052
    extractImageFileNameFromUrl(url) {
        let parsedUrl = null;
        try {
            parsedUrl = new URL(url);
        } catch (err) {
            return undefined;
        }

        // examine pathname and query
        let temp = parsedUrl.pathname + parsedUrl.search;
        let fileNames = temp.split(/=|&|:|\/|\?/).filter(s => this.isImageFileNameCandidate(s));
        if (0 < fileNames.length) {
            return fileNames[fileNames.length - 1];
        }
    
        // if get here, nothing found
        return undefined;
    }

    // Crude. If string has '.' and is not a .php or .html, 
    // and there's at least 3 characters after the '.'
    // assume it's an image filename
    isImageFileNameCandidate(candidate) {
        let lowerString = candidate.toLowerCase();
        return (4 < lowerString.length) &&
            (lowerString.indexOf(".") !== -1) &&
            (lowerString.indexOf(".html") === -1) &&
            (lowerString.indexOf(".php") === -1) &&
            (4 <= (lowerString.length - lowerString.lastIndexOf(".")));
    }

    getImageName(page) {
        if (page) {
            let name = this.extractImageFileNameFromUrl(page);
            if (name) {
                return name.split(/\./gi)[0];
            }
        }
        // This is actually wise to do now.
        return undefined;
    }

    createImageElement(userPreferences) {
        if (this.isSvgImageUsedHere(userPreferences)) {
            return util.createSvgImageElement(this.getZipHref(), this.width, this.height, 
                this.wrappingUrl, userPreferences.includeImageSourceUrl.value);
        } else {
            return this.createImgImageElement("div");
        }
    }

    isSvgImageUsedHere(userPreferences) {
        const MIN_SVG_IMAGE_DIMENSION = 300;
        return userPreferences.useSvgForImages.value &&
            MIN_SVG_IMAGE_DIMENSION <= this.width &&
            MIN_SVG_IMAGE_DIMENSION <= this.height;
    }

    createImgImageElement(wrappingTag) {
        let src = this.getZipHref();
        let origin = this.wrappingUrl;
        let doc = util.createEmptyXhtmlDoc();
        let body = doc.getElementsByTagName("body")[0];
        let wrapper = doc.createElementNS(util.XMLNS, wrappingTag);
        body.appendChild(wrapper);
        let img = doc.createElementNS(util.XMLNS,"img");
        if (wrappingTag === "span") {
            img.className = "inline";
        }
        img.src = util.makeRelative(src);
        img.alt = "";
        wrapper.appendChild(img);
        wrapper.appendChild(util.createComment(doc, origin));
        return wrapper;
    }

    *chapterInfo() {
        // images do not appear in table of contents
    }
}

class FontInfo extends ImageInfo {
    constructor(fontName) {
        super();
        this.fontName = fontName;
    }

    packInEpub(zipWriter) {
        zipWriter.add("OEBPS/Fonts/"+this.fontName,
            new zip.BlobReader(new Blob([this.arraybuffer])));
    }
}

================================================
FILE: plugin/js/EpubItemSupplier.js
================================================

/*
    Provides information (and files) that will be packed into an EpubPacker.
    This implementation is where source Baka-Tsuki.
*/

"use strict";

class EpubItemSupplier { // eslint-disable-line no-unused-vars
    constructor(parser, epubItems, imageCollector) {
        this.parser = parser;
        this.epubItems = [];
        this.coverImageInfo = imageCollector.coverImageInfo;
        this.imageCollector = imageCollector;
        imageCollector.imagesToPackInEpub().forEach(image => this.epubItems.push(image));
        epubItems.forEach(item => this.epubItems.push(item));
        this.coverImageId = () => this.coverImageInfo.getId();
    }

    // used to populate manifest
    manifestItems() {
        return this.epubItems;
    }

    // used to populate spine
    spineItems() {
        return this.epubItems.filter(item => item.isInSpine);
    }

    // used to populate Zip file itself
    files() {
        return this.epubItems;
    }

    // used to populate table of contents
    *chapterInfo() {
        for (let epubItem of this.epubItems) {
            yield* epubItem.chapterInfo();
        }
    }

    makeCoverImageXhtmlFile(emptyDocFactory, title) {
        let doc = emptyDocFactory();
        let body = doc.getElementsByTagName("body")[0];
        let userPreferences = this.imageCollector.userPreferences;
        body.appendChild(this.coverImageInfo.createImageElement(userPreferences));

        if (title) {
            doc.querySelector("title").text = title;
        }

        return util.xmlToString(doc);
    }

    hasCoverImageFile() {
        return (this.coverImageInfo != null);
    }
}

================================================
FILE: plugin/js/EpubMetaInfo.js
================================================

/*
    Wrapper for EPUB information
*/

"use strict";

/*
    Any EPUB we create should have following info
    <param name="uuid" type="string">identifier for this EPUB.  (i.e. "origin" URL story was downloaded from)</param>
    <param name="title" type="string">The Title of the story</param>
    <param name="author" type="string">The writer of the story</param>
    <param name="language" type="string">Language code of story. Defaults to "en" (English)</param>
    <param name="seriesName" type="string">If book is part of series, has name of series.  null if not part of a series</param>
    <param name="seriesIndex" type="string">If book is part of series, has index of book in series.  null if not part of a series</param>
*/
class EpubMetaInfo {
    constructor() {
        this.uuid = UIText.Default.uuid;
        this.title = UIText.Default.title;
        this.author = UIText.Default.author;

        this.language = "en";
        this.fileName = "web.epub";
        this.subject = "";
        this.description = "";
        this.seriesName = null;
        this.seriesIndex = null;
        this.styleSheet = EpubMetaInfo.getDefaultStyleSheet();
        this.translator = null;
        this.fileAuthorAs = null;
    }

    getFileAuthorAs() {
        return (this.fileAuthorAs === null) ? this.author : this.fileAuthorAs;
    }

    static getDefaultStyleSheet() {
        return ""+
        // Style for svg images. I got this from BTE-Gen epunbs. Works nicely.
        "div.svg_outer {\r"+
        "   display: block;\r"+
        "   margin-bottom: 0;\r"+
        "   margin-left: 0;\r"+
        "   margin-right: 0;\r"+
        "   margin-top: 0;\r"+
        "   padding-bottom: 0;\r"+
        "   padding-left: 0;\r"+
        "   padding-right: 0;\r"+
        "   padding-top: 0;\r"+
        "   text-align: left;\r"+
        "}\r"+
        "div.svg_inner {\r"+
        "   display: block;\r"+
        "   text-align: center;\r"+
        "}\r"+

        // Centered headings and some margin to make sure it's not too close to the content.
        "h1, h2 {\r"+
        "   text-align: center;\r"+
        "   margin-bottom: 10%;\r"+
        "   margin-top: 10%;\r"+
        "}\r"+
        "h3, h4, h5, h6 {\r"+
        "   text-align: center;\r"+
        "   margin-bottom: 15%;\r"+
        "   margin-top: 10%;\r"+
        "}\r"+

        // Style for lists. Calibre sometimes has issues with the placement of lists, this fixes it.
        "ol, ul {\r"+
        "   padding-left: 8%;\r"+
        "}\r"+

        "body {\r"+
        "  margin: 2%;\r"+
        "}\r"+

        //Breaks extremely long words, screams, wails etc to fit viewer window.
        "p {\r"+
        "  overflow-wrap: break-word;\r"+
        "}\r"+

        // Prevent texts inside mutliple definition list tags going outside viewer window.
        // Example https://www.baka-tsuki.org/project/index.php?title=The_Unexplored_Summon_Blood_Sign:Volume2_Opening2
        // It looks okay in a browser but in devices with small screen, it's almost unreadable.
        "dd, dt, dl {\r"+
        "  padding: 0;\r"+
        "  margin: 0;\r"+
        "}\r"+

        "img {\r"+
        "   display: block;\r"+
        "   min-height: 1em;\r"+
        "   max-height: 100%;\r"+
        "   max-width: 100%;\r"+
        "   padding-bottom: 0;\r"+
        "   padding-left: 0;\r"+
        "   padding-right: 0;\r"+
        "   padding-top: 0;\r"+
        "   margin-left: auto;\r"+
        "   margin-right: auto;\r"+
        "   margin-bottom: 2%;\r"+
        "   margin-top: 2%;\r"+
        "}\r"+

        // images embedded in sentances (e.g. Emoji)
        "img.inline {\r"+
        "   display: inline;\r"+
        "   min-height: 1em;\r"+
        "   margin-bottom: 0;\r"+
        "   margin-top: 0;\r"+
        "}\r"+

        // differentiate caption text from body text 
       ".thumbcaption {\r"+
       "  display: block;\r"+
       "  font-size: 0.9em;\r"+
       "  padding-right: 5%;\r"+
       "  padding-left: 5%;\r"+
       "}\r"+
       
        // To make hr tags more visible. BT doesn't use them very often but other sites might.
        "hr {\r"+
        "   color: black;\r"+
        "   background-color: black;\r"+
        "   height: 2px;\r"+
        "}\r"+

        // Styling all links.
        "a:link {\r"+
        "   text-decoration: none;\r"+
        "   color: #0B0080;\r"+
        "}\r"+
        "a:visited {\r"+
        "   text-decoration: none;\r"+
        "}\r"+
        "a:hover {\r"+
        "   text-decoration: underline;\r"+
        "}\r"+
        "a:active {\r"+
        "   text-decoration: underline;\r"+
        "}"+

        "table {\r"+
        "   width: 90%;\r"+
        "   border-collapse: collapse;\r"+
        "}\r"+
        "table, th, td {\r"+
        "   border: 1px solid black;\r"+
        "}\r"+

        // Box around author notes
        ".webToEpub-author-note {\r" +
        "    border: 1px solid black; padding: 0.5em\r" +
        "}";
    }

    static getEpubMetaAddInfo(dom, url, allTags) {
        let metaAddInfo = new EpubAddMetaInfo();

        //novelupdates
        if (url.includes("novelupdates.com") == true) {
            metaAddInfo.subject = EpubMetaInfo.addSubjectNovelupdate(dom, allTags);
            metaAddInfo.description = EpubMetaInfo.addDescriptionNovelupdate(dom);
            metaAddInfo.author = EpubMetaInfo.addAuthorNovelupdate(dom);
        } else {
            let test = "Error: Fetch of URL '" + url + "' failed to fetch please check if website is novelupdates.com";
            ErrorLog.showErrorMessage(test);
        }
        return metaAddInfo;
    }
    
    static addSubjectNovelupdate(dom, allTags) {
        let selector = "#seriesgenre .genre";
        if (allTags) {
            selector += ", #showtags .genre";
        }
        return EpubMetaInfo.buildSubjectFromTags(dom, selector);
    }

    static addDescriptionNovelupdate(dom) {
        return dom.querySelector("#editdescription").textContent.replace(/\n+/g, "\n").replace(/\n/g, "\n\n");
    }
    
    static addAuthorNovelupdate(dom) {
        return dom.querySelector("#authtag").textContent;
    }

    static buildSubjectFromTags(dom, selector) {
        return [...dom.querySelectorAll(selector)]
            .map(e => EpubMetaInfo.decensor(e.textContent.trim()))
            .join(", ");
    }

    static decensor(tag) {
        if (tag.includes("*")) {
            for (let j = 0; j < EpubMetaInfo.decensorList.length; j += 2) {
                let cyphertext = EpubMetaInfo.decensorList[j];
                let cleartext = EpubMetaInfo.decensorList[j + 1];
                if (tag.includes(cyphertext)) {
                    tag = tag.replace(cyphertext, cleartext);
                }
            }
        }
        return tag;
    }
}

EpubMetaInfo.decensorList = [
    "Ab*se", "Abuse",
    "An*l", "Anal",
    "B*tch", "Bitch",
    "C*astity", "Chastity",
    "C*ck", "Cock",
    "C*nnilingus", "Cunnilingus",
    "C*otch", "Crotch",
    "E*oge", "Eroge",
    "Ens*aved", "Enslaved",
    "Erot*c", "Erotic",
    "F**anari", "Futanari",
    "F**k", "Fuck",
    "F*llatio", "Fellatio",
    "H**ny", "Horny",
    "H*ndjob", "Handjob",
    "Imp**gnation", "Impregnation",
    "In*est", "Incest",
    "Interc**rse", "Intercourse",
    "M*sturbation", "Masturbation",
    "N*dist", "Nudist",
    "On**ole", "Onahole",
    "Or*y", "Orgy",
    "P**is", "Penis",
    "P*rnographic", "Pornographic",
    "Pe*vert", "Pervert",
    "Prostit**es", "Prostitutes",
    "R*pe", "Rape",
    "S**ked", "Sucked",
    "S**tty", "Slutty",
    "S*ave", "Slave",
    "S*men", "Semen",
    "S*um", "Scum",
    "S*x", "Sex",
    "s*x", "sex",
    "Su*cide", "Suicide",
    "Tr*sh", "Trash",
    "Virg*n", "Virgin"];

class EpubAddMetaInfo {
    constructor() {
        this.subject = "";
        this.description = "";
        this.author = "";
    }
}

================================================
FILE: plugin/js/EpubPacker.js
================================================

/*
  Functions for packing an EPUB file
*/
"use strict";

/*
    For our purposes, an EPUB only contains two types of content file: XHTML and image.
    - The HTML files are in reading order (i.e. Appear in same order as spine and table of contents (ToC))
    - If an HTML file entry has a "title" element, it will appear in the ToC
    - Stand-alone images (e.g. Cover) will have an XHTML entry that points to the image.
    - First image, (if there are any) will be the cover image
*/

/// <param name="uuid" type="string">identifier for this EPUB.  (i.e. "origin" URL story was downloaded from)</param>
/// <param name="title" type="string">The Title of the story</param>
/// <param name="author" type="string">The writer of the story</param>
class EpubPacker {
    constructor(metaInfo, version = EpubPacker.EPUB_VERSION_2) {
        this.metaInfo = metaInfo;
        this.version = version;

        this.emptyDocFactory = util.createEmptyXhtmlDoc;
        let contentType = EpubPacker.XHTML_MIME_TYPE;
        if (version === EpubPacker.EPUB_VERSION_3) {
            this.emptyDocFactory = util.createEmptyHtmlDoc;
            contentType = EpubPacker.HTML_MIME_TYPE;
        }
        this.contentValidator = xml => util.isXhtmlInvalid(xml, contentType);
    }

    static coverImageXhtmlHref() {
        return "OEBPS/Text/Cover.xhtml";
    }

    static coverImageXhtmlId() {
        return "cover";
    }

    assemble(epubItemSupplier) {
        let zipFileWriter = new zip.BlobWriter("application/epub+zip");
        let zipWriter = new zip.ZipWriter(zipFileWriter,{useWebWorkers: false,compressionMethod: 8, extendedTimestamp: false});
        this.addRequiredFiles(zipWriter);
        zipWriter.add("OEBPS/content.opf", new zip.TextReader(this.buildContentOpf(epubItemSupplier)));
        zipWriter.add("OEBPS/toc.ncx", new zip.TextReader(this.buildTableOfContents(epubItemSupplier)));
        if (this.version === EpubPacker.EPUB_VERSION_3) {
            zipWriter.add("OEBPS/toc.xhtml", new zip.TextReader(this.buildNavigationDocument(epubItemSupplier)));
        }
        this.packContentFiles(zipWriter, epubItemSupplier);
        zipWriter.add(util.styleSheetFileName(), new zip.TextReader(this.metaInfo.styleSheet));
        return zipWriter.close();
    }

    static addExtensionIfMissing(fileName) {
        let extension = ".epub";
        return (fileName.endsWith(extension)) ? fileName : fileName + extension;
    }

    // every EPUB must have a mimetype and a container.xml file
    addRequiredFiles(zipFile) {
        zipFile.add("mimetype",  new zip.TextReader("application/epub+zip"),{compressionMethod: 0});
        zipFile.add("META-INF/container.xml",
            new zip.TextReader("<?xml version=\"1.0\"?>" +
            "<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">" +
                "<rootfiles>" +
                    "<rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/>" +
                "</rootfiles>" +
            "</container>")
        );
    }

    buildContentOpf(epubItemSupplier) {
        let ns = "http://www.idpf.org/2007/opf";
        let opf = document.implementation.createDocument(ns, "package", null);
        opf.documentElement.setAttributeNS(null, "version", this.version);
        opf.documentElement.setAttributeNS(null, "unique-identifier", "BookId");
        this.buildMetaData(opf, epubItemSupplier);
        this.buildManifest(opf, ns, epubItemSupplier);
        this.buildSpine(opf, ns, epubItemSupplier);
        this.buildGuide(opf, ns, epubItemSupplier);

        return util.xmlToString(opf);
    }

    buildMetaData(opf, epubItemSupplier) {
        let opf_ns = "http://www.idpf.org/2007/opf";
        let dc_ns = "http://purl.org/dc/elements/1.1/";

        let metadata = opf.createElementNS(opf_ns, "metadata");
        metadata.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:dc", dc_ns);
        metadata.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:opf", opf_ns);
        opf.documentElement.appendChild(metadata);
        this.createAndAppendChildNS(metadata, dc_ns, "dc:title", this.metaInfo.title);
        this.createAndAppendChildNS(metadata, dc_ns, "dc:language", this.metaInfo.language);
        this.createAndAppendChildNS(metadata, dc_ns, "dc:date", this.getDateForMetaData());
        if (!util.isNullOrEmpty(this.metaInfo.subject)) {
            this.createAndAppendChildNS(metadata, dc_ns, "dc:subject", this.metaInfo.subject);
        }
        if (!util.isNullOrEmpty(this.metaInfo.description)) {
            this.createAndAppendChildNS(metadata, dc_ns, "dc:description", this.metaInfo.description);
        }

        let author = this.createAndAppendChildNS(metadata, dc_ns, "dc:creator", this.metaInfo.author);
        this.addMetaProperty(metadata, author, "file-as", "creator", this.metaInfo.getFileAuthorAs());
        this.addMetaProperty(metadata, author, "role", "creator", "aut");

        if (this.metaInfo.translator !== null) {
            let translator = this.createAndAppendChildNS(metadata, dc_ns, "dc:contributor", this.metaInfo.translator);
            this.addMetaProperty(metadata, translator, "file-as", "translator", this.metaInfo.translator);
            this.addMetaProperty(metadata, translator, "role", "translator", "trl");
        }

        let idText = (this.version === EpubPacker.EPUB_VERSION_3 ? "uri:" : "") + this.metaInfo.uuid;
        let identifier = this.createAndAppendChildNS(metadata, dc_ns, "dc:identifier", idText);
        identifier.setAttributeNS(null, "id", "BookId");
        if (this.version === EpubPacker.EPUB_VERSION_2) {
            identifier.setAttributeNS(opf_ns, "opf:scheme", "URI");
        } else {
            this.addMetaProperty(metadata, identifier, "identifier-type", "BookId", "URI");
            let meta = this.createAndAppendChildNS(metadata, opf_ns, "meta");
            meta.setAttributeNS(null, "property", "dcterms:modified");
            let dateWithoutMillisecond = this.getDateForMetaData().substring(0, 19) + "Z";
            meta.textContent = dateWithoutMillisecond;
        }

        let webToEpubVersion = `[https://github.com/dteviot/WebToEpub] (ver. ${util.extensionVersion()})`;
        let contributor = this.createAndAppendChildNS(metadata, dc_ns, "dc:contributor", webToEpubVersion);
        this.addMetaProperty(metadata, contributor, "role", "packingTool", "bkp");

        if (epubItemSupplier.hasCoverImageFile()) {
            this.appendMetaContent(metadata, opf_ns, "cover", epubItemSupplier.coverImageId());
        }

        if (this.metaInfo.seriesName !== null) {
            this.appendMetaContent(metadata, opf_ns, "calibre:series", this.metaInfo.seriesName);
            this.appendMetaContent(metadata, opf_ns, "calibre:series_index", this.metaInfo.seriesIndex);
        }

        for (let i of epubItemSupplier.manifestItems()) {
            let sourceUrl = util.clearIfDataUri(i.sourceUrl);
            if (sourceUrl) {  // Only add dc:source if we have a valid URL
                let source = this.createAndAppendChildNS(metadata, dc_ns, "dc:source", sourceUrl);
                source.setAttributeNS(null, "id", "id." + i.getId());
            }
        }
    }

    addMetaProperty(metadata, element, propName, id, value) {
        let opf_ns = "http://www.idpf.org/2007/opf";
        if (this.version === EpubPacker.EPUB_VERSION_3) {
            element.setAttributeNS(null, "id", id);
            let meta = this.createAndAppendChildNS(metadata, opf_ns, "meta");
            meta.setAttributeNS(null, "refines", "#" +id);
            meta.setAttributeNS(null, "property", propName);
            meta.textContent = value;
        } else {
            element.setAttributeNS(opf_ns, "opf:" + propName, value);
        }
    }

    appendMetaContent(parent, opf_ns, name, content) {
        let meta = this.createAndAppendChildNS(parent, opf_ns, "meta");
        // Some e-book readers such as the Nook fail to recognize covers if the content
        // attribute comes before the name attribute. For maximum compatibility move
        // the name attribute before the content attribute.
        meta.setAttributeNS(null, "name", name);
        meta.setAttributeNS(null, "content", content);
    }
    
    buildManifest(opf, ns, epubItemSupplier) {
        let manifest = this.createAndAppendChildNS(opf.documentElement, ns, "manifest");
        for (let i of epubItemSupplier.manifestItems()) {
            let item = this.addManifestItem(manifest, ns, i.getZipHref(), i.getId(), i.getMediaType());
            this.setSvgPropertyForManifestItem(item, i.hasSvg());
        }

        this.addManifestItem(manifest, ns, util.styleSheetFileName(), "stylesheet", "text/css");
        this.addManifestItem(manifest, ns, "OEBPS/toc.ncx", "ncx", "application/x-dtbncx+xml");
        if (epubItemSupplier.hasCoverImageFile()) {
            let item = this.addManifestItem(manifest, ns, EpubPacker.coverImageXhtmlHref(), EpubPacker.coverImageXhtmlId(), "application/xhtml+xml");
            this.setSvgPropertyForManifestItem(item, this.doesCoverHaveSvg(epubItemSupplier));
        }
        if (this.version === EpubPacker.EPUB_VERSION_3) {
            let item = this.addManifestItem(manifest, ns, "OEBPS/toc.xhtml", "nav", "application/xhtml+xml");
            item.setAttributeNS(null, "properties", "nav");
        }
    }

    addManifestItem(manifest, ns, href, id, mediaType) {
        let item = this.createAndAppendChildNS(manifest, ns, "item");
        let relativeHref = this.makeRelative(href);
        if (mediaType === "image/webp") {
            let userPreferences = main.getUserPreferences();
            if (!userPreferences?.disableWebpImageFormatError?.value) {
                let errorMsg = UIText.Warning.warningWebpImage(relativeHref);
                ErrorLog.log(errorMsg);
            }
        }
        item.setAttributeNS(null, "href", relativeHref);
        item.setAttributeNS(null, "id", id);
        item.setAttributeNS(null, "media-type", mediaType);
        return item;
    }

    setSvgPropertyForManifestItem(item, hasSvg) {
        if (hasSvg && (this.version === EpubPacker.EPUB_VERSION_3)) {
            item.setAttributeNS(null, "properties", "svg");
        }
    }

    doesCoverHaveSvg(epubItemSupplier) {
        let fileContent = epubItemSupplier.makeCoverImageXhtmlFile(util.createEmptyXhtmlDoc);
        let doc = new DOMParser().parseFromString(fileContent, "application/xml");
        return (doc.querySelector("svg") != null);
    }

    buildSpine(opf, ns, epubItemSupplier) {
        let spine = this.createAndAppendChildNS(opf.documentElement, ns, "spine");
        spine.setAttributeNS(null, "toc", "ncx");
        if (epubItemSupplier.hasCoverImageFile()) {
            this.addSpineItemRef(spine, ns, EpubPacker.coverImageXhtmlId());
        }
        for (let item of epubItemSupplier.spineItems()) {
            this.addSpineItemRef(spine, ns, item.getId());
        }
    }

    addSpineItemRef(spine, ns, idref) {
        this.createAndAppendChildNS(spine, ns, "itemref").setAttributeNS(null, "idref", idref);
    }

    buildGuide(opf, ns, epubItemSupplier) {
        if (epubItemSupplier.hasCoverImageFile()) {
            let guide = this.createAndAppendChildNS(opf.documentElement, ns, "guide");
            let reference = this.createAndAppendChildNS(guide, ns, "reference");
            reference.setAttributeNS(null, "href", this.makeRelative(EpubPacker.coverImageXhtmlHref()));
            reference.setAttributeNS(null, "title", "Cover");
            reference.setAttributeNS(null, "type", "cover");
        }
    }

    buildTableOfContents(epubItemSupplier) {
        let ns = "http://www.daisy.org/z3986/2005/ncx/";
        let ncx = document.implementation.createDocument(ns, "ncx", null);
        ncx.documentElement.setAttribute("version", "2005-1");
        ncx.documentElement.setAttribute("xml:lang", this.metaInfo.language);
        let head = this.createAndAppendChildNS(ncx.documentElement, ns, "head");
        this.buildDocTitle(ncx, ns);
        let depth = this.buildNavMap(ncx, ns, epubItemSupplier);
        this.populateHead(head, ns, depth);

        return util.xmlToString(ncx);
    }

    buildNavigationDocument(epubItemSupplier) {
        let ns = "http://www.w3.org/1999/xhtml";
        let navDoc = document.implementation.createDocument(ns, "html", null);
        navDoc.documentElement.setAttribute("xml:lang", this.metaInfo.language);
        navDoc.documentElement.setAttribute("xmlns:epub", "http://www.idpf.org/2007/ops");
        navDoc.documentElement.setAttribute("lang", this.metaInfo.language);
        let head = this.createAndAppendChildNS(navDoc.documentElement, ns, "head");
        this.createAndAppendChildNS(head, ns, "title").textContent = "Table of Contents";
        this.addDocType(navDoc);
        let body = this.createAndAppendChildNS(navDoc.documentElement, ns, "body");
        let nav = this.createAndAppendChildNS(body, ns, "nav");
        nav.setAttribute("epub:type", "toc");
        nav.setAttribute("id", "toc");
        this.populateNavElement(nav, ns, epubItemSupplier);
        return util.xmlToString(navDoc);
    }

    addDocType(navDoc) {
        let docTypeNode = navDoc.implementation.createDocumentType("html", "", "");
        navDoc.insertBefore(docTypeNode, navDoc.childNodes[0]);
    }

    populateHead(head, ns, depth) {
        this.appendMetaContent(head, ns, "dtb:uid", (this.version === EpubPacker.EPUB_VERSION_3 ? "uri:" : "") + this.metaInfo.uuid);
        this.appendMetaContent(head, ns, "dtb:depth", (depth < 2) ? "2" : depth);
        this.appendMetaContent(head, ns, "dtb:totalPageCount", "0");
        this.appendMetaContent(head, ns, "dtb:maxPageNumber", "0");
    }

    buildDocTitle(ncx, ns) {
        let docTitle = this.createAndAppendChildNS(ncx.documentElement, ns, "docTitle");
        this.createAndAppendChildNS(docTitle, ns, "text", this.metaInfo.title);
    }

    populateNavElement(nav, ns, epubItemSupplier) {
        let rootParent = this.createAndAppendChildNS(nav, ns, "ol");
        let parents = new NavPointParentElementsStack(rootParent);
        for (let chapterInfo of epubItemSupplier.chapterInfo()) {
            let parent = parents.findParentElement(chapterInfo.depth);
            let nextLevel = this.buildNavListItem(parent, ns, chapterInfo);
            parents.addElement(chapterInfo.depth, nextLevel);
        }
        this.removeEmptyNavLists(rootParent);
    }

    buildNavListItem(parent, ns, chapterInfo) {
        let li = this.createAndAppendChildNS(parent, ns, "li");
        let link = this.createAndAppendChildNS(li, ns, "a");
        link.href = this.makeRelative(chapterInfo.src);
        link.textContent = chapterInfo.title;
        return this.createAndAppendChildNS(li, ns, "ol");
    }

    removeEmptyNavLists(rootParent) {
        for (let list of rootParent.querySelectorAll("ol")) {
            if (list.childElementCount === 0) {
                list.remove();
            }
        }
    }

    buildNavMap(ncx, ns, epubItemSupplier) {
        let navMap = this.createAndAppendChildNS(ncx.documentElement, ns, "navMap");
        let parents = new NavPointParentElementsStack(navMap);
        let playOrder = 0;
        let id = 0;
        let lastChapterSrc = null;
        for (let chapterInfo of epubItemSupplier.chapterInfo()) {
            let parent = parents.findParentElement(chapterInfo.depth);
            if (lastChapterSrc !== chapterInfo.src) {
                ++playOrder;
            }
            let navPoint = this.buildNavPoint(parent, ns, playOrder, ++id, chapterInfo);
            lastChapterSrc = chapterInfo.src;
            parents.addElement(chapterInfo.depth, navPoint);
        }
        return parents.maxDepth;
    }

    buildNavPoint(parent, ns, playOrder, id, chapterInfo) {
        let navPoint = this.createAndAppendChildNS(parent, ns, "navPoint");
        navPoint.setAttributeNS(null, "id", this.makeId(util.zeroPad(id)));
        navPoint.setAttributeNS(null, "playOrder", playOrder);
        let navLabel = this.createAndAppendChildNS(navPoint, ns, "navLabel");
        this.createAndAppendChildNS(navLabel, ns, "text", chapterInfo.title);
        this.createAndAppendChildNS(navPoint, ns, "content").setAttributeNS(null, "src", this.makeRelative(chapterInfo.src));
        return navPoint;
    }

    packContentFiles(zipWriter, epubItemSupplier) {
        for (let file of epubItemSupplier.files()) {
            file.packInEpub(zipWriter, this.emptyDocFactory, this.contentValidator);
        }
        if (epubItemSupplier.hasCoverImageFile()) {
            let fileContent = epubItemSupplier.makeCoverImageXhtmlFile(this.emptyDocFactory, "Cover");
            zipWriter.add(EpubPacker.coverImageXhtmlHref(), new zip.TextReader(fileContent));
        }
    }

    createAndAppendChildNS(element, ns, name, data) {
        let child = element.ownerDocument.createElementNS(ns, name);
        if (typeof data  !== "undefined") {
            child.appendChild(element.ownerDocument.createTextNode(data));
        }
        element.appendChild(child);
        return child;
    }

    makeId(id) {
        return "body" + id;
    }
    // changes href to be relative to manifest (and toc.ncx)
    // which are in OEBPS
    makeRelative(href) {
        return href.substr(6);
    }

    /// hook point for unit testing (because we can't control the actual time)
    /// return time string to put into <date> element of metadata
    getDateForMetaData() {
        return new Date().toISOString();
    }
}

EpubPacker.EPUB_VERSION_2 = "2.0";
EpubPacker.EPUB_VERSION_3 = "3.0";
EpubPacker.XHTML_MIME_TYPE = "application/xml";
EpubPacker.HTML_MIME_TYPE = "text/html";

/*
  Class to make sure we correctly nest the NavPoint elements
  in the table of contents
*/
class NavPointParentElementsStack {
    constructor(navMap) {
        this.parents = [];
        this.parents.push({
            element: navMap,
            depth: -1
        });
        this.maxDepth = 0;
    }

    findParentElement(depth) {
        let index = this.parents.length - 1;
        while (depth <= this.parents[index].depth) {
            --index;
        }
        return this.parents[index].element;
    }

    addElement(depth, element) {
        // discard any elements that are nested >= this one
        while (depth <= this.parents[this.parents.length - 1].depth) {
            this.parents.pop();
        }
        this.parents.push({
            element: element,
            depth: depth
        });
        if (this.maxDepth < this.parents.length - 1) {
            this.maxDepth = this.parents.length - 1;
        }
    }
}

================================================
FILE: plugin/js/ErrorLog.js
================================================

"use strict";

class ErrorLog {
    constructor() {
    }
    static SuppressErrorLog =  false;

    static log(error) {
        ErrorLog.history.push(ErrorLog.getMsgText(error));
    }

    static showErrorMessage(msg) {
        // if already showing an error message, queue the new one to display
        // when currently showing is closed. 
        if (this.SuppressErrorLog && msg.retryAction == null) {
            return;
        }
        ErrorLog.queue.push(msg);
        if (1 < ErrorLog.queue.length) {
            return;
        }

        let sections = ErrorLog.hideAllSectionsSavingVisibility();
        ErrorLog.getErrorSection().hidden = false;

        ErrorLog.setErrorMessageText(msg);
        ErrorLog.setErrorMessageButtons(msg, sections);
    }

    static onCloseError(sections) {
        ErrorLog.queue.shift();
        if (ErrorLog.queue.length === 0) {
            ErrorLog.restoreSectionVisibility(sections);
        } else {
            ErrorLog.setErrorMessageText(ErrorLog.queue[0]);
            ErrorLog.setErrorMessageButtons(ErrorLog.queue[0], sections);
        }
    }

    static showLogToUser() {
        let history = ErrorLog.dumpHistory();
        if (!util.isNullOrEmpty(history)) {
            ErrorLog.showErrorMessage(history);
        }
    }

    static clearHistory() {
        ErrorLog.history = [];
    }

    static dumpHistory() {
        let errors = ErrorLog.history.join("\r\n\r\n");
        return errors;
    }

    /** private */
    static getErrorSection() {
        return document.getElementById("errorSection");
    }

    /** private */
    static hideAllSectionsSavingVisibility() {
        let sections = new Map();
        for (let section of document.querySelectorAll("section")) {
            sections.set(section, section.hidden);
            section.hidden = true;
        }
        return sections;
    }

    /** private */
    static setErrorMessageText(msg) {
        let textRow = document.querySelector("#errorMessageText pre");
        textRow.textContent = ErrorLog.getMsgText(msg);
    }

    static getMsgText(msg) {
        if (typeof (msg) === "string") {
            return msg;
        } else {
            // assume msg is some sort of error object
            let retVal = "" + msg.stack;
            if (!retVal.includes(msg.message)) {
                retVal = msg.message + " " + retVal;
            }
            return retVal;
        }
    }

    /** private */
    static setErrorMessageButtons(msg, sections) {
        let close = () => ErrorLog.onCloseError(sections);
        let okButton = document.getElementById("errorButtonOk");
        let retryButton = document.getElementById("errorButtonRetry");
        let cancelButton = document.getElementById("errorButtonCancel");
        let OpenURLButton = document.getElementById("errorButtonOpenURL");
        let BlockURLButton = document.getElementById("errorButtonBlockURL");
        if (msg.retryAction !== undefined) {
            okButton.hidden = true;
            retryButton.hidden = false;
            retryButton.onclick = function() {
                close();
                msg.retryAction();
            };
            cancelButton.hidden = false;
            cancelButton.onclick = function() {
                close();
                msg.cancelAction();
            };
            cancelButton.textContent = UIText.Common.cancel;
            if (msg.cancelLabel !== undefined) {
                cancelButton.textContent =  msg.cancelLabel;
            }
            if (msg.openurl !== undefined) {
                OpenURLButton.hidden = false;
                OpenURLButton.onclick = function() {
                    //window.open(new URL(msg.openurl), "_blank").focus();
                    //use chrome.tabs.create to prevent auto popup block from browser
                    chrome.tabs.create({ url: msg.openurl});
                };
                BlockURLButton.hidden = false;
                BlockURLButton.onclick = function() {
                    close();
                    BlockedHostNames.add(new URL(msg.blockurl).hostname);
                    msg.cancelAction();
                };
            } else {
                OpenURLButton.hidden = true;
                BlockURLButton.hidden = true;
            }
        } else {
            okButton.hidden = false;
            okButton.onclick = close;
            retryButton.hidden = true;
            cancelButton.hidden = true;
            OpenURLButton.hidden = true;
            BlockURLButton.hidden = true;
        }
    }

    /** private */
    static restoreSectionVisibility(sections) {
        for (let [key,value] of sections) {
            key.hidden = value;
        }
    }
}

ErrorLog.queue = [];
ErrorLog.history = [];

================================================
FILE: plugin/js/Firefox.js
================================================

"use strict";

/** Functions specific to Firefox version of plug-in */
class Firefox { // eslint-disable-line no-unused-vars
    constructor() {
    }

    /** fetch() calls on Firefox include an origin header.
        Which makes some sites fail with a CORS violation.
        Need to use a webRequest to remove origin from header.
    */    
    static filterHeaders(e) {
        return {requestHeaders: e.requestHeaders.filter(
            h => ((h.name.toLowerCase() !== "origin")
                || !h.value.startsWith("moz-extension://"))
        )};
    }

    static startWebRequestListeners() {
        browser.webRequest.onBeforeSendHeaders.addListener(
            Firefox.filterHeaders,
            {urls: ["<all_urls>"]},
            ["blocking", "requestHeaders"]
        );
    }

    static injectContentScript(tabId) {
        chrome.tabs.executeScript(tabId, { file: "js/ContentScript.js", runAt: "document_end" },
            function(result) {   // eslint-disable-line no-unused-vars
                if (chrome.runtime.lastError) {
                    util.log(chrome.runtime.lastError.message);
                }
            }
        );
    }
}

================================================
FILE: plugin/js/FootnoteExtractor.js
================================================

class FootnoteExtractor { // eslint-disable-line no-unused-vars
    scriptElementsToFootnotes(dom) {
        let indexedFootnotes = new Map();
        [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(s => s.includes("toolTips('.classtoolTips"))
            .forEach(s => indexedFootnotes.set(this.getId(s), this.extractFootnoteText(s)));

        return this.getIdsUsedOnPage(dom)
            .map(id => this.makeSpan(indexedFootnotes.get(id), dom));
    }

    getIdsUsedOnPage(dom) {
        let extractId = (span) => [...span.classList]
            .filter(s => s.startsWith("class"))[0];

        return [...dom.querySelectorAll("span.tooltipsall")]
            .map(extractId);
    }

    getId(script) {
        return this.extractSubstring(script, "toolTips('.", ",").replace("'", "");
    }

    makeSpan(content, dom) {
        let span = dom.createElement("span");
        span.textContent = content;
        return span;
    }

    extractFootnoteText(content) {
        return this.extractSubstring(content, "tt_store_content = \"", "\"; toolTips('");
    }

    extractSubstring(content, startTag, endTag) {
        content = content.substring(content.indexOf(startTag) + startTag.length);
        return content.substring(0, content.indexOf(endTag));
    }
}

================================================
FILE: plugin/js/HttpClient.js
================================================

/*
  Makes HTML calls using Fetch API
*/
"use strict";

class FetchErrorHandler {
    constructor() {
    }

    makeFailMessage(url, error) {
        return UIText.Error.htmlFetchFailed(url, error);
    }

    makeFailCanRetryMessage(url, error) {
        return this.makeFailMessage(url, error) + " " +
            UIText.Warning.httpFetchCanRetry;
    }

    getCancelButtonText() {
        return UIText.Common.cancel;
    }

    static cancelButtonText() {
        return UIText.Common.cancel;
    }

    onFetchError(url, error) {
        return Promise.reject(new Error(this.makeFailMessage(url, error.message)));
    }

    onResponseError(url, wrapOptions, response, errorMessage) {
        let failError;
        if (errorMessage) {
            failError = new Error(errorMessage);
        } else {
            failError = new Error(this.makeFailMessage(response.url, response.status));
        }
        let retry = FetchErrorHandler.getAutomaticRetryBehaviourForStatus(response);
        if (retry.retryDelay.length === 0) {
            return Promise.reject(failError);
        }

        if (wrapOptions.retry === undefined) {
            wrapOptions.retry = retry;
            return this.retryFetch(url, wrapOptions);
        }

        if (0 < wrapOptions.retry.retryDelay.length) {
            return this.retryFetch(url, wrapOptions);
        }

        if (wrapOptions.retry.promptUser) {
            return this.promptUserForRetry(url, wrapOptions, response, failError);
        } else {
            return Promise.reject(failError);
        }
    }

    promptUserForRetry(url, wrapOptions, response, failError) {
        let msg;
        if (wrapOptions.retry.HTTP === 403) { 
            msg = new Error(UIText.Warning.warning403ErrorResponse(new URL(response.url).hostname) + this.makeFailCanRetryMessage(url, response.status));
        } else {
            msg = new Error(new Error(this.makeFailCanRetryMessage(url, response.status)));
        }
        let cancelLabel = this.getCancelButtonText();
        return new Promise((resolve, reject) => {
            if (wrapOptions.retry.HTTP === 403) {
                msg.openurl = response.url;
                msg.blockurl = url;
            }
            msg.retryAction = () => resolve(HttpClient.wrapFetchImpl(url, wrapOptions));
            msg.cancelAction = () => reject(failError);
            msg.cancelLabel = cancelLabel;
            ErrorLog.showErrorMessage(msg);
        });
    }

    async retryFetch(url, wrapOptions) {
        let delayBeforeRetry = wrapOptions.retry.retryDelay.pop() * 1000;
        await util.sleep(delayBeforeRetry);
        return HttpClient.wrapFetchImpl(url, wrapOptions);
    }

    static getAutomaticRetryBehaviourForStatus(response) {
        // seconds to wait before each retry (note: order is reversed)
        let retryDelay = [120, 60, 30, 15];
        switch (response.status) {
            case 403:
                return {retryDelay: [1], promptUser: true, HTTP: 403};
            case 429:
                FetchErrorHandler.show429Error(response);
                return {retryDelay: retryDelay, promptUser: true};
            case 445:
            //Random Unique exception thrown on Webnovel/Qidian. Not part of w3 spec.
                return {retryDelay: retryDelay, promptUser: false};
            case 509:
            // server asked for rate limiting
                return {retryDelay: retryDelay, promptUser: true};
            case 500:
            // is fault at server, retry might clear
                return {retryDelay: retryDelay, promptUser: false};
            case 502: 
            case 503: 
            case 504:
            case 520:
            case 522:
            // intermittant fault
                return {retryDelay: retryDelay, promptUser: true};
            case 524:
            // claudflare random error
                return {retryDelay: [1], promptUser: true};
            case 999:
            // custom WebToEpub error (some api's fail and a few seconds later it is a success)
                return {retryDelay: response.retryDelay, promptUser: false};
            default:
            // it's dead Jim
                return {retryDelay: [], promptUser: false};
        }
    }

    static show429Error(response) {
        let host = new URL(response.url).hostname;
        if (!FetchErrorHandler.rateLimitedHosts.has(host)) {
            FetchErrorHandler.rateLimitedHosts.add(host);
            alert(UIText.Warning.warning429ErrorResponse(host));
        }
    }
}
FetchErrorHandler.rateLimitedHosts = new Set();

class FetchImageErrorHandler extends FetchErrorHandler { // eslint-disable-line no-unused-vars
    constructor(parentPageUrl) {
        super();
        this.parentPageUrl = parentPageUrl;
    }

    makeFailMessage(url, error) {
        return UIText.Error.imageFetchFailed(url, this.parentPageUrl, error);
    }

    getCancelButtonText() {
        return UIText.Common.skip;
    }
}

class HttpClient {
    constructor() {
    }

    static makeOptions() {
        return { credentials: "include" };
    }

    static wrapFetch(url, wrapOptions) {
        if (wrapOptions == null) {
            wrapOptions = {
                errorHandler: new FetchErrorHandler()
            };
        }
        if (wrapOptions.errorHandler == null) {
            wrapOptions.errorHandler = new FetchErrorHandler();
        }
        wrapOptions.responseHandler = new FetchResponseHandler();
        if (wrapOptions.makeTextDecoder != null) {
            wrapOptions.responseHandler.makeTextDecoder = wrapOptions.makeTextDecoder;
        }
        return HttpClient.wrapFetchImpl(url, wrapOptions);
    }

    static fetchHtml(url) {
        let wrapOptions = {
            responseHandler: new FetchHtmlResponseHandler()
        };
        return HttpClient.wrapFetchImpl(url, wrapOptions);
    }

    static fetchJson(url, fetchOptions) {
        let parser = fetchOptions?.parser;
        delete fetchOptions?.parser;
        let wrapOptions = {
            responseHandler: new FetchJsonResponseHandler(),
            fetchOptions: fetchOptions,
            parser: parser
        };
        return HttpClient.wrapFetchImpl(url, wrapOptions);
    }

    static fetchText(url) {
        let wrapOptions = {
            responseHandler: new FetchTextResponseHandler(),
        };
        return HttpClient.wrapFetchImpl(url, wrapOptions);
    }

    static async wrapFetchImpl(url, wrapOptions) {
        if (BlockedHostNames.has(new URL(url).hostname)) {
            let skipurlerror = new Error("!Blocked! URL skipped because the user blocked the site");
            return wrapOptions.errorHandler.onFetchError(url, skipurlerror);
        }
        await HttpClient.setPartitionCookies(url);
        if (wrapOptions.fetchOptions == null) {
            wrapOptions.fetchOptions = HttpClient.makeOptions();
        }
        if (wrapOptions.errorHandler == null) {
            wrapOptions.errorHandler = new FetchErrorHandler();
        }
        try
        {
            let response = await fetch(url, wrapOptions.fetchOptions);
            let ret = await HttpClient.checkResponseAndGetData(url, wrapOptions, response);
            if (wrapOptions.parser?.isCustomError(ret)) {
                let CustomErrorResponse = wrapOptions.parser.setCustomErrorResponse(url, wrapOptions, ret);
                return wrapOptions.errorHandler.onResponseError(CustomErrorResponse.url, CustomErrorResponse.wrapOptions, CustomErrorResponse.response, CustomErrorResponse.errorMessage);
            }
            return ret;
        }
        catch (error)
        {
            return wrapOptions.errorHandler.onFetchError(url, error);
        }
    }

    static checkResponseAndGetData(url, wrapOptions, response) {
        if (!response.ok) {
            return wrapOptions.errorHandler.onResponseError(url, wrapOptions, response);
        } else {
            let handler = wrapOptions.responseHandler;
            handler.setResponse(response);
            return handler.extractContentFromResponse(response);
        }
    }

    static async setDeclarativeNetRequestRules(RulesArray) {
        let url = chrome.runtime.getURL("").split("/").filter(a => a != "");
        let id = url[url.length - 1];
        for (let i = 0; i < RulesArray.length; i++) {
            //limit rule to only webtoepub domain to prevent potiential security problems
            RulesArray[i].condition.initiatorDomains = [id];
        }
        let oldRules = await chrome.declarativeNetRequest.getSessionRules();
        //In firefox i had declarativeNetRequest.getSessionRules() fail with undefined
        if (oldRules == null) {
            oldRules = [];
        }
        let oldRuleIds = oldRules.map(rule => rule.id);
        await chrome.declarativeNetRequest.updateSessionRules({
            removeRuleIds: oldRuleIds,
            addRules: RulesArray
        });
    }

    static async setPartitionCookies(url) {
        // get partitionKey in the form of https://<site name>.<tld>
        let parsedUrl = new URL(url);
        //keep old code for reference in case it changes again
        //let topLevelSite = parsedUrl.protocol + "//" + parsedUrl.hostname;

        try {
            //  get all cookie from the site which use the partitionKey (e.g. cloudflare)
            //keep old code for reference in case it changes again
            //let cookies = await chrome.cookies.getAll({partitionKey: {topLevelSite: topLevelSite}});
            
            //set domain to the highest level from the website as all subdomains are included #1447 #1445
            let urlparts = parsedUrl.hostname.split(".");
            let cookies = "";
            if (!util.isFirefox()) {
                cookies = await chrome.cookies.getAll({domain: urlparts[urlparts.length-2]+"."+urlparts[urlparts.length-1],partitionKey: {}});
            } else {
                cookies = await browser.cookies.getAll({domain: urlparts[urlparts.length-2]+"."+urlparts[urlparts.length-1],partitionKey: {}});
            }
            cookies = cookies.filter(item => item.partitionKey != undefined);
            //create new cookies for the site without the partitionKey
            //cookies without the partitionKey get sent with fetch
            cookies.forEach(element => chrome.cookies.set({
                domain: element.domain,
                url: "https://"+element.domain.substring(1),
                name: element.name, 
                value: element.value
            }));
        } catch {
            // Probably running browser that doesn't support partitionKey, e.g. Kiwi
            console.log("failed to set cookie");
        } 
    }
}

let BlockedHostNames = new Set();

class FetchResponseHandler {
    isHtml() {
        return this.contentType.startsWith("text/html");
    }

    setResponse(response) {
        this.response = response;
        this.contentType = response.headers.get("content-type");
    }

    extractContentFromResponse(response) {
        if (this.isHtml()) {
            return this.responseToHtml(response);
        } else {
            return this.responseToBinary(response);
        }
    }

    responseToHtml(response) {
        return response.arrayBuffer().then(function(rawBytes) {
            let data = this.makeTextDecoder(response).decode(rawBytes);
            let html = new DOMParser().parseFromString(data, "text/html");
            util.setBaseTag(this.response.url, html);
            this.responseXML = html;
            return this;
        }.bind(this));
    }

    responseToBinary(response) {
        return response.arrayBuffer().then(function(data) {
            this.arrayBuffer = data;
            return this;
        }.bind(this));
    }

    responseToText(response) {
        return response.arrayBuffer().then(function(rawBytes) {
            return this.makeTextDecoder(response).decode(rawBytes);
        }.bind(this));
    }

    responseToJson(response) {
        return response.text().then(function(data) {
            this.json =  JSON.parse(data);
            return this;
        }.bind(this));
    }

    makeTextDecoder(response) {
        let utflabel = this.charsetFromHeaders(response.headers);
        return new TextDecoder(utflabel);
    }

    charsetFromHeaders(headers) {
        let contentType = headers.get("Content-Type");
        if (!util.isNullOrEmpty(contentType)) {
            let pieces = contentType.toLowerCase().split("charset=");
            if (2 <= pieces.length) {
                return pieces[1].split(";")[0].replace(/"/g, "").trim();
            }
        }
        return FetchResponseHandler.DEFAULT_CHARSET;
    }
}
FetchResponseHandler.DEFAULT_CHARSET = "utf-8";

class FetchJsonResponseHandler extends FetchResponseHandler {
    constructor() {
        super();
    }

    extractContentFromResponse(response) {
        return super.responseToJson(response);
    }
}

class FetchTextResponseHandler extends FetchResponseHandler {
    constructor() {
        super();
    }

    extractContentFromResponse(response) {
        return super.responseToText(response);
    }
}

class FetchHtmlResponseHandler extends FetchResponseHandler {
    constructor() {
        super();
    }

    extractContentFromResponse(response) {
        return super.responseToHtml(response);
    }
}

================================================
FILE: plugin/js/ImageCollector.js
================================================

/*
    Fetches the image files
*/

"use strict";

/** class that handles image tags

- urlIndex - track URLs associated with an ImageInfo
- bitmapIndex - hashes of the image bitmaps, to allow us to eliminate duplicate images
- imagesToFetch - images that need to be fetched from internet
- imagesToPack - images to pack into epub
*/
class ImageCollector {
    constructor() {
        this.reset();
        this.userPreferences = null;
    }

    // An "image collector" with no images
    // used by parsers for source with no images.
    static StubCollector() {
        return {
            coverImageInfo: null,
            imagesToPackInEpub: function() { return []; }
        };
    }

    reset() {
        this.imageInfoList = [];
        this.urlIndex = new Map();
        this.bitmapIndex = new Map();
        this.imagesToFetch = [];
        this.imagesToPack = [];
        this.coverImageInfo = null;
    }

    copyState(otherImageCollector) {
        this.imageInfoList = otherImageCollector.imageInfoList;
        this.urlIndex = otherImageCollector.urlIndex;
        this.bitmapIndex = otherImageCollector.bitmapIndex;
        this.imagesToFetch = otherImageCollector.imagesToFetch;
        this.imagesToPack = otherImageCollector.imagesToPack;
        this.coverImageInfo = otherImageCollector.coverImageInfo;
        this.userPreferences = otherImageCollector.userPreferences;
    }

    addImageInfo(wrappingUrl, sourceUrl, dataOrigFileUrl, fetchFirst) {
        let imageInfo = null;
        let index = this.urlIndex.get(sourceUrl);
        if (index === undefined) {
            index = this.urlIndex.get(wrappingUrl);
        }
        if (index === undefined) {
            index = this.urlIndex.get(dataOrigFileUrl);
        }
        if (index !== undefined) {
            imageInfo = this.imageInfoList[index];
        } else {
            index = this.imageInfoList.length;
            imageInfo = new ImageInfo(wrappingUrl, index, sourceUrl, dataOrigFileUrl);
            this.imageInfoList.push(imageInfo);
            if (fetchFirst) {
                this.imagesToFetch = [imageInfo].concat(this.imagesToFetch);
            } else {
                this.imagesToFetch.push(imageInfo);
            }
        }
        this.urlIndex.set(wrappingUrl, index);
        this.urlIndex.set(sourceUrl, index);
        if (dataOrigFileUrl != null) {
            this.urlIndex.set(dataOrigFileUrl, index);
        }
        return imageInfo;
    }

    setCoverImageUrl(url) {
        // Note, this can be called in two cases.
        // 1. Baka-Tsuki, where images have already been loaded, so image may already be present
        // 2. Other Parsers, so image is not present.
        if (!util.isNullOrEmpty(url)) {
            let info = this.imageInfoByUrl(url);
            if (info === null) {
                info = this.addImageInfo(url, url, null, true);
            }
            info.isCover = true;
            this.coverImageInfo = info;
        }
    }

    imageInfoByUrl(url) {
        let index = this.urlIndex.get(url);
        return (index === undefined) ? null : this.imageInfoList[index];
    }

    onUserPreferencesUpdate(userPreferences) {
        this.userPreferences = userPreferences;
    }

    numberOfImagesToFetch() {
        return this.imagesToFetch.length;
    }

    async fetchImages(progressIndicator, parentPageUrl) {
        for (let imageInfo of this.imagesToFetch) {
            if (!imageInfo.queuedForFetch) {
                imageInfo.queuedForFetch = true;
                await this.fetchImage(imageInfo, progressIndicator, parentPageUrl);
            }
        }
        this.imagesToFetch = [];
    }

    /**
  - @private
    */
    addToPackList(imageInfo) {
        let hash = ImageCollector.calculateHash(imageInfo.arraybuffer);
        let index = this.bitmapIndex.get(hash);
        if (index === undefined) {
            // first time we've seen the bitmap, so all OK
            this.bitmapIndex.set(hash, imageInfo.index);
            this.imagesToPack.push(imageInfo);
        } else {
            // duplicate bitmap, use previous version
            let wrongIndex = imageInfo.index;
            for (let [key, value] of this.urlIndex) {
                if (value === wrongIndex) {
                    this.urlIndex.set(key, index);
                }
            }
        }
    }

    /**
  - @private
    */
    static calculateHash(arraybuffer) {
        let hash = 0;
        let byteArray = new Uint8Array(arraybuffer);
        if (byteArray.length !== 0) {
            for (let i = 0; i < byteArray.length; ++i) {
                hash = ((hash << 5) - hash) + byteArray[i];
                hash |= 0;
            }
        }
        return ImageCollector.toHex(byteArray.length) + ImageCollector.toHex(hash);
    }

    /** Convert integer to 8 character Hex value
  - @private
    */
    static toHex(i) {
        let s = "00000000" + i.toString(16);
        return s.substring(s.length - 8);
    }

    /*
  - Hook point for Baka-Tsuki to select image to fetch
    */
    selectImageUrlFromHtmlImagesPage(html) {  // eslint-disable-line no-unused-vars
        return null;
    }

    // get URL of page that holds all copies of this image
    extractWrappingUrl(element) {
        if (element.tagName.toLowerCase() === "img") {
            return element.src;
        }
        return (element.tagName.toLowerCase() === "a") ? element.href : element.getElementsByTagName["a"](0).href;
    }

    makeImageTagReplacer(element) {
        let wrappingElement = this.findImageWrappingElement(element);
        let wrappingUrl = this.extractWrappingUrl(wrappingElement);
        return new ImageTagReplacer(wrappingElement, wrappingUrl, this.userPreferences);
    }

    findImageWrappingElement(element) {
        // find "highest" element that is wrapping an image element
        let link = this.findWrappingLink(element);
        if (link === null) {
            // image not wrapped in hyperlink, so just return the image itself
            return element;
        }
        let parent = link;
        while (parent != null) {
            if (this.isImageWrapperElement(parent)) {
                return parent;
            }
            parent = parent.parentElement;
        }

        // assume all images are wrapped in at least a href
        return link;
    }

    findWrappingLink(element) {
        let link = element.parentElement;
        while (link !== null) {
            if (link.tagName.toLowerCase() === "a") {
                return link;
            }
            link = link.parentElement;
        }
        return link;
    }

    isImageWrapperElement(element) {
        return ((element.tagName.toLowerCase() === "div") &&
            ((element.className === "thumb tright") || (element.className === "floatright") ||
            (element.className === "thumb") || (element.className === "floatleft")));
    }

    findImagesUsedInDocument(content) {
        for (let imageElement of content.querySelectorAll("img")) {
            this.fixLazyLoadImageSource(imageElement);
            let src = this.findHighestResImage(imageElement);
            let wrappingElement = this.findImageWrappingElement(imageElement);
            let wrappingUrl = this.extractWrappingUrl(wrappingElement);
            let existing = this.imageInfoByUrl(wrappingUrl);
            if (existing == null) {
                let dataOrigFileUrl = this.findDataOrigFileUrl(imageElement, wrappingUrl);
                this.addImageInfo(wrappingUrl, src, dataOrigFileUrl, false);
            } else {
                existing.isOutsideGallery = true;
            }
        }
    }

    findHighestResImage(img) {
        let srcset = img.getAttribute("srcset");
        if (srcset != null) {
            let src = this.findHighestResInSrcset(srcset);
            if (src != null) {
                img.src = this.findHighestResInSrcset(srcset);
            }
        }
        return img.src;
    }

    findHighestResInSrcset(srcset) {
        let max = -1;
        let url = null;
        let pairs = srcset.split(",")
            .map(o => o.trim().split(" "))
            .filter(o => (o.length == 2) && o[0].startsWith("http"));
        for (let pair of pairs) {
            let size = parseInt(pair[1]);
            if (max < size) {
                max = size;
                url = pair[0];
            }
        }
        return url;
    }

    fixLazyLoadImageSource(img) {
        for (let attrib of ["data-lazy-srcset", "data-srcset"]) {
            let lazySrcset = img.getAttribute(attrib);
            if (lazySrcset != null) {
                img.setAttribute("srcset", lazySrcset);
                break;
            }
        }

        for (let attrib of ["data-lazy-src", "data-src"]) {
            let lazySrc = img.getAttribute(attrib);
            if (lazySrc != null) {
                img.src = lazySrc;
                break;
            }
        }
        return img.src;
    }

    findDataOrigFileUrl(imageElement, wrappingUrl) {
        let dataOrigFile = imageElement.getAttribute("data-orig-file");
        if ((dataOrigFile != null) && (dataOrigFile != imageElement.src)
            && (dataOrigFile != wrappingUrl)) {
            let baseUrl = imageElement.ownerDocument.baseURI;
            return util.resolveRelativeUrl(baseUrl, dataOrigFile);
        }
        return null;
    }

    /**  Update image tags, point to image file in epub
  - @param {element} element containing <img> tags to update
    */
    replaceImageTags(element) {
        let converters = [];
        for (let currentNode of element.querySelectorAll("img")) {
            converters.push(this.makeImageTagReplacer(currentNode));
        }
        converters.forEach(c => c.replaceTag(this.imageInfoByUrl(c.wrappingUrl)));
    }

    getImageDimensions(imageInfo) {
        return new Promise((resolve, reject) => { // eslint-disable-line no-unused-vars
            let img = new Image();
            let options = {type: imageInfo.mediaType};
            let blob = new Blob([new Uint8Array(imageInfo.arraybuffer)], options);
            let dataUrl = URL.createObjectURL(blob);
            img.onload = function() {
                imageInfo.height = img.height;
                imageInfo.width = img.width;
                URL.revokeObjectURL(dataUrl);
                resolve(img);
            };
            img.onerror = function() {
                // If the image gives an error then set a general height and width
                imageInfo.height = 1200;
                imageInfo.width = 1600;
                URL.revokeObjectURL(dataUrl);
                reject(img);
            };
            // start downloading image after event handlers are set
            img.src = dataUrl;
        });
    }

    runCompression(imageInfo, img) {
        return new Promise((resolve, reject) => {
            if (this.userPreferences.compressImages.value)
            {
                let outputType = "image/jpeg";
                switch (this.userPreferences.compressImagesType.value) {
                    case "auto":
                        outputType = util.detectMimeType(imageInfo.getBase64(25));
                        break;
                    case "webp":
                        outputType = "image/webp";
                        break;
                    case "png":
                        outputType = "image/png";
                        break;
                    case "jpg":
                    default:
                        outputType = "image/jpeg";
                        break;
                }

                if (imageInfo.isCover && this.userPreferences.compressImagesJpgCover.value)
                {
                    outputType = "image/jpeg";
                }
                let c = document.createElement("canvas");
                let ctx = c.getContext("2d");
                let maxResolution = this.userPreferences.compressImagesMaxResolution.value;            
                if (imageInfo.height > maxResolution || imageInfo.width > maxResolution)
                {
                    if (imageInfo.height > imageInfo.width)
                    {
                        c.height = maxResolution;
                        c.width = Math.max(1, Math.round((imageInfo.width * 1.0) / ((imageInfo.height * 1.0)/maxResolution)));
                    }
                    else
                    {
                        c.width = maxResolution;
                        c.height = Math.max(1, Math.round((imageInfo.height * 1.0) / ((imageInfo.width * 1.0)/maxResolution)));
                    }
                }
                else
                {
                    c.height = imageInfo.height;
                    c.width = imageInfo.width;
                }
                ctx.drawImage(img, 0, 0, c.width, c.height);
                c.toBlob(async (cBlob) => {
                    try {
                        imageInfo.height = c.height;
                        imageInfo.width = c.width;
                        imageInfo.mediaType = outputType;
                        imageInfo.arraybuffer = await cBlob.arrayBuffer();
                        resolve();
                    } catch (e) {
                        reject();
                    }
                }, outputType, 0.9);
            }
            else
            {
                resolve();
            }
        });
    }

    async fetchImage(imageInfo, progressIndicator, parentPageUrl) {
        try
        {
            let initialUrl = this.initialUrlToTry(imageInfo);
            this.urlIndex.set(initialUrl, imageInfo.index);
            let fetchOptions = {errorHandler: new FetchImageErrorHandler(parentPageUrl) };
            let xhr = await HttpClient.wrapFetch(initialUrl, fetchOptions);
            xhr = await this.findImageFileUrl(xhr, imageInfo, imageInfo.dataOrigFileUrl, fetchOptions);
            imageInfo.mediaType = xhr.contentType;
            imageInfo.arraybuffer = xhr.arrayBuffer;
            this.fixupInvalidMediaType(imageInfo);
            {
                let img = await this.getImageDimensions(imageInfo);
                await this.runCompression(imageInfo, img);
            }
            progressIndicator();
            this.addToPackList(imageInfo);
        }
        catch (error)
        {
            // ToDo, implement error handler.
            this.imagesToPack.push(imageInfo);
            ErrorLog.log(error);
        }
    }

    fixupInvalidMediaType(imageInfo) {
        if (!imageInfo.mediaType?.startsWith("image")) {
            imageInfo.mediaType = util.detectMimeType(imageInfo.getBase64(25));
            if (imageInfo.mediaType == null)
            {
                let path = new URL(imageInfo.sourceUrl).pathname;
                let index = path.lastIndexOf(".");
                let format = (index < 0)
                    ? "jpeg"
                    : path.substring(index + 1);
                imageInfo.mediaType = "image/" + format;
            }
        }
    }

    findImageFileUrl(xhr, imageInfo, dataOrigFileUrl, fetchOptions) {
        // with Baka-Tsuki, the link wrapping the image will return an HTML
        // page with a set of images.  We need to pick the desired image
        if (xhr.isHtml()) {
            // find URL of wanted image file on html page
            // if we can't find one, just use the original image.
            let temp = this.selectImageUrlFromImagePage(xhr.responseXML);
            if (temp == null) {
                if (dataOrigFileUrl != null) {
                    return this.findImageFileUrlUsingDataOrigFileUrl(imageInfo);
                }
                if (!this.userPreferences?.disableImageResError?.value) {
                    let baseUri = xhr.responseXML.baseURI;
                    let errorMsg = UIText.Error.gotHtmlExpectedImageWarning(baseUri);
                    ErrorLog.log(errorMsg);
                }
                temp = imageInfo.sourceUrl;
            }
            temp = ImageCollector.removeSizeParamsFromWordPressQuery(temp);
            this.urlIndex.set(temp, imageInfo.index);
            return HttpClient.wrapFetch(temp, fetchOptions);
        } else {
            // page wasn't HTML, so assume is actual image
            imageInfo.sourceUrl = xhr.response.url;
            this.urlIndex.set(xhr.response.url, imageInfo.index);
            return Promise.resolve(xhr);
        }
    }

    findImageFileUrlUsingDataOrigFileUrl(imageInfo) {
        return HttpClient.wrapFetch(imageInfo.dataOrigFileUrl).then(
            xhr => this.findImageFileUrl(xhr, imageInfo, null)
        );
    }

    imagesToPackInEpub() {
        return this.imagesToPack;
    }

    /*
  - Hook point to allow picking between high and low res images.
    */
    initialUrlToTry(imageInfo) {
        let urlToTry = imageInfo.sourceUrl;
        if (!util.isNullOrEmpty(imageInfo.wrappingUrl)
            && !ImageCollector.urlHasFragment(imageInfo.wrappingUrl)) {
            urlToTry = imageInfo.wrappingUrl;
        }
        return ImageCollector.removeSizeParamsFromWordPressQuery(urlToTry);
    }

    static urlHasFragment(url) {
        try {
            return !util.isNullOrEmpty(new URL(url).hash);
        } catch (error) {
            return false;
        }
    }

    static removeSizeParamsFromWordPressQuery(originalUrl) {
        let url = new URL(originalUrl);
        let searchParams = url.searchParams;
        if (!util.isNullOrEmpty(searchParams.toString()) &&
            ImageCollector.isWordPressHostedFile(url.hostname) ) {
            ImageCollector.removeSizeParamsFromSearch(searchParams);
            return url.toString();
        } else {
            return originalUrl;
        }
    }

    static isWordPressHostedFile(hostname) {
        return hostname.endsWith("files.wordpress.com") || hostname.endsWith(".wp.com");
    }

    static removeSizeParamsFromSearch(searchParams) {
        searchParams.delete("w");
        searchParams.delete("h");
        searchParams.delete("resize");
    }

    /**
  - Derived classes will override
  - Base version tells user there's a problem
    */
    selectImageUrlFromImagePage(dom) {
        // try MediaWiki format
        let div = dom.querySelector("div.fullMedia");
        if (div !== null) {
            let link = div.querySelector("a");
            return (link === null) ? null : link.href;
        }
        return null;
    }

    preprocessImageTags(content, parentPageUrl) {
        if (this.userPreferences.skipImages.value) {
            util.removeChildElementsMatchingSelector(content, "img, image");
            return Promise.resolve(content);
        } else {
            return ImageCollector.replaceHyperlinksToImagesWithImages(content, parentPageUrl);
        }
    }

    static replaceHyperlinksToImagesWithImages(content, parentPageUrl) {
        let toReplace = util.getElements(content, "a", ImageCollector.isHyperlinkToImage);
        for (let hyperlink of toReplace.filter(h => !ImageCollector.linkContainsImageTag(h))) {
            ImageCollector.replaceHyperlinkWithImg(hyperlink);
        }
        return Imgur.expandGalleries(content, parentPageUrl);
    }

    /** @private */
    static isHyperlinkToImage(hyperlink) {
        let extension = ImageCollector.getExtensionFromUrlFilename(hyperlink);
        return extension === "png" ||
        extension === "jpg" ||
        extension === "jpeg" ||
        extension === "gif" ||
        extension === "svg";
    }

    /** @private */
    static getExtensionFromUrlFilename(hyperlink) {
        let split = util.extractFilename(hyperlink).split(".");
        return (split.length < 2) ? "" : split[split.length - 1];
    }

    /** @private */
    static linkContainsImageTag(hyperlink) {
        return (hyperlink.querySelector("img") !== null);
    }

    /** @private */
    static replaceHyperlinkWithImg(hyperlink) {
        let img = hyperlink.ownerDocument.createElement("img");
        img.src = hyperlink.href;
        hyperlink.replaceWith(img);
    }
}

//==============================================================

class VariableSizeImageCollector extends ImageCollector { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    onUserPreferencesUpdate(userPreferences) {
        super.onUserPreferencesUpdate(userPreferences);
        if (userPreferences.highestResolutionImages.value) {
            this.initialUrlToTry = (imageInfo) => imageInfo.wrappingUrl;
        } else {
            this.initialUrlToTry = (imageInfo) => imageInfo.sourceUrl;
        }
    }
}

//==============================================================

/** Class to replace an <img> tag. _/
class ImageTagReplacer {
    /_*
     * Record details of element to replace
     *@param {element} wrappingElement the outermost parent element of the <img> tag to remove.
     * @param {string} wrappingUrl url of image being replaced
     *@param {userPreferences} userPreferences - user's configuration options
     */
    constructor(wrappingElement, wrappingUrl, userPreferences) {
        this.wrappingElement = wrappingElement;
        this.wrappingUrl = wrappingUrl;
        this.userPreferences = userPreferences;
    }

    /**
     * @param {imageInfo} imageInfo to use to construct replacement tag
     */
    replaceTag(imageInfo) {
        // replace tag with nested <img> tag, with new <img> tag
        let parent = this.wrappingElement.parentElement;
        if ((imageInfo != null) && (parent != null)) {
            if (this.isDuplicateImageToRemove(imageInfo)) {
                this.wrappingElement.remove();
            } else {
                this.insertImageInLegalParent(parent, imageInfo);
            }
        }
    }

    /** @private */
    insertImageInLegalParent(parent, imageInfo) {
        if (this.isImageInline(imageInfo)) {
            this.insertInlineImageInLegalParent(imageInfo);
        } else {
            this.insertBlockImageInLegalParent(parent, imageInfo);
        }
    }

    /** @private */
    isImageInline(imageInfo) {
        const MAX_INLINE_IMAGE_HEIGHT = 200;
        let parent = this.wrappingElement;
        while ((parent != null) && util.isInlineElement(parent)) {
            parent = parent.parentNode;
        }
        return this.isParagraph(parent) &&
            !util.isNullOrEmpty(parent.textContent) &&
            (imageInfo.height <= MAX_INLINE_IMAGE_HEIGHT);
    }

    /** @private */
    isParagraph(element) {
        return (element != null) && (element.tagName.toLowerCase() === "p");
    }

    /** @private */
    insertInlineImageInLegalParent(imageInfo) {
        let newImage = imageInfo.createImgImageElement("span");
        this.wrappingElement.replaceWith(newImage);
    }

    /** @private */
    insertBlockImageInLegalParent(parent, imageInfo) {
        // Under XHTML, <div> not allowed to be a child of a <p> element, (or <i>, <u>, <s> etc.)
        let nodeAfter = this.wrappingElement;
        while (util.isInlineElement(parent) && (parent.parentNode != null)) {
            nodeAfter = parent;
            parent = parent.parentNode;
        }
        if (this.isParagraph(parent)) {
            nodeAfter = parent;
        }
        let newImage = imageInfo.createImageElement(this.userPreferences);
        nodeAfter.parentNode.insertBefore(newImage, nodeAfter);
        util.removeHeightAndWidthStyleFromParents(newImage);
        this.copyCaption(newImage, this.wrappingElement);
        this.wrappingElement.remove();
    }

    copyCaption(newImage, oldWrapper) {
        let thumbCaption = oldWrapper.querySelector("div.thumbcaption");
        if (thumbCaption != null) {
            for (let magnify of thumbCaption.querySelectorAll("div.magnify")) {
                magnify.remove();
            }
            if (!util.isNullOrEmpty(thumbCaption.textContent)) {
                newImage.appendChild(thumbCaption);
            }
        }
    }

    /**
     * @private
     */
    isDuplicateImageToRemove(imageInfo) {
        return this.userPreferences.removeDuplicateImages.value && 
            this.isElementInImageGallery() && (imageInfo.isOutsideGallery || imageInfo.isCover);
    }

    /**
     * @private
     */
    isElementInImageGallery() {
        return (this.wrappingElement.className === "thumb");
    }
}

================================================
FILE: plugin/js/Imgur.js
================================================

/*
  This holds code for transforming an imgur gallery into content image collector can handle
*/
"use strict";

class Imgur { // eslint-disable-line no-unused-vars
    constructor() {
    }

    static expandGalleries(content, parentPageUrl) {
        let sequence = Promise.resolve();
        for (let link of Imgur.getGalleryLinksToReplace(content)) {
            sequence = sequence.then(() => {
                let href = Imgur.fixupImgurGalleryUrl(link.href);
                return HttpClient.wrapFetch(href).then((xhr) => {
                    Imgur.replaceGalleryHyperlinkWithImages(link, xhr.responseXML);
                    return Promise.resolve();
                }).catch((err) => {
                    let errorMsg = UIText.Error.imgurFetchFailed(link.href, parentPageUrl, err);
                    ErrorLog.log(errorMsg);
                    return Promise.resolve();
                });
            });
        }
        sequence = sequence.then(() => {
            return Promise.resolve(content);
        });
        return sequence; 
    }

    static isImgurGallery(dom) {
        let host = util.extractHostName(dom.baseURI).toLowerCase();
        return Imgur.isImgurHostName(host);
    }

    static isImgurHostName(host) {
        return (host === "imgur.com") || (host.endsWith(".imgur.com"));
    }

    static convertGalleryToConventionalForm(dom) {
        let imagesList = Imgur.findImagesList(dom);
        return (imagesList == null) ? null : Imgur.constructStandardHtmForImgur(imagesList);
    }

    static constructStandardHtmForImgur(imagesList) {
        let doc = document.implementation.createHTMLDocument();
        let div = doc.createElement("div");
        doc.body.appendChild(div);
        for (let item of imagesList) {
            let img = doc.createElement("img");
            // ToDo: use real image to build URI
            img.src = "http://i.imgur.com/" + item.hash + item.ext;
            div.appendChild(img);
        }
        return div;
    }

    static findImagesList(dom) {
        let json = Imgur.findImagesJson(dom);
        if (json != null) {
            if (json.album_images != null) {
                return json.album_images.images;
            } else {
                return [ json ];
            }
        }
    }

    static findImagesJson(dom) {
        // Ugly hack, need to find the list of images as image links are created dynamically in HTML.
        // Obviously this will break each time imgur change their scripts.
        for (let text of Imgur.scriptsWithRunSlots(dom)) {
            let json = util.locateAndExtractJson(text, "item:");
            if (json != null) {
                return json;
            }
        }
        return null;
    }

    static scriptsWithRunSlots(dom) {
        return [...dom.querySelectorAll("script")]
            .map(s => s.innerHTML)
            .filter(i => (0 <= i.indexOf("window.runSlots")));
    }

    static isHyperlinkToImgurGallery(hyperlink) {
        return Imgur.isImgurHostName(hyperlink.hostname)
          && !ImageCollector.linkContainsImageTag(hyperlink)
          && Imgur.isLinkToGallery(hyperlink);
    }

    /** @private 
     * Hack, assume if no extension, it's a gallery
    */
    static isLinkToGallery(hyperlink) {
        return !util.extractFilename(hyperlink).includes(".");
    }

    static replaceGalleryHyperlinkWithImages(link, galleryDom) {
        if (Imgur.isImgurGallery(galleryDom)) {
            let images =  Imgur.convertGalleryToConventionalForm(galleryDom);
            link.replaceWith(images);
        }       
    }

    static getGalleryLinksToReplace(dom) {
        return util.getElements(dom, "a", Imgur.isHyperlinkToImgurGallery);
    }

    static fixupImgurGalleryUrl(url) {
        let link = document.createElement("a");
        link.href = url;
        if (Imgur.isHyperlinkToImgurGallery(link) && !url.endsWith("?grid")) {
            return url + "?grid";
        }
        return url;
    }
}

================================================
FILE: plugin/js/main.js
================================================

/*
    Main processing handler for popup.html

*/
var main = (function() {
    "use strict";

    // this will be called when message listener fires
    function onMessageListener(message, sender, sendResponse) {  // eslint-disable-line no-unused-vars
        if (message.messageType == "ParseResults") {
            chrome.runtime.onMessage.removeListener(onMessageListener);
            util.log("addListener");
            util.log(message);
            // convert the string returned from content script back into a DOM
            let dom = new DOMParser().parseFromString(message.document, "text/html");
            populateControlsWithDom(message.url, dom);
        }
    }

    // details 
    let initialWebPage = null;
    let parser = null;
    let userPreferences = null;
    let library = new Library; 

    // register listener that is invoked when script injected into HTML sends its results
    function addMessageListener() {
        try {
            // note, this will throw if not running as an extension.
            if (!chrome.runtime.onMessage.hasListener(onMessageListener)) {
                chrome.runtime.onMessage.addListener(onMessageListener);
            }
        } catch (chromeError) {
            util.log(chromeError);
        }
    }

    // extract urls from DOM and populate control
    async function processInitialHtml(url, dom) {
        if (setParser(url, dom)) {
            try {
                userPreferences.addObserver(parser);
            } catch (error) {
                ErrorLog.showErrorMessage(error);
                return;
            }
            try {
                await parser.loadEpubMetaInfo(dom);
                let metaInfo = parser.getEpubMetaInfo(dom, userPreferences.useFullTitle.value);
                populateMetaInfo(metaInfo);
                setUiToDefaultState();
                parser.populateUI(dom);
            } catch (error) {
                ErrorLog.showErrorMessage(error);
            }
            try {
                await parser.onLoadFirstPage(url, dom);
            } catch (error) {
                ErrorLog.showErrorMessage(error);
            }
        }
    }

    function setUiToDefaultState() {
        document.getElementById("highestResolutionImagesRow").hidden = true;
        document.getElementById("unSuperScriptAlternateTranslations").hidden = true; 
        document.getElementById("imageSection").hidden = true;
        document.getElementById("outputSection").hidden = false;
        document.getElementById("translatorRow").hidden = true;
        document.getElementById("fileAuthorAsRow").hidden = true;
        document.getElementById("defaultParserSection").hidden = true;
    }

    function populateMetaInfo(metaInfo) {
        setUiFieldToValue("startingUrlInput", metaInfo.uuid);
        setUiFieldToValue("titleInput", metaInfo.title);
        setUiFieldToValue("authorInput", metaInfo.author);
        setUiFieldToValue("languageInput", metaInfo.language);
        setUiFieldToValue("fileNameInput", metaInfo.fileName);
        setUiFieldToValue("subjectInput", metaInfo.subject);
        setUiFieldToValue("descriptionInput", metaInfo.description);
        if (metaInfo.seriesName !== null) {
            document.getElementById("seriesRow").hidden = false;
            document.getElementById("volumeRow").hidden = false;
            setUiFieldToValue("seriesNameInput", metaInfo.seriesName);
            setUiFieldToValue("seriesIndexInput", metaInfo.seriesIndex);
        }

        setUiFieldToValue("translatorInput", metaInfo.translator);
        setUiFieldToValue("fileAuthorAsInput", metaInfo.fileAuthorAs);
    }

    function setUiFieldToValue(elementId, value) {
        let element = document.getElementById(elementId);
        if (util.isTextInputField(element) || util.isTextAreaField(element)) {
            element.value = (value == null) ? "" : value;
        } else {
            throw new Error(UIText.Error.unhandledFieldTypeError);
        }
    }

    function metaInfoFromControls() {
        let metaInfo = new EpubMetaInfo();
        metaInfo.uuid = getValueFromUiField("startingUrlInput");
        metaInfo.title = getValueFromUiField("titleInput");
        metaInfo.author = getValueFromUiField("authorInput");
        metaInfo.language = getValueFromUiField("languageInput");
        metaInfo.fileName = getValueFromUiField("fileNameInput");
        metaInfo.subject = getValueFromUiField("subjectInput");
        metaInfo.description = getValueFromUiField("descriptionInput");

        if (document.getElementById("seriesRow").hidden === false) {
            metaInfo.seriesName = getValueFromUiField("seriesNameInput");
            metaInfo.seriesIndex = getValueFromUiField("seriesIndexInput");
        }

        metaInfo.translator = getValueFromUiField("translatorInput");
        metaInfo.fileAuthorAs = getValueFromUiField("fileAuthorAsInput");
        metaInfo.styleSheet = userPreferences.styleSheet.value;

        return metaInfo;
    }

    function getValueFromUiField(elementId) {
        let element = document.getElementById(elementId);
        if (util.isTextInputField(element) || util.isTextAreaField(element)) {
            return (element.value === "") ? null : element.value;
        } else {
            throw new Error(UIText.Error.unhandledFieldTypeError);
        }
    }

    async function fetchContentAndPackEpub() {
        let libclick = this;
        if (document.getElementById("noAdditionalMetadataCheckbox").checked == true) {
            setUiFieldToValue("subjectInput", "");
            setUiFieldToValue("descriptionInput", "");
        }
        let metaInfo = metaInfoFromControls();

        if ("yes" == libclick.dataset.libclick) {
            if (document.getElementById("chaptersPageInChapterListCheckbox").checked) {
                ErrorLog.showErrorMessage(UIText.Error.errorAddToLibraryLibraryAddPageWithChapters);
                return;
            }
        }

        ChapterUrlsUI.limitNumOfChapterS(userPreferences.maxChaptersPerEpub.value);
        ChapterUrlsUI.resetDownloadStateImages();
        ErrorLog.clearHistory();
        window.workInProgress = true;
        main.getPackEpubButton().disabled = true;
        replaceLibAddToLibrary();
        parser.onStartCollecting();
        await parser.fetchContent().then(() => {
            return packEpub(metaInfo);
        }).then((content) => {
            // Enable button here.  If user cancels save dialog
            // the promise never returns
            window.workInProgress = false;
            main.getPackEpubButton().disabled = false;
            replaceLibAddToLibrary();
            let overwriteExisting = userPreferences.overwriteExistingEpub.value;
            let backgroundDownload = userPreferences.noDownloadPopup.value;
            let fileName = Download.CustomFilename();
            if ("yes" == libclick.dataset.libclick || util.sleepController.signal.aborted) {
                return library.LibAddToLibrary(content, fileName, document.getElementById("startingUrlInput").value, overwriteExisting, backgroundDownload);
            }
            return Download.save(content, fileName, overwriteExisting, backgroundDownload);
        }).then(() => {
            parser.updateReadingList();
            if (util.sleepController.signal.aborted) {
                util.sleepController = new AbortController;
                resetUI();
            }
            if (libclick.dataset.libsuppressErrorLog == true) {
                return;
            } else {
                ErrorLog.showLogToUser();
                dumpErrorLogToFile();
            }
        }).catch((err) => {
            window.workInProgress = false;
            main.getPackEpubButton().disabled = false;
            if (util.sleepController.signal.aborted) {
                util.sleepController = new AbortController;
            }
            replaceLibAddToLibrary();
            ErrorLog.showErrorMessage(err);
        });
    }

    function replaceLibAddToLibrary() {
        let el = document.getElementById("LibAddToLibrary");
        el.hidden = !el.hidden;
        el = document.getElementById("LibPauseToLibrary");
        el.hidden = !el.hidden;
    }

    function pauseToLibrary() {
        util.sleepController.abort();
    }

    function epubVersionFromPreferences() {
        return userPreferences.createEpub3.value ? 
            EpubPacker.EPUB_VERSION_3 : EpubPacker.EPUB_VERSION_2;
    }

    function packEpub(metaInfo) {
        let epubVersion = epubVersionFromPreferences();
        let epub = new EpubPacker(metaInfo, epubVersion);
        return epub.assemble(parser.epubItemSupplier());
    }

    function dumpErrorLogToFile() {
        let errors = ErrorLog.dumpHistory();
        if (userPreferences.writeErrorHistoryToFile.value &&
            !util.isNullOrEmpty(errors)) {
            let fileName = metaInfoFromControls().fileName + ".ErrorLog.txt";
            let blob = new Blob([errors], {type : "text"});
            return Download.save(blob, fileName)
                .catch (err => ErrorLog.showErrorMessage(err));
        }
    }

    function getActiveTabDOM(tabId) {
        addMessageListener();
        injectContentScript(tabId);
    }

    function injectContentScript(tabId) {
        if (util.isFirefox()) {
            Firefox.injectContentScript(tabId);
        } else {
            chromeInjectContentScript(tabId);
        }
    }

    function chromeInjectContentScript(tabId) {
        try {
            chrome.scripting.executeScript({
                target: {tabId: tabId},
                files: ["js/ContentScript.js"]
            });
        } catch {
            if (chrome.runtime.lastError) {
                util.log(chrome.runtime.lastError.message);
            }
        }
    }

    function populateControls() {
        loadUserPreferences();
        parserFactory.populateManualParserSelectionTag(getManuallySelectParserTag());
        configureForTabMode();
    }

    function loadUserPreferences() {
        userPreferences = UserPreferences.readFromLocalStorage();
        userPreferences.addObserver(library);
        userPreferences.writeToUi();
        userPreferences.hookupUi();
        BakaTsukiSeriesPageParser.registerBakaParsers(userPreferences.autoSelectBTSeriesPage.value);
    }

    function isRunningInTabMode() {
        // if query string supplied, we're running in Tab mode.
        let search = window.location.search;
        return !util.isNullOrEmpty(search);
    }

    async function populateControlsWithDom(url, dom) {
        initialWebPage = dom;
        setUiFieldToValue("startingUrlInput", url);

        // set the base tag, in case server did not supply it 
        util.setBaseTag(url, initialWebPage);
        await processInitialHtml(url, initialWebPage);
        if (document.getElementById("autosearchmetadataCheckbox").checked == true) {
            autosearchadditionalmetadata();
        }
    }

    function setParser(url, dom) {
        let manualSelect = getManuallySelectParserTag().value;
        if (util.isNullOrEmpty(manualSelect)) {
            parser = parserFactory.fetch(url, dom);
        } else {
            parser = parserFactory.manuallySelectParser(manualSelect);
        }
        if (parser === undefined) {
            ErrorLog.showErrorMessage(UIText.Error.noParserFound);
            return false;
        }
        getLoadAndAnalyseButton().hidden = true;
        let disabledMessage = parser.disabled();
        if (disabledMessage !== null) {
            ErrorLog.showErrorMessage(disabledMessage);
            return false;
        }
        return true;
    }

    // called when the "Diagnostics" check box is ticked or unticked
    function onDiagnosticsClick() {
        let enable = document.getElementById("diagnosticsCheckBoxInput").checked;
        document.getElementById("reloadButton").hidden = !enable;
    }

    function onAdvancedOptionsClick() {
        let section =  getAdvancedOptionsSection();
        section.hidden = !section.hidden;
        section = getAdditionalMetadataSection();
        section.hidden = !userPreferences.ShowMoreMetadataOptions.value;
        section =  getLibrarySection();
        section.hidden = true;
    }

    function onShowMoreMetadataOptionsClick() {
        let section = getAdditionalMetadataSection();
        section.hidden = !section.hidden;
    }

    function onLibraryClick() {
        let section =  getLibrarySection();
        section.hidden = !section.hidden;
        if (!section.hidden) {
            Library.LibRenderSavedEpubs();
        }
        section =  getAdvancedOptionsSection();
        section.hidden = true;
    }

    function onStylesheetToDefaultClick() {
        document.getElementById("stylesheetInput").value = EpubMetaInfo.getDefaultStyleSheet();
        userPreferences.readFromUi();
    }

    function openTabWindow() {
        // open new tab window, passing ID of open tab with content to convert to epub as query parameter.
        getActiveTab().then((tabId) => {
            let url = chrome.runtime.getURL("popup.html") + "?id=";
            url += tabId;
            try {
                chrome.tabs.create({ url: url, openerTabId: tabId });
            }
            catch (err) {
                //firefox android catch
                chrome.tabs.create({ url: url});
            }
            window.close();
        });
    }

    function getActiveTab() {
        return new Promise((resolve, reject) => {
            chrome.tabs.query({ currentWindow: true, active: true }, (tabs) => {
                if ((tabs != null) && (0 < tabs.length)) {
                    resolve(tabs[0].id);
                } else {
                    reject();
                }
            });
        });
    }

    async function onLoadAndAnalyseButtonClick() {
        // load page via XmlHTTPRequest
        let url = getValueFromUiField("startingUrlInput");
        getLoadAndAnalyseButton().disabled = true;
        return HttpClient.wrapFetch(url).then(async (xhr) => {
            await populateControlsWithDom(url, xhr.responseXML);
            getLoadAndAnalyseButton().disabled = false;
        }).catch((error) => {
            getLoadAndAnalyseButton().disabled = false;
            ErrorLog.showErrorMessage(error);
        });
    }

    function configureForTabMode() {
        getActiveTabDOM(extractTabIdFromQueryParameter());
    }

    function extractTabIdFromQueryParameter() {
        let windowId = window.location.search.split("=")[1];
        if (!util.isNullOrEmpty(windowId)) {
            return parseInt(windowId, 10);
        }
    }

    function getPackEpubButton() {
        return document.getElementById("packEpubButton");
    }

    function getLoadAndAnalyseButton() {
        return document.getElementById("loadAndAnalyseButton");
    }

    function resetUI() {
        initialWebPage = null;
        parser = null;
        let metaInfo = new EpubMetaInfo();
        metaInfo.uuid = "";
        populateMetaInfo(metaInfo);
        getLoadAndAnalyseButton().hidden = false;
        main.getPackEpubButton().disabled = false;
        document.getElementById("LibAddToLibrary").disabled = false;
        document.getElementById("LibAddToLibrary").hidden = false;
        document.getElementById("LibPauseToLibrary").hidden = true;
        ChapterUrlsUI.clearChapterUrlsTable();
        CoverImageUI.clearUI();
        ProgressBar.setValue(0);
        // Clear the selected value so it doesn't look like a parser is selected
        document.getElementById("manuallySelectParserTag").selectedIndex = -1;
    }

    function localizeHtmlPage() {
        // can't use a single select, because there are buttons in td elements
        for (let selector of ["button, option", "td, th", ".i18n"]) {
            for (let element of [...document.querySelectorAll(selector)]) {
                if (element.textContent.startsWith("__MSG_")) {
                    UIText.localizeElement(element);
                }
            }
        }
    }

    function clearCoverUrl() {
        CoverImageUI.setCoverImageUrl(null);
    }

    function getManuallySelectParserTag() {
        return document.getElementById("manuallySelectParserTag");
    }

    function getAdditionalMetadataSection() {
        return document.getElementById("AdditionalMetadatatable");
    }

    function getAdvancedOptionsSection() {
        return document.getElementById("advancedOptionsSection");
    }

    function getLibrarySection() {
        return document.getElementById("hiddenBibSection");
    }

    function onSeriesPageHelp() {
        chrome.tabs.create({ url: "https://github.com/dteviot/WebToEpub/wiki/FAQ#using-baka-tsuki-series-page-parser" });
    }

    function onCustomFilenameHelp() {
        chrome.tabs.create({ url: "https://github.com/dteviot/WebToEpub/wiki/Advanced-Options#custom-filename" });
    }

    function onDefaultParserHelp() {
        chrome.tabs.create({ url: "https://github.com/dteviot/WebToEpub/wiki/FAQ#how-to-convert-a-new-site-using-the-default-parser" });
    }

    function onReadOptionsFromFile(event) {
        userPreferences.readFromFile(event, populateControls);
    }

    function onReadingListCheckboxClicked() {
        let url = parser.state.chapterListUrl;
        let checked = UserPreferences.getReadingListCheckbox().checked;
        userPreferences.readingList.onReadingListCheckboxClicked(checked, url);
    }

    function sbFiltersShow()
    {
        sbShow();
        ChapterUrlsUI.Filters.init();
        document.getElementById("sbFilters").hidden = false;
        
        let filtersForm = document.getElementById("sbFiltersForm");
        util.removeElements(filtersForm.children);
        filtersForm.appendChild(ChapterUrlsUI.Filters.generateFiltersTable());
        ChapterUrlsUI.Filters.Filter(); //Run reset filters to clear confusion.
    }

    function sbShow() {
        document.getElementById("sbOptions").classList.add("sidebarOpen");
    }

    function sbHide() {
        document.getElementById("sbOptions").classList.remove("sidebarOpen");
        document.getElementById("sbFilters").hidden = true;
    }

    function showReadingList() {
        let sections = new Map(
            [...document.querySelectorAll("section")]
                .map(s =>[s, s.hidden])
        );
        [...sections.keys()].forEach(s => s.hidden = true);

        document.getElementById("readingListSection").hidden = false;
        document.getElementById("closeReadingList").onclick = () => {
            [...sections].forEach(s => s[0].hidden = s[1]);
        };

        let table = document.getElementById("readingListTable");
        userPreferences.readingList.showReadingList(table);
        table.onclick = (event) => userPreferences.readingList.onClickRemove(event);
    }

    /**
     * If work in progress, give user chance to cancel closing the window
     */
    function onUnloadEvent(event) {
        if (window.workInProgress === true) {
            event.preventDefault();
            event.returnValue = "";
        } else {
            delete event["returnValue"];
        }
    }

    function addEventHandlers() {
        getPackEpubButton().onclick = fetchContentAndPackEpub;
        document.getElementById("diagnosticsCheckBoxInput").onclick = onDiagnosticsClick;
        document.getElementById("reloadButton").onclick = populateControls;
        getManuallySelectParserTag().onchange = populateControls;
        document.getElementById("advancedOptionsButton").onclick = onAdvancedOptionsClick;
        document.getElementById("hiddenBibButton").onclick = onLibraryClick;
        document.getElementById("ShowMoreMetadataOptionsCheckbox").addEventListener("change", () => onShowMoreMetadataOptionsClick());
        document.getElementById("LibShowAdvancedOptionsCheckbox").addEventListener("change", () => Library.LibRenderSavedEpubs());
        document.getElementById("LibAddToLibrary").addEventListener("click", fetchContentAndPackEpub);
        document.getElementById("LibPauseToLibrary").addEventListener("click", pauseToLibrary);
        document.getElementById("stylesheetToDefaultButton").onclick = onStylesheetToDefaultClick;
        document.getElementById("resetButton").onclick = resetUI;
        document.getElementById("clearCoverImageUrlButton").onclick = clearCoverUrl;
        document.getElementById("seriesPageHelpButton").onclick = onSeriesPageHelp;
        document.getElementById("CustomFilenameHelpButton").onclick = onCustomFilenameHelp;
        document.getElementById("defaultParserHelpButton").onclick = onDefaultParserHelp;
        getLoadAndAnalyseButton().onclick = onLoadAndAnalyseButtonClick;
        document.getElementById("loadMetadataButton").onclick = onLoadMetadataButtonClick;

        document.getElementById("writeOptionsButton").onclick = () => userPreferences.writeToFile();
        document.getElementById("readOptionsInput").onchange = onReadOptionsFromFile;
        UserPreferences.getReadingListCheckbox().onclick = onReadingListCheckboxClicked;
        document.getElementById("viewFiltersButton").onclick = () => sbFiltersShow();
        document.getElementById("sbClose").onclick = () => sbHide();
        document.getElementById("viewReadingListButton").onclick = () => showReadingList();
        window.addEventListener("beforeunload", onUnloadEvent);
    }
 
 
    // Additional metadata
    function autosearchadditionalmetadata() {
        getPackEpubButton().disabled = true;
        document.getElementById("LibAddToLibrary").disabled = true;
        let titlename = getValueFromUiField("titleInput");
        let url ="https://www.novelupdates.com/series-finder/?sf=1&sh="+titlename;
        if (getValueFromUiField("subjectInput")==null) {
            autosearchnovelupdates(url, titlename);
        }   
        getPackEpubButton().disabled = false; 
        document.getElementById("LibAddToLibrary").disabled = false;    
    }
 
    function autosearchnovelupdates(url, titlename) {
        return HttpClient.wrapFetch(url).then((xhr) => {
            findnovelupdatesurl(url, xhr.responseXML, titlename);
        }).catch((error) => {
            getLoadAndAnalyseButton().disabled = false;
            ErrorLog.showErrorMessage(error);
        });
    }

    function findnovelupdatesurl(url, dom, titlename) {
        try {    
            let searchurl = [...dom.querySelectorAll("a")].filter(a => a.textContent==titlename)[0];
            setUiFieldToValue("metadataUrlInput", searchurl.href);
            url = getValueFromUiField("metadataUrlInput");
            if (url.includes("novelupdates.com") == true) {
                onLoadMetadataButtonClick();
            }
        } catch {
            //
        }
    }
 
    function onLoadMetadataButtonClick() {
        getPackEpubButton().disabled = true;
        document.getElementById("LibAddToLibrary").disabled = true;
        let url = getValueFromUiField("metadataUrlInput");
        return HttpClient.wrapFetch(url).then((xhr) => {
            populateMetadataAddWithDom(url, xhr.responseXML);
        }).catch((error) => {
            getLoadAndAnalyseButton().disabled = false;
            ErrorLog.showErrorMessage(error);
        });
    }

    function populateMetadataAddWithDom(url, dom) {
        try {
            let allTags = document.getElementById("lesstagsCheckbox").checked == false;
            let metaAddInfo = EpubMetaInfo.getEpubMetaAddInfo(dom, url, allTags);
            setUiFieldToValue("subjectInput", metaAddInfo.subject);
            setUiFieldToValue("descriptionInput", metaAddInfo.description);
            if (getValueFromUiField("authorInput")=="<unknown>") {
                setUiFieldToValue("authorInput", metaAddInfo.author);
            }
            getPackEpubButton().disabled = false;
            document.getElementById("LibAddToLibrary").disabled = false;
        } catch (error) {
            ErrorLog.showErrorMessage(error);
            getPackEpubButton().disabled = false;
            document.getElementById("LibAddToLibrary").disabled = false;
        }
    }

    // actions to do when window opened
    window.onload = () => {
        userPreferences = UserPreferences.readFromLocalStorage();
        if (isRunningInTabMode()) { 
            ErrorLog.SuppressErrorLog =  false;
            localizeHtmlPage();
            getAdvancedOptionsSection().hidden = !userPreferences.advancedOptionsVisibleByDefault.value;
            getAdditionalMetadataSection().hidden = !userPreferences.ShowMoreMetadataOptions.value;
            addEventHandlers();
            populateControls();
            if (util.isFirefox()) {
                Firefox.startWebRequestListeners();
            }
        } else {
            openTabWindow();
        }
    };

    return {
        getPackEpubButton: getPackEpubButton,
        onLoadAndAnalyseButtonClick : onLoadAndAnalyseButtonClick,
        fetchContentAndPackEpub: fetchContentAndPackEpub,
        resetUI: resetUI,
        getUserPreferences: () => userPreferences,
    };
})();

================================================
FILE: plugin/js/Parser.js
================================================

/*
  Base class that all parsers build from.
*/
"use strict";

/**

- For sites that have multiple chapters per web page, this can minimize HTTP calls
 */
class FetchCache { // eslint-disable-line no-unused-vars
    constructor() {
        this.path = null;
        this.dom = null;
    }

    async fetch(url) {
        if  (!this.inCache(url)) {
            this.dom = (await HttpClient.wrapFetch(url)).responseXML;
            this.path = new URL(url).pathname;
        }
        return this.dom.cloneNode(true);
    }

    inCache(url) {
        return (((new URL(url).pathname) === this.path)
        && (this.dom !== null));
    }
}

/**

- A Parser's state variables
*/
class ParserState {
    constructor() {
        this.webPages = new Map();
        this.chapterListUrl = null;
    }

    setPagesToFetch(urls) {
        let nextPrevChapters = new Set();
        this.webPages = new Map();
        for (let i = 0; i < urls.length; ++i) {
            let page = urls[i];
            if (i < urls.length - 1) {
                nextPrevChapters.add(util.normalizeUrlForCompare(urls[i + 1].sourceUrl));
            }
            page.nextPrevChapters = nextPrevChapters;
            this.webPages.set(page.sourceUrl, page);
            nextPrevChapters = new Set();
            nextPrevChapters.add(util.normalizeUrlForCompare(page.sourceUrl));
        }
    }
}

class Parser {
    constructor(imageCollector) {
        this.minimumThrottle = 500;
        this.maxSimultanousFetchSize = 1;
        this.state = new ParserState();
        this.imageCollector = imageCollector || new ImageCollector();
        this.userPreferences = null;
    }

    copyState(otherParser) {
        this.state = otherParser.state;
        this.imageCollector.copyState(otherParser.imageCollector);
        this.userPreferences = otherParser.userPreferences;
    }

    setPagesToFetch(urls) {
        this.state.setPagesToFetch(urls);
    }

    getPagesToFetch() {
        return this.state.webPages;
    }
    
    //Use this option if the parser isn't sending the correct HTTP header
    isCustomError(response) {  // eslint-disable-line no-unused-vars
        return false;
    }

    setCustomErrorResponse(url, wrapOptions, checkedresponse) {
        //example
        let ret = {};
        ret.url = url;
        ret.wrapOptions = wrapOptions;
        ret.response = {};
        //URL that's get opened on 'Open URL for Captcha' click
        ret.response.url = checkedresponse.response.url;
        ret.response.status = 403;
        //How often should it be retried and with how much delay in between
        ret.response.retryDelay = [80,40,20,10,5];
        ret.errorMessage = "This is a custom error message that will be displayed should all retries fail";
        //return empty to throw error
        return {};
    }

    onUserPreferencesUpdate(userPreferences) {
        this.userPreferences = userPreferences;
        this.imageCollector.onUserPreferencesUpdate(userPreferences);
    }

    isWebPagePackable(webPage) {
        return ((webPage.isIncludeable)
         && ((webPage.rawDom != null) || (webPage.error != null)));
    }

    convertRawDomToContent(webPage) {
        let content = this.findContent(webPage.rawDom);
        this.customRawDomToContentStep(webPage, content);
        util.decodeCloudflareProtectedEmails(content);
        if (this.userPreferences.removeNextAndPreviousChapterHyperlinks.value) {
            this.removeNextAndPreviousChapterHyperlinks(webPage, content);
        }
        this.removeUnwantedElementsFromContentElement(content);
        this.replaceWpBlockSpacersWithHR(content);
        this.addTitleToContent(webPage, content);
        util.fixBlockTagsNestedInInlineTags(content);
        this.imageCollector.replaceImageTags(content);
        util.removeUnusedHeadingLevels(content);
        util.makeHyperlinksRelative(webPage.rawDom.baseURI, content);
        util.setStyleToDefault(content);
        util.prepForConvertToXhtml(content);
        util.removeEmptyAttributes(content);
        util.removeSpansWithNoAttributes(content);
        util.removeEmptyDivElements(content);
        util.removeTrailingWhiteSpace(content);
        if (util.isElementWhiteSpace(content)) {
            let errorMsg = UIText.Warning.warningNoVisibleContent(webPage.sourceUrl);
            ErrorLog.showErrorMessage(errorMsg);
        }
        return content;
    }

    addTitleToContent(webPage, content) {
        let title = this.findChapterTitle(webPage.rawDom, webPage);
        if (title != null) {
            if (title instanceof HTMLElement) {
                title = title.textContent;
            }
            if (webPage.title == "[placeholder]") {
                webPage.title = title.trim();
            }
            if (!this.titleAlreadyPresent(title, content)) {
                let titleElement = webPage.rawDom.createElement("h1");
                titleElement.appendChild(webPage.rawDom.createTextNode(title.trim()));
                content.insertBefore(titleElement, content.firstChild);
            }
        } else {
            if (webPage.title == "[placeholder]") {
                webPage.title = webPage.rawDom.title;
            }
        }
    }

    titleAlreadyPresent(title, content) {
        let existingTitle = content.querySelector("h1, h2, h3, h4, h5, h6");
        return (existingTitle != null)
            && (title.trim() === existingTitle.textContent.trim());
    }

    /**
     * Element with title of an individual chapter
     * Override when chapter title not in content element
    */
    findChapterTitle(dom) {   // eslint-disable-line no-unused-vars
        return null;
    }

    replaceWpBlockSpacersWithHR(content) {
        [...content.querySelectorAll("div.wp-block-spacer")].forEach(
            e => e.replaceWith(content.ownerDocument.createElement("hr"))
        );
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeScriptableElements(element);
        util.removeComments(element);
        util.removeElements(element.querySelectorAll("noscript, input"));
        util.removeUnwantedWordpressElements(element);
        util.removeMicrosoftWordCrapElements(element);
        util.removeShareLinkElements(element);
        util.removeLeadingWhiteSpace(element);
    }

    customRawDomToContentStep(chapter, content) { // eslint-disable-line no-unused-vars
        // override for any custom processing
    }

    populateUI(dom) {
        CoverImageUI.showCoverImageUrlInput(true);
        let coverUrl = this.findCoverImageUrl(dom);
        CoverImageUI.setCoverImageUrl(coverUrl);
        this.populateUIImpl();
    }

    populateUIImpl() {
        // default implementation is do nothing more
    }

    /**
     * Default implementation, take first image in content section
    */
    findCoverImageUrl(dom) {
        if (dom != null) {
            let content = this.findContent(dom);
            if (content != null) {
                let cover = content.querySelector("img");
                if (cover != null) {
                    return cover.src;
                }
            }
        }
        return null;
    }

    removeNextAndPreviousChapterHyperlinks(webPage, element) {
        let elementToRemove = (this.findParentNodeOfChapterLinkToRemoveAt != null) ?
            this.findParentNodeOfChapterLinkToRemoveAt.bind(this)
            : (element) => element;

        let chapterLinks = [...element.querySelectorAll("a")]
            .filter(link => webPage.nextPrevChapters.has(util.normalizeUrlForCompare(link.href)))
            .map(link => elementToRemove(link));
        util.removeElements(chapterLinks);
    }

    /**
    * default implementation turns each webPage into single epub item
    */
    webPageToEpubItems(webPage, epubItemIndex) {
        let content = this.convertRawDomToContent(webPage);
        let items = [];
        if (content != null) {
            items.push(new ChapterEpubItem(webPage, content, epubItemIndex));
        }
        return items;
    }

    makePlaceholderEpubItem(webPage, epubItemIndex) {
        let temp = Parser.makeEmptyDocForContent(webPage.sourceUrl);
        temp.content.textContent = UIText.Default.chapterPlaceholderMessage(webPage.sourceUrl, webPage.error);
        util.convertPreTagToPTags(temp.dom, temp.content);
        return [new ChapterEpubItem(webPage, temp.content, epubItemIndex)];
    }

    /**
    * default implementation
    */
    static extractTitleDefault(dom) {
        let title = dom.querySelector("meta[property='og:title']");
        return (title === null) ? dom.title : title.getAttribute("content");
    }

    extractTitleImpl(dom) {
        return Parser.extractTitleDefault(dom);
    }

    extractTitle(dom) {
        let title = this.extractTitleImpl(dom);
        if (title == null) {
            title = Parser.extractTitleDefault(dom);
        }
        if (title.textContent !== undefined) {
            title = title.textContent;
        }
        return title.trim();
    }

    /**
    * default implementation
    */
    extractAuthor(dom) {  // eslint-disable-line no-unused-vars
        return "<unknown>";
    }

    /**
    * default implementation, 
    * if not available, default to English
    */
    extractLanguage(dom) {
        // try jetpack tag
        let locale = dom.querySelector("meta[property='og:locale']");
        if (locale !== null) {
            return locale.getAttribute("content");
        }

        // try <html>'s lang attribute
        locale = dom.querySelector("html").getAttribute("lang");
        return (locale === null) ? "en" : locale;
    }

    /**
    * default implementation, 
    * if not available, return ''
    */
    extractSubject(dom) {   // eslint-disable-line no-unused-vars
        return "";
    }

    extractDescription(dom) {
        let infoDiv = document.createElement("div");
        if (this.getInformationEpubItemChildNodes !== undefined)
        {
            this.populateInfoDiv(infoDiv, dom);
        }
        return infoDiv.textContent;
    }

    /**
    * default implementation, Derived classes will override
    */
    extractSeriesInfo(dom, metaInfo) {  // eslint-disable-line no-unused-vars
    }

    async loadEpubMetaInfo(dom) {  // eslint-disable-line no-unused-vars
        return;
    }

    getEpubMetaInfo(dom, useFullTitle) {
        let metaInfo = new EpubMetaInfo();
        metaInfo.uuid = dom.baseURI;
        try {
            metaInfo.title = this.extractTitle(dom);
        }
        catch (err) {
            metaInfo.title = "";
        }
        try {
            metaInfo.author = this.extractAuthor(dom).trim();
        }
        catch (err) {
            metaInfo.author = "";
        }
        try {
            metaInfo.language = this.extractLanguage(dom);
        }
        catch (err) {
            metaInfo.language = "";
        }
        try {
            metaInfo.fileName = this.makeSaveAsFileNameWithoutExtension(metaInfo.title, useFullTitle);
        }
        catch (err) {
            metaInfo.fileName = "web.epub";
        }
        try {
            metaInfo.subject = this.extractSubject(dom);
        }
        catch (err) {
            metaInfo.subject = "";
        }
        try {
            metaInfo.description = this.extractDescription(dom);
        }
        catch (err) {
            metaInfo.description = "";
        }
        this.extractSeriesInfo(dom, metaInfo);
        return metaInfo;
    }

    singleChapterStory(baseUrl, dom) {
        return [{
            sourceUrl: baseUrl,
            title: this.extractTitle(dom)
        }];
    }

    getBaseUrl(dom) {
        return Array.from(dom.getElementsByTagName("base"))[0].href;
    }

    makeSaveAsFileNameWithoutExtension(title, useFullTitle) {
        let maxFileNameLength = useFullTitle ? 512 : 20;
        let fileName = (title == null)  ? "web" : util.safeForFileName(title, maxFileNameLength);
        if (util.isStringWhiteSpace(fileName)) {
            // title is probably not English, so just use it as is
            fileName = title;
        }
        return fileName;
    }

    epubItemSupplier() {
        let epubItems = this.webPagesToEpubItems([...this.state.webPages.values()]);
        this.fixupHyperlinksInEpubItems(epubItems);
        return new EpubItemSupplier(this, epubItems, this.imageCollector);
    }

    webPagesToEpubItems(webPages) {
        let epubItems = [];
        let index = 0;

        if (this.userPreferences.addInformationPage.value &&
            this.getInformationEpubItemChildNodes !== undefined) {
            epubItems.push(this.makeInformationEpubItem(this.state.firstPageDom));
            ++index;
        }

        for (let webPage of webPages.filter(c => this.isWebPagePackable(c))) {
            let newItems = (webPage.error == null)
                ? webPage.parser.webPageToEpubItems(webPage, index)
                : this.makePlaceholderEpubItem(webPage, index);
            epubItems = epubItems.concat(newItems);
            index += newItems.length;
            delete(webPage.rawDom);
        }
        return epubItems;
    }

    makeInformationEpubItem(dom) {
        let titleText = UIText.Default.informationPageTitle;
        let title = document.createElement("h1");
        title.appendChild(document.createTextNode(titleText));
        let div = document.createElement("div");
        let urlElement = document.createElement("p");
        let bold = document.createElement("b");
        bold.textContent = UIText.Default.tableOfContentsUrl;
        urlElement.appendChild(bold);
        urlElement.appendChild(document.createTextNode(this.state.chapterListUrl));
        div.appendChild(urlElement);
        let infoDiv = document.createElement("div");
        this.populateInfoDiv(infoDiv, dom);    
        let childNodes = [title, div, infoDiv];
        let chapter = {
            sourceUrl: this.state.chapterListUrl,
            title: titleText,
            newArch: null
        };
        return new ChapterEpubItem(chapter, {childNodes: childNodes}, 0);
    }

    populateInfoDiv(infoDiv, dom) {
        for (let n of this.getInformationEpubItemChildNodes(dom).filter(n => n != null)) {
            let clone = util.sanitizeNode(n);
            if (clone) {
                this.cleanInformationNode(clone);
            }
            if (clone != null) {
                infoDiv.appendChild(clone);
            }
        }
        // this "page" doesn't go through image collector, so strip images
        util.removeChildElementsMatchingSelector(infoDiv, "img");
    }

    cleanInformationNode(node) {     // eslint-disable-line no-unused-vars
        // do nothing, derived class overrides as required
    }

    // called when plugin has obtained the first web page
    async onLoadFirstPage(url, firstPageDom) {
        this.state.firstPageDom = firstPageDom;
        this.state.chapterListUrl = url;
        let chapterUrlsUI = new ChapterUrlsUI(this);
        this.userPreferences.setReadingListCheckbox(url);

        try {
            let chapters = await this.getChapterUrls(firstPageDom, chapterUrlsUI);
            if (this.userPreferences.chaptersPageInChapterList.value) {
                chapters = this.addFirstPageUrlToWebPages(url, firstPageDom, chapters);
            }
            chapters = this.cleanWebPageUrls(chapters);
            chapters?.forEach(chapter => chapter.title = chapter.title?.trim());
            await this.userPreferences.readingList.deselectOldChapters(url, chapters);
            chapterUrlsUI.populateChapterUrlsTable(chapters);
            if (0 < chapters.length) {
                if (chapters[0].sourceUrl === url) {
                    chapters[0].rawDom = firstPageDom;
                    this.updateLoadState(chapters[0]);
                }
                ProgressBar.setValue(0);
            }
            this.state.setPagesToFetch(chapters);
            chapterUrlsUI.connectButtonHandlers();
        } catch (err) {
            ErrorLog.showErrorMessage(err);
        }
    }

    cleanWebPageUrls(webPages) {
        let foundUrls = new Set();
        let isUnique = function(webPage) {
            let unique = !foundUrls.has(webPage.sourceUrl);
            if (unique) {
                foundUrls.add(webPage.sourceUrl);
            }
            return unique;
        };

        return webPages
            .map(this.fixupImgurGalleryUrl)
            .filter(p => util.isUrl(p.sourceUrl))
            .filter(isUnique);
    }

    fixupImgurGalleryUrl(webPage) {
        webPage.sourceUrl = Imgur.fixupImgurGalleryUrl(webPage.sourceUrl);
        return webPage;
    }

    addFirstPageUrlToWebPages(url, firstPageDom, webPages) {
        let present = webPages.find(e => e.sourceUrl === url);
        if (present)
        {
            return webPages;
        } else {
            return [{
                sourceUrl:  url,
                title: this.extractTitle(firstPageDom)
            }].concat(webPages);
        }
    }

    onFetchChaptersClicked() {
        if (0 == this.state.webPages.size) {
            ErrorLog.showErrorMessage(UIText.Error.noChaptersFoundAndFetchClicked);
        } else {
            this.fetchWebPages();
        }
    }

    fetchContent() {
        return this.fetchWebPages();
    }

    setUiToShowLoadingProgress(length) {
        main.getPackEpubButton().disabled = true;
        ProgressBar.setMax(length + 1);
        ProgressBar.setValue(1);
    }

    async fetchWebPages() {
        let pagesToFetch = [...this.state.webPages.values()].filter(c => c.isIncludeable);
        if (pagesToFetch.length === 0) {
            return Promise.reject(new Error("No chapters found."));
        }

        this.setUiToShowLoadingProgress(pagesToFetch.length);

        this.imageCollector.reset();
        this.imageCollector.setCoverImageUrl(CoverImageUI.getCoverImageUrl());

        await this.addParsersToPages(pagesToFetch);
        let index = 0;
        try
        {
            let group = this.groupPagesToFetch(pagesToFetch, index);
            while (0 < group.length) {
                await Promise.all(group.map(async (webPage) => this.fetchWebPageContent(webPage)));
                index += group.length;
                group = this.groupPagesToFetch(pagesToFetch, index);
                if (util.sleepController.signal.aborted) {
                    break;
                }
            }
        }
        catch (err)
        {
            ErrorLog.log(err);
        }
    }

    async addParsersToPages(pagesToFetch) {
        parserFactory.addParsersToPages(this, pagesToFetch);
    }

    groupPagesToFetch(webPages, index) {
        return webPages.slice(index, index + this.maxSimultanousFetchSize);
    }

    async fetchWebPageContent(webPage) {
        ChapterUrlsUI.showDownloadState(webPage.row, ChapterUrlsUI.DOWNLOAD_STATE_SLEEPING);
        await this.rateLimitDelay();
        ChapterUrlsUI.showDownloadState(webPage.row, ChapterUrlsUI.DOWNLOAD_STATE_DOWNLOADING);
        let pageParser = webPage.parser;
        try {
            let webPageDom = await pageParser.fetchChapter(webPage.sourceUrl);
            delete webPage.error;
            webPage.rawDom = webPageDom;
            pageParser.preprocessRawDom(webPageDom);
            pageParser.removeUnusedElementsToReduceMemoryConsumption(webPageDom);
            let content = pageParser.findContent(webPage.rawDom);
            if (content == null) {
                let errorMsg = UIText.Error.errorContentNotFound(webPage.sourceUrl);
                throw new Error(errorMsg);
            }
            return pageParser.fetchImagesUsedInDocument(content, webPage);
        } catch (error) {
            if (this.userPreferences.skipChaptersThatFailFetch.value) {
                ErrorLog.log(error);
                webPage.error = error;
            } else {
                webPage.isIncludeable = false;
                throw error;
            }
        }
    }

    async fetchImagesUsedInDocument(content, webPage) {
        let revisedContent = await this.imageCollector.preprocessImageTags(content, webPage.sourceUrl);
        this.imageCollector.findImagesUsedInDocument(revisedContent);
        await this.imageCollector.fetchImages(() => { }, webPage.sourceUrl);
        this.updateLoadState(webPage);
    }

    /**
    * default implementation
    * derived classes override if need to do something to fetched DOM before
    * normal processing steps
    */
    preprocessRawDom(webPageDom) { // eslint-disable-line no-unused-vars
    }

    removeUnusedElementsToReduceMemoryConsumption(webPageDom) {
        util.removeElements(webPageDom.querySelectorAll("select, iframe"));
    }

    // Hook if need to chase hyperlinks in page to get all chapter content
    async fetchChapter(url) {
        return (await HttpClient.wrapFetch(url)).responseXML;
    }

    updateReadingList() {
        this.userPreferences.readingList.update(
            this.state.chapterListUrl,
            [...this.state.webPages.values()]
        );
    }

    updateLoadState(webPage) {
        ChapterUrlsUI.showDownloadState(webPage.row, ChapterUrlsUI.DOWNLOAD_STATE_LOADED);
        ProgressBar.updateValue(1);
    }

    // Hook point, when need to do something when "Pack EPUB" pressed
    onStartCollecting() {
    }    

    fixupHyperlinksInEpubItems(epubItems) {
        let targets = this.sourceUrlToEpubItemUrl(epubItems);
        for (let item of epubItems) {
            for (let link of item.getHyperlinks().filter(this.isUnresolvedHyperlink)) {
                if (!this.hyperlinkToEpubItemUrl(link, targets)) {
                    this.makeHyperlinkAbsolute(link);
                }
            }
        }
    }

    sourceUrlToEpubItemUrl(epubItems) {
        let targets = new Map();
        for (let item of epubItems) {
            let key = util.normalizeUrlForCompare(item.sourceUrl);
            
            // Some source URLs may generate multiple epub items.
            // In that case, want FIRST epub item
            if (!targets.has(key)) {
                targets.set(key, util.makeRelative(item.getZipHref()));
            }
        }
        return targets;
    }

    isUnresolvedHyperlink(link) {
        let href = link.getAttribute("href");
        if (href == null) {
            return false;
        }
        return !href.startsWith("#") &&
            !href.startsWith("../Text/");
    }

    hyperlinkToEpubItemUrl(link, targets) {
        let key = util.normalizeUrlForCompare(link.href);
        let targetInEpub = targets.has(key);
        if (targetInEpub) {
            link.href = targets.get(key) + link.hash;
        }
        return targetInEpub;
    }

    makeHyperlinkAbsolute(link) {
        if (link.href !== link.getAttribute("href")) {
            link.href = link.href;       // eslint-disable-line no-self-assign
        }
    }

    disabled() {
        return null;
    }

    tagAuthorNotes(elements) {
        for (let e of elements) {
            e.classList.add("webToEpub-author-note");
        }
    }

    tagAuthorNotesBySelector(element, selector) {
        let notes = element.querySelectorAll(selector);
        if (this.userPreferences.removeAuthorNotes.value) {
            util.removeElements(notes);
        } else {
            this.tagAuthorNotes(notes);
        }
    }

    static makeEmptyDocForContent(baseUrl) {
        let dom = document.implementation.createHTMLDocument("");
        if (baseUrl != null) {
            util.setBaseTag(baseUrl, dom);        
        }
        let content = dom.createElement("div");
        content.className = Parser.WEB_TO_EPUB_CLASS_NAME;
        dom.body.appendChild(content);
        return {
            dom: dom,
            content: content 
        };
    }

    static findConstrutedContent(dom) {
        return dom.querySelector("div." + Parser.WEB_TO_EPUB_CLASS_NAME);
    }

    static addTextToChapterContent(newDoc, contentText) {
        let lines = contentText
            .replace(/\r/g, "\n")
            .replace(/\n\n/g, "\n")
            .split("\n")
            .filter(s => !util.isNullOrEmpty(s));
        for (let line of lines) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = line;
            newDoc.content.appendChild(pnode);
        }
    }

    async getChapterUrlsFromMultipleTocPages(dom, extractPartialChapterList, getUrlsOfTocPages, chapterUrlsUI)  {
        let chapters = extractPartialChapterList(dom);
        let urlsOfTocPages = getUrlsOfTocPages(dom);
        return await this.getChaptersFromAllTocPages(chapters, extractPartialChapterList, urlsOfTocPages, chapterUrlsUI);
    }

    getRateLimit()
    {
        let manualDelayPerChapterValue = (!isNaN(parseInt(this.userPreferences.manualDelayPerChapter.value)))?parseInt(this.userPreferences.manualDelayPerChapter.value):this.minimumThrottle;
        if (!this.userPreferences.overrideMinimumDelay.value)
        {
            return Math.max(this.minimumThrottle, manualDelayPerChapterValue);
        }
        return manualDelayPerChapterValue;
    }

    async rateLimitDelay() {
        let manualDelayPerChapterValue = this.getRateLimit();
        await util.sleep(manualDelayPerChapterValue);
    }

    async getChaptersFromAllTocPages(chapters, extractPartialChapterList, urlsOfTocPages, chapterUrlsUI, wrapOptions)  {
        if (0 < chapters.length) {
            chapterUrlsUI.showTocProgress(chapters);
        }
        for (let url of urlsOfTocPages) {
            await this.rateLimitDelay();
            let newDom = (await HttpClient.wrapFetch(url, wrapOptions)).responseXML;
            let partialList = extractPartialChapterList(newDom);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    async walkTocPages(dom, chaptersFromDom, nextTocPageUrl, chapterUrlsUI) {
        let chapters = chaptersFromDom(dom);
        chapterUrlsUI.showTocProgress(chapters);
        let url = nextTocPageUrl(dom, chapters, chapters);
        while (url != null) {
            await this.rateLimitDelay();
            dom = (await HttpClient.wrapFetch(url)).responseXML;
            let partialList = chaptersFromDom(dom);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
            url = nextTocPageUrl(dom, chapters, partialList);
        }
        return chapters;
    }

    moveFootnotes(dom, content, footnotes) {
        if (0 < footnotes.length) {
            let list = dom.createElement("ol");
            for (let f of footnotes) {
                let item = dom.createElement("li");
                f.removeAttribute("style");
                item.appendChild(f);
                list.appendChild(item);
            }
            let header = dom.createElement("h2");
            header.appendChild(dom.createTextNode("Footnotes"));
            content.appendChild(header);
            content.appendChild(list);
        }
    }

    async walkPagesOfChapter(url, moreChapterTextUrl) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let count = 2;
        let nextUrl = moreChapterTextUrl(dom, url, count);
        let oldContent = this.findContent(dom);
        while (nextUrl != null) {
            await this.rateLimitDelay();
            let nextDom = (await HttpClient.wrapFetch(nextUrl)).responseXML;
            let newContent = this.findContent(nextDom);
            nextUrl = moreChapterTextUrl(nextDom, url, ++count);
            oldContent.appendChild(dom.createElement("br"));
            util.moveChildElements(newContent, oldContent);
        }
        return dom;
    }    
}

Parser.WEB_TO_EPUB_CLASS_NAME = "webToEpubContent";

================================================
FILE: plugin/js/ParserFactory.js
================================================

/*
    Selects parser based on current URL
*/

"use strict";

class ParserFactory {
    constructor() {
        this.parsers = new Map();
        this.parserRules = [];
        this.parserUrlRules = [];
        this.manualSelection = [];
        this.registerManualSelect("", () => undefined);
    }

    static isWebArchive(url) {
        let host = util.extractHostName(url);
        let subs = ["web", "web-beta"];
        for (let sub of subs) {
            if (host.startsWith(sub + ".archive.org")) {
                return true;
            }
        }
        return false;
    }

    static stripWebArchive(url) {
        let hostName = url.split("://");
        return hostName[2] ? "https://" + hostName[2] : url; 
    }

    static stripLeadingWww(hostName) {
        return hostName.startsWith("www.") ? hostName.substring(4) : hostName;            
    }

    register(hostName, constructor) {
        if (this.parsers.get(ParserFactory.stripLeadingWww(hostName)) == null) {
            this.parsers.set(ParserFactory.stripLeadingWww(hostName), constructor);
        } else {
            throw new Error("Duplicate parser registered for hostName " + hostName);
        }
    }

    registerDeadSite(hostName, constructor) {
        // basically, a note that site is dead
        this.register(hostName, constructor);
    }

    reregister(hostName, constructor) {
        this.parsers.set(ParserFactory.stripLeadingWww(hostName), constructor);
    }

    registerManualSelect(name, constructor) {
        this.manualSelection.push({name, constructor});
    }

    /*
    *  @param {function} test predicate that checks if parser can handle URL & DOM
    *  @param {function} constructor to obtain parser to handle the URL
    */
    registerRule(test, constructor) {
        this.parserRules.push( {test: test, constructor: constructor } );
    }

    /*
    *  @param {function} test predicate that checks if parser can handle URL
    *  @param {function} constructor to obtain parser to handle the URL
    */
    registerUrlRule(test, constructor) {
        this.parserUrlRules.push( {test: test, constructor: constructor } );
    }

    fetchByUrl(url) {
        let hostName = ParserFactory.hostNameForParserSelection(url);
        let constructor = this.parsers.get(hostName);
        if (constructor !== undefined) {
            return constructor(url);
        }

        for (let pair of this.parserUrlRules) {
            if (pair.test(url)) {
                return pair.constructor(url);
            }
        }

        return null;
    }

    fetch(url, dom) {
        let forUrl = this.fetchByUrl(url);
        if (forUrl != null) {
            return forUrl;
        }

        // no exact match found, see if any parser is willing to handle the URL and/or DOM
        let maxConfidence = 0;
        let constructor = null;
        for (let pair of this.parserRules) {
            let confidence = (pair.test(url, dom) * 1.0);
            if (maxConfidence < confidence) {
                maxConfidence = confidence;
                constructor = pair.constructor;
            }
        }
        if (0 < maxConfidence) {
            return constructor(url);
        }

        // still no parser found, fall back to default
        return new DefaultParser();
    }

    static hostNameForParserSelection(url) {
        if (ParserFactory.isWebArchive(url)) {
            url = ParserFactory.stripWebArchive(url);
        }
        return ParserFactory.stripLeadingWww(util.extractHostName(url));
    }

    populateManualParserSelectionTag(selectTag) {
        let options = selectTag.options;
        if (options.length === 0) {
            for (let p of this.manualSelection) {
                options.add(new Option(p.name));
            }
        }
    }

    manuallySelectParser(parserName) {
        for (let m of this.manualSelection) {
            if (m.name === parserName) {
                return m.constructor();
            }
        }
    }

    async addParsersToPages(initialParser, webPages) {
        let pagesByHost = new Map();
        let initialUrl = initialParser.state.chapterListUrl;
        let initialHostName = ParserFactory.hostNameForParserSelection(initialUrl);
        for (let page of webPages) {
            let key = ParserFactory.hostNameForParserSelection(page.sourceUrl);
            if (key === initialHostName) {
                page.parser = initialParser;
                continue;
            }
            let pages = pagesByHost.get(key);
            if (pages == null) {
                pages = [];
                pagesByHost.set(key, pages);
            }
            pages.push(page);
        }

        for (let pair of pagesByHost) {
            await this.assignParserToPages(pair[1], initialParser);
        }
    }

    async assignParserToPages(webPages, initialParser) {
        let url = webPages[0].sourceUrl;
        let parser = this.fetchByUrl(url);
        if (parser == null) {
            let responseXML = (await HttpClient.wrapFetch(url)).responseXML;
            parser = parserFactory.fetch(url, responseXML);
        }
        ParserFactory.copyParserToPages(parser, webPages, initialParser);
    }

    static copyParserToPages(parser, webPages, initialParser) {
        parser.copyState(initialParser);
        for (let page of webPages) {
            page.parser = parser;
        }
    }
}

let parserFactory = new ParserFactory();

================================================
FILE: plugin/js/ProgressBar.js
================================================

"use strict";

/**
   Code to manipulate the Progress Bar on the UI
*/
class ProgressBar { // eslint-disable-line no-unused-vars
    constructor() {
    }

    static getUiElement() {
        return document.getElementById("fetchProgress");
    }

    static setValue(value) {
        ProgressBar.getUiElement().value = value;
        ProgressBar.updateText();
    }

    static updateValue(increment) {
        ProgressBar.getUiElement().value += increment;
        ProgressBar.updateText();
    }

    static setMax(max) {
        ProgressBar.getUiElement().max = max;
        ProgressBar.updateText();
    }

    static updateText() {
        let element = ProgressBar.getUiElement();
        let text = "";
        if (1 < element.max) {
            text = `${element.value}/${element.max}`;
            ProgressBar.updateTabTitle(element.value, element.max);
        }
        document.getElementById("progressString").textContent = text;
    }

    static updateTabTitle(value, max) {
        value = (value*100/max).toFixed(1);
        if (value == "100.0") {
            value = "100";
        }
        document.title = value + "% WebToEpub";
    }
}

================================================
FILE: plugin/js/ReadingList.js
================================================

"use strict";

/** Track EPUB chapters that have been previously downloaded

- Note, as local storage is limited to 5 Megabytes,
- and some stories can have  * 4k or more chapters,
- Can't hold all URLs.  So just record last chapter for each story.
*/
class ReadingList {
    constructor() {
        this.epubs = new Map();
    }

    addEpub(url) {
        let oldUrl = this.epubs.get(url);
        if (oldUrl == null) {
            this.epubs.set(url, "");
        }
    }

    deleteEpub(url) {
        this.epubs.delete(url);
    }

    tryDeleteEpubAndSave(url) {
        if (this.getEpub(url)) {
            this.deleteEpub(url);
            this.writeToLocalStorage();
            return true;
        }
        return false;
    }

    setEpub(url, chapterURL) {
        this.epubs.set(url, chapterURL);
        this.writeToLocalStorage();
    }

    getEpub(url) {
        return this.epubs.get(url);
    }

    async deselectOldChapters(url, chapterList) {
        let oldUrl = this.epubs.get(url);
        if (oldUrl != null) {
            let foundLastURL = false;
            for (let i = 0; i < chapterList.length; ++i) {
                if (oldUrl === chapterList[i].sourceUrl) {
                    foundLastURL = true;
                    for (let j = 0; j <= i; ++j) {
                        chapterList[j].isIncludeable = false;
                        chapterList[j].previousDownload = true;
                    }
                    break;
                }
            }
            if (!foundLastURL) {
                let SourceChapterList = await Library.LibGetSourceChapterList(url);
                if (SourceChapterList == null) {
                    return;
                }
                for (let i = chapterList.length-1; i >= 0; --i) {
                    for (let j = SourceChapterList.length-1; j >= 0; --j) {
                        if (SourceChapterList[j] === chapterList[i].sourceUrl) {
                            for (let z = 0; z <= i; ++z) {
                                chapterList[z].isIncludeable = false;
                                chapterList[z].previousDownload = true;
                            }
                            return;
                        }
                    }
                }
            }
        }
    }

    update(url, chapterList) {
        let oldUrl = this.epubs.get(url);
        let chapterListIsIncludeable = [...chapterList].filter(a => a.isIncludeable);
        if (oldUrl != null) {
            let progressBarValue = ProgressBar.getUiElement()?.value;
            if (progressBarValue) {
                let finished = progressBarValue - 1;
                for (let i = 0; i < finished; i++) {
                    this.epubs.set(url, chapterListIsIncludeable[i].sourceUrl);
                }
            } else {
                for (let c of chapterListIsIncludeable) {
                    this.epubs.set(url, c.sourceUrl);
                }
            }
            if (oldUrl !== this.epubs.get(url)) {
                this.writeToLocalStorage();
            }
        }
    }

    static replacer(key, value) {
        switch (key) {
            case "epubs":
                return [...value].map(v => ({ toc: v[0], lastUrl: v[1] }));
            default:
                return value;
        }
    }

    static reviver(key, value) {
        switch (key) {
            case "epubs":
                return new Map([...value].map(ReadingList.reviveEpub));
            case "history": {
                return value[value.length - 1];
            }
            default:
                return value;
        }
    }

    static reviveEpub(packedEpub) {
        return (packedEpub.history == null)
            ? [packedEpub.toc, packedEpub.lastUrl]
            : [packedEpub.toc, packedEpub.history];
    }

    toJson() {
        return JSON.stringify(this, ReadingList.replacer);
    }

    static fromJson(json) {
        let rl = new ReadingList();
        rl.epubs = JSON.parse(json, ReadingList.reviver).epubs;
        return rl;
    }

    readFromLocalStorage() {
        let config = window.localStorage.getItem(ReadingList.storageName);
        if (config != null) {
            this.epubs = ReadingList.fromJson(config).epubs;
        }
    }

    writeToLocalStorage() {
        window.localStorage.setItem(ReadingList.storageName, this.toJson());
    }

    onReadingListCheckboxClicked(checked, url) {
        if (checked) {
            this.addEpub(url);
        } else {
            this.deleteEpub(url);
        }
        this.writeToLocalStorage();
    }

    showReadingList(table) {
        util.removeChildElementsMatchingSelector(table, "tr");
        for (let e of this.epubs.keys()) {
            let row = document.createElement("tr");
            table.appendChild(row);
            let link = document.createElement("a");
            link.href = e;
            link.textContent = e;
            this.appendColumnToRow(row, link);
            let button = document.createElement("button");
            button.textContent = UIText.Common.remove;
            this.appendColumnToRow(row, button);
        }
    }

    appendColumnToRow(row, element) {
        let col = document.createElement("td");
        col.appendChild(element);
        row.appendChild(col);
    }

    onClickRemove(evt) {
        if (evt.target.tagName === "BUTTON") {
            let row = evt.target.parentElement.parentElement;
            this.deleteEpub(row.querySelector("a").href);
            this.showReadingList(evt.currentTarget);
            this.writeToLocalStorage();
        }
    }
}
ReadingList.storageName = "ReadingList";

================================================
FILE: plugin/js/UIText.js
================================================

"use strict";

/**

- Centralized UI text constants
- User-facing text that needs to be localized should be defined here for easier management
 */
class UIText { // eslint-disable-line no-unused-vars
    // Chapter-related text
    static Chapter = {
        tooltipChapterDownloading: chrome.i18n.getMessage("**MSG_Tooltip_chapter_downloading**"),
        tooltipChapterDownloaded: chrome.i18n.getMessage("**MSG_Tooltip_chapter_downloaded**"),
        tooltipChapterSleeping: chrome.i18n.getMessage("**MSG_Tooltip_chapter_sleeping**"),
        tooltipChapterPreviouslyDownloaded: chrome.i18n.getMessage("**MSG_Tooltip_chapter_previously_downloaded**"),
        maxChaptersSelected: (selectedCount, maxChapters) => chrome.i18n.getMessage("**MSG_More_than_max_chapters_selected**", [selectedCount, maxChapters]),
        shiftClickMessage: chrome.i18n.getMessage("**MSG_Shift_Click**")
    };

    // Library-related text
    static Library = {
        deleteEpub: chrome.i18n.getMessage("**MSG_button_Lib_Template_Delete_EPUB**"),
        searchNewChapter: chrome.i18n.getMessage("**MSG_button_Lib_Template_Search_new_Chapters**"),
        updateNewChapter: chrome.i18n.getMessage("**MSG_button_Lib_Template_Update_new_Chapters**"),
        download: chrome.i18n.getMessage("**MSG_button_Lib_Template_Download_EPUB**"),
        newChapter: chrome.i18n.getMessage("**MSG_label_Lib_Template_New_Chapter**"),
        storyURL: chrome.i18n.getMessage("**MSG_label_Lib_Template_Story_URL**"),
        filename: chrome.i18n.getMessage("**MSG_label_Lib_Template_Filename**"),
        updateAll: chrome.i18n.getMessage("**MSG_button_Lib_Template_Update_All**"),
        clearLibrary: chrome.i18n.getMessage("**MSG_button_Lib_Template_Clear_Library**"),
        exportLibrary: chrome.i18n.getMessage("**MSG_button_Lib_Template_Export_Library**"),
        importLibrary: chrome.i18n.getMessage("**MSG_button_Lib_Template_Import_Library**"),
        addToLibrary: chrome.i18n.getMessage("**MSG_button_Lib_Template_Add_List_To_Library**"),
        mergeUpload: chrome.i18n.getMessage("**MSG_button_Lib_Template_Add_Chapter_from_different_EPUB**"),
        editMetadata: chrome.i18n.getMessage("**MSG_button_Lib_Template_Edit_Metadata**"),
        warningURLChange: chrome.i18n.getMessage("**MSG_label_Lib_Template_Warning_URL_Change**"),
        warningInProgress: chrome.i18n.getMessage("**MSG_label_Lib_Warning_In_Progress**_"),
        confirmClearLibrary: chrome.i18n.getMessage("**MSG_confirm_Clear_Library**")
    };

    // Metadata-related text
    static Metadata = {
        title: chrome.i18n.getMessage("**MSG_label_Title**"),
        author: chrome.i18n.getMessage("**MSG_label_Author**"),
        language: chrome.i18n.getMessage("**MSG_label_Language**"),
        subject: chrome.i18n.getMessage("**MSG_label_Metadata_subject**"),
        description: chrome.i18n.getMessage("**MSG_label_Metadata_description**"),
        save: chrome.i18n.getMessage("**MSG_label_Metadata_Save**")
    };

    // Common UI elements
    static Common = {
        ok: chrome.i18n.getMessage("**MSG_button_error_OK**"),
        cancel: chrome.i18n.getMessage("**MSG_button_error_Cancel**"),
        retry: chrome.i18n.getMessage("**MSG_button_error_Retry**"),
        help: chrome.i18n.getMessage("**MSG_button_Help**"),
        remove: chrome.i18n.getMessage("**MSG_button_Remove**"),
        skip: chrome.i18n.getMessage("**MSG_button_error_Skip**"),
        addToLibrary: chrome.i18n.getMessage("**MSG_button_Add_to_Library**")
    };

    // Error messages
    static Error = {
        noParserFound: chrome.i18n.getMessage("noParserFound"),
        noChaptersFound: chrome.i18n.getMessage("noChaptersFound"),
        noChaptersFoundAndFetchClicked: chrome.i18n.getMessage("noChaptersFoundAndFetchClicked"),
        noImagesFound: chrome.i18n.getMessage("noImagesFound"),
        unhandledFieldTypeError: chrome.i18n.getMessage("unhandledFieldTypeError"),
        errorContentNotFound: (url) => chrome.i18n.getMessage("errorContentNotFound", [url]),
        errorIllegalFileName: (filename, illegalChars) => chrome.i18n.getMessage("errorIllegalFileName", [filename, illegalChars]),
        errorEditMetadata: chrome.i18n.getMessage("errorEditMetadata"),
        errorAddToLibraryLibraryAddPageWithChapters: chrome.i18n.getMessage("errorAddToLibraryLibraryAddPageWithChapters"),
        htmlFetchFailed: (url, error) => chrome.i18n.getMessage("htmlFetchFailed", [url, error]),
        imageFetchFailed: (url, parentUrl, error) => chrome.i18n.getMessage("imageFetchFailed", [url, parentUrl, error]),
        imgurFetchFailed: (url, parentUrl, error) => chrome.i18n.getMessage("imgurFetchFailed", [url, parentUrl, error]),
        gotHtmlExpectedImageWarning: (url) => chrome.i18n.getMessage("gotHtmlExpectedImageWarning", [url]),
        convertToXhtmlWarning: (filename, url, errorMessage) => chrome.i18n.getMessage("convertToXhtmlWarning", [filename, url, errorMessage])
    };

    // Warning messages
    static Warning = {
        warningNoChapterUrl: chrome.i18n.getMessage("warningNoChapterUrl"),
        warningNoVisibleContent: (url) => chrome.i18n.getMessage("warningNoVisibleContent", [url]),
        warning403ErrorResponse: (hostname) => chrome.i18n.getMessage("warning403ErrorResponse", [hostname]),
        warning429ErrorResponse: (hostname) => chrome.i18n.getMessage("warning429ErrorResponse", [hostname]),
        warningParserDisabledComradeMao: chrome.i18n.getMessage("warningParserDisabledComradeMao"),
        parserDisabledNotification: chrome.i18n.getMessage("parserDisabledNotification"),
        httpFetchCanRetry: chrome.i18n.getMessage("httpFetchCanRetry"),
        warningWebpImage: (relativeHref) => chrome.i18n.getMessage("warningWebpImage", [relativeHref])
    };

    // Default/Placeholder text
    static Default = {
        uuid: chrome.i18n.getMessage("defaultUUID"),
        title: chrome.i18n.getMessage("defaultTitle"),
        author: chrome.i18n.getMessage("defaultAuthor"),
        chapterPlaceholderMessage: (title, url) => chrome.i18n.getMessage("chapterPlaceholderMessage", [title, url]),
        informationPageTitle: chrome.i18n.getMessage("informationPageTitle"),
        tableOfContentsUrl: chrome.i18n.getMessage("tableOfContentsUrl")
    };

    // Cover image related text
    static CoverImage = {
        noImagesFoundLabel: chrome.i18n.getMessage("noImagesFoundLabel"),
        setCover: chrome.i18n.getMessage("setCover")
    };

    // HTTP Client specific messages
    static HttpClient = {
        makeFailCanRetryMessage: chrome.i18n.getMessage("httpFetchCanRetry")
    };

    // Utility method for localizing UI elements
    static localizeElement(element) {
        let key = element.textContent.trim();
        let localized = chrome.i18n.getMessage(key);
        if (!util.isNullOrEmpty(localized) && localized !== key) {
            element.textContent = localized;
        }
    }
}

================================================
FILE: plugin/js/UserPreferences.js
================================================

/*
    User settings for how extension should behave
*/

"use strict";

/** Holds a single preference value for user  */
class UserPreference {
    constructor(storageName, uiElementName, defaultValue) {
        this.storageName = storageName;
        this.uiElementName = uiElementName;
        this.value = defaultValue;
    }

    getUiElement() {
        return document.getElementById(this.uiElementName);
    }

    writeToLocalStorage() {
        window.localStorage.setItem(this.storageName, this.value);
    }
}

class BoolUserPreference extends UserPreference {
    constructor(storageName, uiElementName, defaultValue) {
        super(storageName, uiElementName, defaultValue);
    }

    readFromLocalStorage() {
        let test = window.localStorage.getItem(this.storageName);
        if (test !== null) {
            this.value = (test === "true");
        }
    }

    readFromUi() {
        this.value = this.getUiElement().checked;
    }

    writeToUi() {
        this.getUiElement().checked = this.value;
    }

    hookupUi(readFromUi) {
        this.getUiElement().onclick = readFromUi;
    }
}

class StringUserPreference extends UserPreference {
    constructor(storageName, uiElementName, defaultValue) {
        super(storageName, uiElementName, defaultValue);
    }

    readFromLocalStorage() {
        let test = window.localStorage.getItem(this.storageName);
        if (test !== null) {
            this.value = test;
        }
    }

    readFromUi() {
        this.value = this.getUiElement().value;
    }

    writeToUi() {
        this.getUiElement().value = this.value;
    }

    hookupUi(readFromUi) {
        let uiElement = this.getUiElement();
        if (uiElement.tagName === "SELECT") {
            uiElement.onchange = readFromUi;
        } else {
            uiElement.addEventListener("blur", readFromUi, true);
        }
    }
}

/** The collection of all preferences for user  */
class UserPreferences { // eslint-disable-line no-unused-vars
    constructor() {
        this.preferences = [];
        this.observers = [];
        this.readingList = new ReadingList();

        // Initialize all preferences explicitly for IDE support
        // (autocomplete, type inference, no unresolved variable warnings)
        this.removeDuplicateImages = this.addPreference("removeDuplicateImages", "removeDuplicateImages", false);
        this.includeImageSourceUrl = this.addPreference("includeImageSourceUrl", "includeImageSourceUrlCheckboxInput", true);
        this.highestResolutionImages = this.addPreference("highestResolutionImages", "highestResolutionImagesCheckboxInput", true);
        this.unSuperScriptAlternateTranslations = this.addPreference("unSuperScriptAlternateTranslations", "unSuperScriptCheckboxInput", false);
        this.styleSheet = this.addPreference("styleSheet", "stylesheetInput", EpubMetaInfo.getDefaultStyleSheet());
        this.CustomFilename = this.addPreference("CustomFilename", "CustomFilenameInput", "%Filename%");
        this.useSvgForImages = this.addPreference("useSvgForImages", "useSvgForImagesInput", true);
        this.removeNextAndPreviousChapterHyperlinks = this.addPreference("removeNextAndPreviousChapterHyperlinks", "removeNextAndPreviousChapterHyperlinksInput", true);
        this.advancedOptionsVisibleByDefault = this.addPreference("advancedOptionsVisibleByDefault", "advancedOptionsVisibleByDefaultCheckbox", false);
        this.noDownloadPopup = this.addPreference("noDownloadPopup", "noDownloadPopupCheckbox", false);
        this.writeErrorHistoryToFile = this.addPreference("writeErrorHistoryToFile", "writeErrorHistoryToFileCheckbox", false);
        this.createEpub3 = this.addPreference("createEpub3", "createEpub3Checkbox", false);
        this.chaptersPageInChapterList = this.addPreference("chaptersPageInChapterList", "chaptersPageInChapterListCheckbox", false);
        this.autoSelectBTSeriesPage = this.addPreference("autoSelectBTSeriesPage", "autoParserSelectIncludesBTSeriesPageCheckbox", false);
        this.removeAuthorNotes = this.addPreference("removeAuthorNotes", "removeAuthorNotesCheckbox", false);
        this.removeChapterNumber = this.addPreference("removeChapterNumber", "removeChapterNumberCheckbox", false);
        this.removeOriginal = this.addPreference("removeOriginal", "removeOriginalCheckbox", true);
        this.selectTranslationAi = this.addPreference("selectTranslationAi", "selectTranslationAiCheckbox", false);
        this.selectRetryLonger = this.addPreference("selectRetryLonger", "selectRetryLongerCheckbox", false);
        this.removeTranslated = this.addPreference("removeTranslated", "removeTranslatedCheckbox", false);
        this.skipChaptersThatFailFetch = this.addPreference("skipChaptersThatFailFetch", "skipChaptersThatFailFetchCheckbox", false);
        this.maxChaptersPerEpub = this.addPreference("maxChaptersPerEpub", "maxChaptersPerEpubTag", "10,000");
        this.manualDelayPerChapter = this.addPreference("manualDelayPerChapter", "manualDelayPerChapterTag", "0");
        this.overrideMinimumDelay = this.addPreference("overrideMinimumDelay", "overrideMinimumDelayCheckbox", false);
        this.skipImages = this.addPreference("skipImages", "skipImagesCheckbox", false);
        this.compressImages = this.addPreference("compressImages", "compressImagesCheckbox", false);
        this.compressImagesJpgCover = this.addPreference("compressImagesJpgCover", "compressImagesJpgCoverCheckbox", false);
        this.compressImagesType = this.addPreference("compressImagesType", "compressImagesType", "jpg");
        this.compressImagesMaxResolution = this.addPreference("compressImagesMaxResolution", "compressImagesMaxResolutionTag", "1080");
        this.overwriteExistingEpub = this.addPreference("overwriteExistingEpub", "overwriteEpubWhenDuplicateFilenameCheckbox", false);
        this.themeColor = this.addPreference("themeColor", "themeColorTag", "");
        this.useFullTitle = this.addPreference("useFullTitle", "useFullTitleAsFileNameCheckbox", false);
        this.addInformationPage = this.addPreference("addInformationPage", "addInformationPageToEpubCheckbox", true);
        this.lesstags = this.addPreference("lesstags", "lesstagsCheckbox", true);
        this.autosearchmetadata = this.addPreference("autosearchmetadata", "autosearchmetadataCheckbox", false);
        this.noAdditionalMetadata = this.addPreference("noAdditionalMetadata", "noAdditionalMetadataCheckbox", true);
        this.ShowMoreMetadataOptions = this.addPreference("ShowMoreMetadataOptions", "ShowMoreMetadataOptionsCheckbox", false);
        this.LibShowAdvancedOptions = this.addPreference("LibShowAdvancedOptions", "LibShowAdvancedOptionsCheckbox", false);
        this.LibShowCompactView = this.addPreference("LibShowCompactView", "LibShowCompactViewCheckbox", false);
        this.LibDownloadEpubAfterUpdate = this.addPreference("LibDownloadEpubAfterUpdate", "LibDownloadEpubAfterUpdateCheckbox", false);
        this.disableShiftClickAlert = this.addPreference("disableShiftClickAlert", "disableShiftClickAlertCheckbox", false);
        this.disableImageResError = this.addPreference("disableImageResError", "disableImageResErrorCheckbox", false);
        this.disableWebpImageFormatError = this.addPreference("disableWebpImageFormatError", "disableWebpImageFormatErrorCheckbox", false);

        document.getElementById("themeColorTag").addEventListener("change", UserPreferences.SetTheme);
    }

    /** @private */
    addPreference(storageName, uiElementName, defaultValue) {
        let preference = null;
        if (typeof(defaultValue) === "boolean") {
            preference = new BoolUserPreference(storageName, uiElementName, defaultValue);
        } else if (typeof(defaultValue) === "string") {
            preference = new StringUserPreference(storageName, uiElementName, defaultValue);
        } else {
            throw new Error("Unknown preference type");
        }
        this.preferences.push(preference);
        return preference;
    }

    static readFromLocalStorage() {
        let newPreferences = new UserPreferences();
        for (let p of newPreferences.preferences) {
            p.readFromLocalStorage();
        }
        newPreferences.readingList.readFromLocalStorage();
        return newPreferences;
    }

    writeToLocalStorage() {
        for (let p of this.preferences) {
            p.writeToLocalStorage();
        }
        this.readingList.writeToLocalStorage();
    }

    addObserver(observer) {
        this.observers.push(observer);
        this.notifyObserversOfChange();
    }

    readFromUi() {
        for (let p of this.preferences) {
            p.readFromUi();
        }

        this.writeToLocalStorage();
        this.notifyObserversOfChange();
    }

    notifyObserversOfChange() {
        for (let observer of this.observers) {
            observer.onUserPreferencesUpdate(this);
        }
    }

    writeToUi() {
        for (let p of this.preferences) {
            p.writeToUi();
        }
        UserPreferences.SetTheme();
    }

    hookupUi() {
        let readFromUi = this.readFromUi.bind(this);
        for (let p of this.preferences) {
            p.hookupUi(readFromUi);
        }

        this.notifyObserversOfChange();
    }

    writeToFile() {
        let obj = {};
        let serialized = window.localStorage.getItem(DefaultParserSiteSettings.storageName);
        if (serialized != null) {
            obj[DefaultParserSiteSettings.storageName] = JSON.parse(serialized);
        }
        obj[ReadingList.storageName] = JSON.parse(this.readingList.toJson());
        for (let p of this.preferences) {
            obj[p.storageName] = p.value; 
        }
        serialized = JSON.stringify(obj);
        let blob = new Blob([serialized], {type : "text"});
        return Download.save(blob, "Options.json")
            .catch (err => ErrorLog.showErrorMessage(err));
    }

    readFromFile(event, populateControls) {
        if (event.target.files.length == 0) {
            return;
        }
        
        let file = event.target.files[0];
        let reader = new FileReader();
        reader.onload = readerEvent => {
            let content = readerEvent.target.result;

            // reset so triggers if user selects same file again  
            event.target.value = null;
            try {
                let json = JSON.parse(content);
                this.loadOptionsFromJson(json);
                this.loadDefaultParserFromJson(json);
                this.loadReadingListFromJson(json);
                populateControls();
            } catch (err) {
                ErrorLog.showErrorMessage(err);
            }
        };
        reader.readAsText(file);
    }

    loadOptionsFromJson(json) {
        for (let p of this.preferences) {
            let val = json[p.storageName];
            if (val !== undefined && (p.value !== val)) {
                p.value = val;
                p.writeToLocalStorage();
            }
        }
    }

    loadDefaultParserFromJson(json) {
        let val = json[DefaultParserSiteSettings.storageName];
        if (val === undefined) {
            window.localStorage.removeItem(DefaultParserSiteSettings.storageName);
        } else {
            let serialized = JSON.stringify(val);
            window.localStorage.setItem(DefaultParserSiteSettings.storageName, serialized);
        }
    }

    loadReadingListFromJson(json) {
        let val = json[ReadingList.storageName];
        if (val !== undefined) {
            let serialized = JSON.stringify(val);
            this.readingList = ReadingList.fromJson(serialized);
            window.localStorage.setItem(ReadingList.storageName, serialized);
        }
    }

    setReadingListCheckbox(url) {
        let inlist = this.readingList.getEpub(url) != null;
        UserPreferences.getReadingListCheckbox().checked = inlist;
    }

    static getReadingListCheckbox() {
        return document.getElementById("includeInReadingListCheckbox");
    }

    static SetTheme() {
        let theme = document.querySelector("#themeColorTag").value;
        let autodark = document.querySelector("link#autoDark");
        let alwaysDark = document.querySelector("link#alwaysDark");
        autodark.disabled = true;
        alwaysDark.disabled = true;
        if (theme == "") {
            autodark.disabled = false;
        } else if (theme == "DarkMode") {
            alwaysDark.disabled = false;
        }
    }
}

================================================
FILE: plugin/js/Util.js
================================================

/*
    General dumping ground for misc functions that I can't find a better place for.
    Warning: Don't look at this too closely, or you may lose your sanity.
    Side Note: Putting these all in one place may not have been a good idea.
    I think they're breeding. There seem to be more functions in here that I didn't create.
*/

"use strict";

const util = (function() {
    var sleepController = new AbortController;

    function sleep(ms) {
        return new Promise(resolve => {
            function finished() {
                resolve();
                sleepController.signal.removeEventListener("abort", finished);
            }
            sleepController.signal.addEventListener("abort", finished);
            setTimeout(finished, ms);
        });
    }

    function randomInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function isFirefox() {
        if (navigator.brave && navigator.brave.isBrave)
        {
            return false;
        }
        else if (typeof (browser) === "undefined")
        {
            // old version of chrome
            return false;
        }
        else
        {
            // this only works as long as firefox hasn't implemented this 
            // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/PlatformNaclArch
            return (typeof (browser.runtime.PlatformNaclArch) == "undefined");
        }
    }

    function extensionVersion() {
        let runtime = isFirefox() ? browser.runtime : chrome.runtime;
        // when running unit tests, runtime is not available
        return (typeof (runtime) === "undefined") ? "unknown" : runtime.getManifest().version;
    }

    function createEmptyXhtmlDoc() {
        let doc = document.implementation.createDocument(XMLNS, "", null);
        addXhtmlDocTypeToStart(doc);
        let htmlNode = doc.createElementNS(XMLNS, "html");
        doc.appendChild(htmlNode);
        let head = doc.createElementNS(XMLNS, "head");
        htmlNode.appendChild(head);
        head.appendChild(doc.createElementNS(XMLNS, "title"));
        populateHead(doc, head);
        let body = doc.createElementNS(XMLNS, "body");
        htmlNode.appendChild(body);
        return doc;
    }

    function populateHead(doc, head) {
        let style = doc.createElementNS(XMLNS, "link");
        head.appendChild(style);
        style.setAttribute("href", makeRelative(styleSheetFileName()));
        style.setAttribute("type", "text/css");
        style.setAttribute("rel", "stylesheet");
    }

    function createEmptyHtmlDoc() {
        let doc = document.implementation.createHTMLDocument("");
        populateHead(doc, doc.querySelector("head"));
        return doc;
    }

    function createSvgImageElement(href, width, height, origin, includeImageSourceUrl) {
        let svg_ns = "http://www.w3.org/2000/svg";
        let xlink_ns = "http://www.w3.org/1999/xlink";
        let doc = createEmptyXhtmlDoc();
        let body = doc.getElementsByTagName("body")[0];
        let div = doc.createElementNS(XMLNS, "div");
        div.className = "svg_outer svg_inner";
        body.appendChild(div);
        const svg = document.createElementNS(svg_ns, "svg");
        svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", xlink_ns);
        div.appendChild(svg);
        svg.setAttributeNS(null, "height", "99%");
        svg.setAttributeNS(null, "width", "100%");
        svg.setAttributeNS(null, "version", "1.1");
        svg.setAttributeNS(null, "preserveAspectRatio", "xMidYMid meet");
        svg.setAttributeNS(null, "viewBox", "0 0 " + width + " " + height);
        let newImage = doc.createElementNS(svg_ns, "image");
        svg.appendChild(newImage);
        newImage.setAttributeNS(xlink_ns, "xlink:href", makeRelative(href));
        newImage.setAttributeNS(null, "width", width);
        newImage.setAttributeNS(null, "height", height);
        origin = clearIfDataUri(origin);
        if (includeImageSourceUrl) {
            let desc = doc.createElementNS(svg_ns, "desc");
            svg.appendChild(desc);
            desc.appendChild(document.createTextNode(origin));
        } else {
            svg.appendChild(createComment(doc, origin));
        }
        return div;
    }

    function clearIfDataUri(content) {
        // Filter out data: URIs to prevent massive base64 content
        return (content && content.startsWith("data:")) ? "" : content;
    }

    // assumes we're making link from file in OEBPS\Text to OEBPS\Images
    function makeRelative(href) {
        return ".." + href.substring(5);
    }

    function resolveRelativeUrl(baseUrl, relativeUrl) {
        return new URL(relativeUrl, baseUrl).href;
    }

    function extractHostName(url) {
        return new URL(url).hostname;
    }

    function extractFilename(hyperlink) {
        let filename = hyperlink.pathname
            .split("/")
            .filter(p => p !== "")
            .pop();
        return filename ?? "";
    }

    function extractFilenameFromUrl(url) {
        return new URL(url).pathname
            .split("/")
            .filter(p => p !== "")
            .pop();
    }

    function getParamFromUrl(url, paramName) {
        return new URL(url).searchParams.get(paramName);
    }

    // set the base tag of a DOM to specified URL.
    function setBaseTag(url, dom) {
        if (dom != null) {
            let tags = Array.from(dom.getElementsByTagName("base"));
            if (0 < tags.length) {
                tags[0].setAttribute("href", url);
            } else {
                let baseTag = dom.createElement("base");
                baseTag.setAttribute("href", url);
                dom.getElementsByTagName("head")[0].appendChild(baseTag);
            }
        }
    }

    // refer https://usamaejaz.com/cloudflare-email-decoding/
    function decodeCloudflareProtectedEmails(content) {
        for (let link of [...content.querySelectorAll(".__cf_email__")]) {
            replaceCloudflareProtectedLink(link);
        }
        let links = [...content.querySelectorAll("a")].filter(l => (l.href != null) && l.href.includes("/cdn-cgi/l/email-protection"));
        for (let link of links) {
            replaceCloudflareProtectedLink(link);
        }
    }

    function replaceCloudflareProtectedLink(link) {
        let cyptedEmail = link.getAttribute("data-cfemail");
        if (cyptedEmail == null) {
            cyptedEmail = link.hash;
            if (!isNullOrEmpty(cyptedEmail)) {
                cyptedEmail = cyptedEmail.substring(1);
            }
        }
        if (cyptedEmail != null) {
            let decryptedEmail = decodeEmail(cyptedEmail);
            let textNode = document.createTextNode(decryptedEmail);
            link.parentNode.insertBefore(textNode, link);
            link.remove();
        }
    }

    function decodeEmail(encodedString) {
        let extractHex = (index) => parseInt(encodedString.slice(index, index + 2), 16);
        let key = extractHex(0);
        let email = "";
        for (let index = 2; index < encodedString.length; index += 2) {
            email += String.fromCharCode(extractHex(index) ^ key);
        }
        return email;
    }

    // delete all nodes in the supplied array
    function removeElements(elements) {
        for (let e of elements) {
            e.remove();
        }
    }

    function removeChildElementsMatchingSelector(element, selector) {
        if (element !== null) {
            removeElements(element.querySelectorAll(selector));
        }
    }

    function removeComments(root) {
        let walker = document.createTreeWalker(root, NodeFilter.SHOW_COMMENT);

        // if we delete currentNode, call to nextNode() fails.
        let nodeList = [];
        while (walker.nextNode()) {
            nodeList.push(walker.currentNode);
        }
        removeElements(nodeList);
    }

    // discard empty divs created when moving elements
    function removeEmptyDivElements(element) {
        removeElements(getElements(element, "div", e => isElementWhiteSpace(e)));
    }

    function removeTrailingWhiteSpace(element) {
        let children = element.childNodes;
        while ((0 < children.length) && isElementWhiteSpace(children[children.length - 1])) {
            children[children.length - 1].remove();
        }
    }

    function removeLeadingWhiteSpace(element) {
        let children = element.childNodes;
        while ((0 < children.length) && isElementWhiteSpace(children[0])) {
            children[0].remove();
        }
    }

    function removeHTMLUnknownElement(nodes) {
        let children = nodes.childNodes;
        for (let i = 0; i < children.length; i++) {
            if (children[i] instanceof HTMLUnknownElement) {
                children[i].remove();
            } else {
                removeHTMLUnknownElement(children[i]);
            }
        }
    }

    function removeScriptableElements(element) {
        removeChildElementsMatchingSelector(element, "script, iframe");
        removeEventHandlers(element);
    }

    function removeMicrosoftWordCrapElements(element) {
        for (let node of getElements(element, "O:P")) {
            flattenNode(node);
        }
    }

    function flattenNode(node) {
        while (node.hasChildNodes()) {
            node.parentNode.insertBefore(node.childNodes[0], node);
        }
        node.remove();
    }

    /**
     * @todo expand to remove ALL event handlers
     */
    function removeEventHandlers(contentElement) {
        let walker = contentElement.ownerDocument.createTreeWalker(contentElement, NodeFilter.SHOW_ELEMENT);
        let element = contentElement;
        while (element != null) {
            element.removeAttribute("onclick");
            element = walker.nextNode();
        }
    }

    function removeHeightAndWidthStyleFromParents(element) {
        let parent = element.parentElement;
        while ((parent != null) && (parent.tagName.toLowerCase() !== "body")) {
            removeHeightAndWidthStyle(parent);
            parent = parent.parentElement;
        }
    }

    function removeHeightAndWidthStyle(element) {
        let style = element.style;
        if ((style.width !== "") || (style.height !== "")) {
            style.width = null;
            style.height = null;
            if (style.length === 0) {
                // avoid a style="" attribute in element
                element.removeAttribute("style");
            }
        }
        element.removeAttribute("width");
        element.removeAttribute("height");
    }

    function removeUnwantedWordpressElements(element) {
        let ccs = "div.sharedaddy, div.wpcnt, ul.post-categories, div.mistape_caption, "
            + "div.wpulike, div.wp-next-post-navi, .ezoic-adpicker-ad, .ezoic-ad, "
            + "ins.adsbygoogle";
        removeChildElementsMatchingSelector(element, ccs);
    }

    function removeShareLinkElements(contentElement) {
        removeChildElementsMatchingSelector(contentElement, "div.sharepost");
    }

    function convertPreTagToPTags(dom, element, splitOn) {
        let normalizeEol = (s) => s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

        splitOn = splitOn || "\n";
        let strings = normalizeEol(element.innerText).split(splitOn);
        element.innerHTML = "";
        for (let s of strings) {
            let p = dom.createElement("p");
            p.appendChild(dom.createTextNode(s));
            element.appendChild(p);
        }
    }

    function prepForConvertToXhtml(element) {
        replaceCenterTags(element);
        replaceUnderscoreTags(element);
        replaceSTags(element);
    }

    function replaceCenterTags(element) {
        for (let center of element.querySelectorAll("center")) {
            let replacement = center.ownerDocument.createElement("p");
            replacement.style.textAlign = "center";
            convertElement(center, replacement);
        }
    }

    function replaceUnderscoreTags(element) {
        for (let underscore of element.querySelectorAll("U")) {
            let replacement = underscore.ownerDocument.createElement("span");
            // ToDo: figure out how to do this by manipulating the style directly
            replacement.setAttribute("style", "text-decoration: underline;");
            convertElement(underscore, replacement);
        }
    }

    function replaceSTags(element) {
        for (let underscore of element.querySelectorAll("s")) {
            let replacement = underscore.ownerDocument.createElement("span");
            // ToDo: figure out how to do this by manipulating the style directly
            replacement.setAttribute("style", "text-decoration: line-through;");
            convertElement(underscore, replacement);
        }
    }

    function convertElement(element, replacement) {
        let parent = element.parentElement;
        parent.insertBefore(replacement, element);
        moveChildElements(element, replacement);
        copyAttributes(element, replacement);
        element.remove();
    }

    function moveChildElements(from, to) {
        while (from.firstChild) {
            to.appendChild(from.firstChild);
        }
    }

    function copyAttributes(from, to) {
        for (let i = 0; i < from.attributes.length; ++i) {
            let attr = from.attributes[i];
            try {
                to.setAttribute(attr.localName, attr.value);
            } catch (e) {
                // probably invalid attribute name.  Discard
            }
        }
    }

    function fixDelayLoadedImages(element, delayAttrib) {
        for (let i of element.querySelectorAll("img")) {
            let url = i.getAttribute(delayAttrib);
            if (!isNullOrEmpty(url)) {
                i.src = url;
            }
        }
    }

    function fixBlockTagsNestedInInlineTags(contentElement) {
        // if an inline tag contains block tags, move contents out of inline tag
        // refer https://github.com/dteviot/WebToEpub/issues/62
        let garbage = [];
        let walker = contentElement.ownerDocument.createTreeWalker(contentElement, NodeFilter.SHOW_ELEMENT);
        let element = contentElement;
        while (element != null) {
            if (isInlineElement(element) && isBlockElementInside(element)) {
                moveElementsOutsideTag(element);
                garbage.push(element);
            }
            element = walker.nextNode();
        }

        for (let g of garbage) {
            g.remove();
        }
    }

    function isBlockElementInside(inlineElement) {
        let walker = inlineElement.ownerDocument.createTreeWalker(inlineElement, NodeFilter.SHOW_ELEMENT);
        let element = null;
        while ((element = walker.nextNode())) {
            if (isBlockElement(element)) {
                return true;
            }
        }

        // if here, no block element found
        return false;
    }

    function moveElementsOutsideTag(inlineElement) {
        while (inlineElement.hasChildNodes()) {
            let node = inlineElement.childNodes[0];
            inlineElement.parentNode.insertBefore(node, inlineElement);

            // handle case of <inline><inline><block></block></inline></inline>
            fixBlockTagsNestedInInlineTags(node);
        }
    }

    function isNodeInTag(tags, node) {
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return false;
        } else {
            let tagName = node.tagName.toLowerCase();
            return tags.some(t => t === tagName);
        }
    }

    function isInlineElement(node) {
        return isNodeInTag(INLINE_ELEMENTS, node);
    }

    function isBlockElement(node) {
        return isNodeInTag(BLOCK_ELEMENTS, node);
    }

    function getFirstImgSrc(dom, selector) {
        return dom.querySelector(selector)?.querySelector("img")?.src ?? null;
    }

    function extractHashFromUri(uri) {
        let index = uri.indexOf("#");
        return (index === -1) ? null : uri.substring(index + 1);
    }

    function resolveLazyLoadedImages(content, imgCss, attrName) {
        attrName = attrName || "data-src";
        for (let img of content.querySelectorAll(imgCss)) {
            let dataSrc = img.getAttribute(attrName);
            if (dataSrc !== null) {
                img.src = dataSrc.trim();
            }
        }
    }

    function makeHyperlinksRelative(baseUri, content) {
        for (let link of getElements(content, "a", e => isLocalHyperlink(baseUri, e))) {
            link.href = "#" + extractHashFromUri(link.href);
        }
    }

    function isLocalHyperlink(baseUri, link) {
        return link.href.startsWith(baseUri) && (link.href.indexOf("#") !== -1);
    }

    function findPrimaryStyleSettings(element, styleProperties) {
        let characterCountForElement = function(element) {
            let count = 0;
            let child = element.firstChild;
            while (child) {
                if (child.nodeType === Node.TEXT_NODE) {
                    count += child.nodeValue.length;
                }
                child = child.nextSibling;
            }
            return count;
        };

        let findMaxCount = function(map) {
            let maxPair = [undefined, 0];
            for (let pair of map) {
                if (maxPair[1] <= pair[1]) {
                    maxPair = pair;
                }
            }
            return maxPair[0];
        };

        let mergeStyles = function(parentStyle, currentStyle, styleProperty) {
            if (currentStyle === null || currentStyle === undefined) {
                return parentStyle;
            }
            let c = currentStyle[styleProperty];
            return c !== "" ? c : parentStyle;
        };

        let updateStat = function(map, key, count) {
            let total = map.get(key);
            if (total === undefined) {
                total = 0;
            }
            map.set(key, total + count);
        };

        let walk = function(element, stats, parentStyle, styleProperties) {
            let mergedStyle = [];
            let count = characterCountForElement(element);
            for (let i = 0; i < styleProperties.length; ++i) {
                let merged = mergeStyles(parentStyle[i], element.style, styleProperties[i]);
                updateStat(stats[i], merged, count);
                mergedStyle.push(merged);
            }
            for (let i = 0; i < element.childElementCount; ++i) {
                walk(element.children[i], stats, mergedStyle, styleProperties);
            }
        };

        let stats = styleProperties.map(() => new Map());
        let initialStyle = styleProperties.map(() => undefined);

        walk(element, stats, initialStyle, styleProperties);
        return stats.map(s => findMaxCount(s));
    }

    /**
     *  Remove specified inline style value from element and its descendants
     */
    function removeStyleValue(element, styleName, value) {
        if (value === undefined) {
            return;
        }
        let walker = element.ownerDocument.createTreeWalker(element, NodeFilter.SHOW_ELEMENT);
        do {
            let node = walker.currentNode;
            let style = node.style;
            if (style[styleName] === value) {
                style[styleName] = null;
                if (style.length === 0) {
                    node.removeAttribute("style");
                }
            }
        } while (walker.nextNode());
    }

    /** If web page is using custom font color or size, set to default */
    function setStyleToDefault(element) {
        let styleProperties = ["color", "fontSize"];
        let primary = findPrimaryStyleSettings(element, styleProperties);
        for (let i = 0; i < styleProperties.length; ++i) {
            removeStyleValue(element, styleProperties[i], primary[i]);
        }
    }

    // move up heading if higher levels are missing, i.e. h2 to h1, h3 to h2 if there's no h1.
    function removeUnusedHeadingLevels(contentElement) {
        let usedHeadings = HEADER_TAGS.map(tag => [...contentElement.querySelectorAll(tag)])
            .filter(headings => 0 < headings.length);
        for (let i = 0; i < usedHeadings.length; ++i) {
            for (let element of usedHeadings[i]) {
                let replacement = element.ownerDocument.createElement(HEADER_TAGS[i]);
                convertElement(element, replacement);
            }
        }
    }

    /**
     * wrap any raw text in <p></p> tags
     */
    function wrapRawTextNode(node) {
        if ((node.nodeType === Node.TEXT_NODE) && !isStringWhiteSpace(node.nodeValue)) {
            let wrapper = node.ownerDocument.createElement("p");
            wrapper.appendChild(node.ownerDocument.createTextNode(node.nodeValue));
            return wrapper;
        } else {
            return node;
        }
    }

    function isNullOrEmpty(s) {
        return ((s == null) || isStringWhiteSpace(s));
    }

    function hyperlinksToChapterList(contentElement, isChapterPredicate, getChapterArc) {
        if (contentElement == null) {
            return [];
        }

        let linkSet = new Set();
        let includeLink = function(link) {
            // ignore links with no name or link
            if (isNullOrEmpty(link.innerText) || isNullOrEmpty(link.href)) {
                return false;
            }

            // ignore duplicate links
            let href = normalizeUrlForCompare(link.href);
            if (linkSet.has(href)) {
                return false;
            }

            linkSet.add(href);
            return isChapterPredicate ? isChapterPredicate(link) : true;
        };

        // only set newArc when arc changes
        let currentArc = null;
        let newArcValueForChapter = function(link) {
            if (getChapterArc) {
                let arc = getChapterArc(link);
                if (arc === currentArc) {
                    return null;
                } else {
                    currentArc = arc;
                    return currentArc;
                }
            }

            return currentArc;
        };

        return getElements(contentElement, "a", a => includeLink(a))
            .map(link => hyperLinkToChapter(link, newArcValueForChapter(link)));
    }

    function removeTrailingSlash(url) {
        return url.endsWith("/") ? url.substring(0, url.length - 1) : url;
    }

    function removeAnchor(url) {
        let index = url.indexOf("#");
        return (0 <= index) ? url.substring(0, index) : url;
    }

    function normalizeUrlForCompare(url) {
        let noTrailingSlash = removeTrailingSlash(removeAnchor(url));

        const protocolSeparator = "://";
        let protocolIndex = noTrailingSlash.indexOf(protocolSeparator);
        return (protocolIndex < 0) ? noTrailingSlash
            : noTrailingSlash.substring(protocolIndex + protocolSeparator.length);
    }

    function hyperLinkToChapter(link, newArc) {
        return {
            sourceUrl: link.href,
            title: link.innerText.trim(),
            newArc: (newArc === undefined) ? null : newArc
        };
    }

    function createComment(doc, content) {
        content = clearIfDataUri(content);
        // comments are not allowed to contain a double hyphen
        let escaped = content.replace(/--/g, "%2D%2D");
        return doc.createComment("  " + escaped + "  ");
    }

    function addXmlDeclarationToStart(dom) {
        // As JavaScript doesn't support this directly, need to do a dirty hack using
        // a processing instruction
        // see https://bugzilla.mozilla.org/show_bug.cgi?id=318086
        let declaration = dom.createProcessingInstruction("xml", "version=\"1.0\" encoding=\"utf-8\"");
        dom.insertBefore(declaration, dom.childNodes[0]);
    }

    function addXhtmlDocTypeToStart(dom) {
        // So that we don't get weird as hell issues with certain tags we use a dirty hack to add a doctype
        let docType = dom.implementation.createDocumentType("html", "-//W3C//DTD XHTML 1.1//EN", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd");
        dom.insertBefore(docType, dom.children[0]);
    }

    function isStringWhiteSpace(s) {
        return !(/\S/.test(s));
    }

    function isElementWhiteSpace(element) {
        switch (element.nodeType) {
            case Node.TEXT_NODE:
                return isStringWhiteSpace(element.textContent);
            case Node.COMMENT_NODE:
                return true;
        }
        if ((element.tagName === "IMG") || (element.tagName === "image")) {
            return false;
        }
        if (element.querySelector("img, image") !== null) {
            return false;
        }
        return isStringWhiteSpace(element.innerText);
    }

    function isHeaderTag(node) {
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return false;
        }
        let tag = node.tagName.toLowerCase();
        return HEADER_TAGS.some(t => tag === t);
    }

    function isUrl(string) {
        try {
            let url = new URL(string);
            return url.protocol.startsWith("http:")
                || url.protocol.startsWith("https:");
        } catch (e) {
            return false;
        }
    }

    function xmlToString(dom) {
        addXmlDeclarationToStart(dom);
        return new XMLSerializer().serializeToString(dom);
    }

    function zeroPad(num) {
        let padded = "000" + num;
        padded = padded.substring(padded.length - 4, padded.length);
        return padded;
    }

    function iterateElements(root, filter, whatToShow = NodeFilter.SHOW_ELEMENT) {
        let iterator = document.createNodeIterator(root,
            whatToShow,
            { acceptNode: filter }
        );
        let elements = [];
        let node = null;
        while ((node = iterator.nextNode()) != null) {
            elements.push(node);
        }
        return elements;
    }

    function getElements(dom, tagName, filter) {
        let array = Array.from(dom.getElementsByTagName(tagName));
        return (filter === undefined || typeof filter !== "function")
            ? array : array.filter(filter);
    }

    function getElement(dom, tagName, filter) {
        let elements = getElements(dom, tagName, filter);
        return (elements.length === 0) ? null : elements[0];
    }

    /**
     *   Used in removeNextAndPreviousChapterHyperlinks()
     *   Basically, we want to remove all elements related to the hyperlink
     *   So we want to remove the parent element. However, need to be careful
     *   we don't go so high we wipe out the entire document
     */
    function moveIfParent(element, parentTag) {
        let parent = element.parentNode;
        if ((parent.tagName.toLowerCase() === parentTag) &&
            (parent.textContent.length < 200)) {
            return parent;
        }
        return element;
    }

    function safeForFileName(title, maxLength = 20) {
        if (title) {
            // Allow only a-z regardless of case and numbers as well as hyphens and underscores; replace spaces and no-break spaces with underscores
            title = title.replace(/[ \u00a0]/gi, "_").replace(/([^a-z0-9_-]+)/gi, "");
            // There is technically a 255-character limit in windows for file paths.
            // So we will allow files to have 20 characters and when they go over we split them
            // we then truncate the middle so that the file name is always different
            const ellipsis = "...";
            let splitLength = Math.floor((maxLength - ellipsis.length) / 2);
            return title.length > maxLength
                ? title.slice(0, splitLength) + ellipsis + title.slice(title.length - splitLength)
                : title;
        }
        return "";
    }

    function makeStorageFileName(subdirectory, index, title, extension) {
        if (title) {
            const safeLengthForNameInZip = 200;
            title = "_" + safeForFileName(title, safeLengthForNameInZip) + ".";
        } else {
            // We don't want issues so just set it to . to prepare for the extension
            title = ".";
        }
        return subdirectory + zeroPad(index) + title + extension;
    }

    function isTextAreaField(element) {
        return (element.tagName === "TEXTAREA");
    }

    function isTextInputField(element) {
        return (element.tagName === "INPUT") &&
            ((element.type === "text") || (element.type === "url"));
    }

    function isXhtmlInvalid(xhtmlAsString, mimeType = "application/xml") {
        let doc = new DOMParser().parseFromString(xhtmlAsString, mimeType);
        let parserError = doc.querySelector("parsererror");
        return (parserError === null) ? null : parserError.textContent;
    }

    function dctermsToTable(dom) {
        let table = dom.createElement("table");
        let body = dom.createElement("tbody");
        table.appendChild(body);
        for (let term of dom.querySelectorAll("meta[name*='dcterms.']")) {
            let row = dom.createElement("tr");
            body.appendChild(row);
            let td = dom.createElement("td");
            row.appendChild(td);
            td.textContent = term.getAttribute("name").replace("dcterms.", "");
            td = dom.createElement("td");
            row.appendChild(td);
            td.textContent = term.getAttribute("content");
        }
        return table;
    }

    function parseHtmlAndInsertIntoContent(htmlText, content) {
        let parsed = util.sanitize(htmlText);
        while (content.firstChild) {
            content.removeChild(content.firstChild);
        }
        for (const tag of [...parsed.querySelector("body").children]) {
            content.appendChild(tag);
        }
    }

    // allow disabling logging from one place
    function log(arg) { // eslint-disable-line no-unused-vars
        // ToDo: uncomment this for debug logging
        // console.log(arg);
    }

    // This is for Unit Testing only
    function syncLoadSampleDoc(fileName, url) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", fileName, false);
        xhr.send(null);
        let dom = new DOMParser().parseFromString(xhr.responseText, "text/html");
        setBaseTag(url, dom);
        return dom;
    }

    function styleSheetFileName() {
        return "OEBPS/Styles/stylesheet.css";
    }

    function extractUrlFromBackgroundImage(element) {
        const background = element?.style?.backgroundImage;
        return background?.substring(5, background.length - 2) ?? null;
    }

    function extractSubstring(s, prefix, suffix) {
        if (typeof (prefix) !== "string") {
            let match = s.match(prefix);
            if (match === null) {
                throw new Error("prefix not found");
            } else {
                prefix = match[0];
            }
        }

        let i = s.indexOf(prefix);
        if (i < 0) {
            throw new Error("prefix not found");
        }
        s = s.substring(i + prefix.length);
        i = s.indexOf(suffix);
        if (i < 0) {
            throw new Error("suffix not found");
        }
        return s.substring(0, i);
    }

    function findIndexOfClosingQuote(s, startIndex) {
        let index = startIndex + 1;
        while (index < s.length && (s[index] !== "\"")) {
            index += (s[index] === "\\") ? 2 : 1;
        }
        return index;
    }

    function findIndexOfClosingBracket(s, startIndex) {
        let index = startIndex + 1;
        let depth = 1;
        let c = s[index];
        while (0 < depth && index < s.length) {
            if (c === "]" || c === "}") {
                --depth;
                if (depth === 0) {
                    return index;
                }
            } else if (c === "[" || c === "{") {
                ++depth;
            } else if (c === "\"") {
                index = findIndexOfClosingQuote(s, index);
            }
            ++index;
            c = s[index];
        }
        // unbalanced brackets
        return -1;
    }

    /** locate and extract JSON that is embedded in a string
     * @param {string} s - show/hide control
     * @param {string} prefix - text that precedes the embedded JSON
     */
    function locateAndExtractJson(s, prefix) {
        const findOpeningBracket = function(s, index) {
            while (index < s.length) {
                let ch = s[index];
                if ((ch === "[") || (ch === "{")) {
                    return index;
                }
                ++index;
            }
            return -1;
        };

        let index = s.indexOf(prefix);
        if (0 <= index) {
            index = findOpeningBracket(s, index + prefix.length);
            if (0 <= index) {
                let end = findIndexOfClosingBracket(s, index);
                if (index < end) {
                    let jsonString = s.substring(index, end + 1);
                    return JSON.parse(jsonString);
                }
            }
        }
        return null;
    }

    function createChapterTab(url) {
        return new Promise((resolve) => {
            chrome.tabs.create({url: url, active: false}, (tab) => {
                resolve(tab.id);
            });
        });
    }

    function removeAttributes(element, attributeNames) {
        if (!element || attributeNames == null) return;

        // Handle single attribute name as string
        if (typeof attributeNames === "string") {
            element.removeAttribute(attributeNames);
            return;
        }

        // Handle array of attribute names
        if (Array.isArray(attributeNames)) {
            for (const name of attributeNames) {
                if (typeof name === "string") {
                    element.removeAttribute(name);
                }
            }
        }
    }

    function removeEmptyAttributes(content) {
        const elements = content.querySelectorAll("*");

        for (const element of elements) {
            const attributes = element.attributes;
            const attributesToRemove = [];

            for (let i = 0; i < attributes.length; i++) {
                if (attributes[i].value.trim() === "") {
                    attributesToRemove.push(attributes[i].name);
                }
            }

            for (let i = attributesToRemove.length - 1; i >= 0; i--) {
                element.removeAttribute(attributesToRemove[i]);
            }
        }
    }

    function removeSpansWithNoAttributes(content) {
        // within p or div tags, spans with no attributes have no purpose
        const spans = content.querySelectorAll("p span, div span");

        for (const span of spans) {
            if (span.attributes.length === 0) {
                while (span.firstChild) {
                    span.parentNode.insertBefore(span.firstChild, span);
                }
                span.parentNode.removeChild(span);
            }
        }
    }

    function replaceSemanticInlineStylesWithTags(element, removeLeftoverStyles = false) {
        if (element.hasAttribute("style")) {
            let styleText = element.getAttribute("style");

            // Map of style patterns to their semantic HTML equivalents
            const styleToTag = [
                { regex: /font-style\s*:\s*(italic|oblique)\s*;?/g, tag: "i" },
                { regex: /font-weight\s*:\s*(bold|[7-9]\d\d)\s*;?/g, tag: "b" },
                { regex: /text-decoration\s*:\s*underline\s*;?/g, tag: "u" },
                { regex: /text-decoration\s*:\s*line-through\s*;?/g, tag: "s" }
            ];

            // Apply semantic tags and remove corresponding styles
            for (const style of styleToTag) {
                if (style.regex.test(styleText)) {
                    // Reset lastIndex since test() advances it
                    style.regex.lastIndex = 0;
                    wrapInnerContentInTag(element, style.tag);
                    styleText = styleText.replace(style.regex, "");
                }
            }

            // Remove non-semantic font-weight
            styleText = styleText.replace(/font-weight\s*:\s*(normal|[1-4]\d\d)\s*;?/g, "");
            styleText = styleText.trim();

            if (styleText && (!removeLeftoverStyles || /italic|bold|font-weight|underline|line-through/.test(styleText))) {
                element.setAttribute("style", styleText);
            } else {
                // Remove all remaining styles except text-align:center if present
                element.style.getPropertyValue("text-align") === "center"
                    ? element.setAttribute("style", "text-align: center;")
                    : element.removeAttribute("style");
            }
        }
    }

    function wrapInnerContentInTag(element, tagName) {
        const wrapper = document.createElement(tagName);
        moveChildElements(element, wrapper);
        element.appendChild(wrapper);
    }

    function getDefaultExtensionByMime(mimeType)
    {
        let retval = MIME_TYPE_EXTENSIONS[mimeType];
        if (retval) retval = retval[0];
        return retval;
    }
    function detectMimeType(b64) {
        let b64b = atob(b64);
        for (var s in MIME_TYPE_SIGNATURES) {
            if (b64b.indexOf(atob(s)) === 0 || b64.indexOf(s) === 0) {
                return MIME_TYPE_SIGNATURES[s][0];
            }
        }
    }

    function sanitize(dirty) {
        let savedBaseURI = dirty.baseURI;
        const clean = DOMPurify.sanitize(dirty);
        let html = new DOMParser().parseFromString(clean, "text/html");
        if (savedBaseURI) {
            util.setBaseTag(savedBaseURI, html);
        }
        return html;
    }

    function sanitizeNode(dirty) {
        // don't need to sanitize text nodes
        // and DOMPurify deletes them if they're whitespace
        return (dirty?.nodeType === 3)
            ? dirty.cloneNode(true)
            : sanitize(dirty).body.firstChild;
    }

    // Define constants
    const XMLNS = "http://www.w3.org/1999/xhtml";

    // ugly, but we're treating <u> and <s> as inline (they are not)
    const INLINE_ELEMENTS = ["b", "big", "i", "small", "tt", "abbr", "acronym", "cite",
        "code", "dfn", "em", "kbd", "strong", "samp", "time", "var", "a", "bdo",
        "br", "img", "map", "object", "q", "script", "span", "sub", "sup",
        "button", "input", "label", "select", "textarea", "u", "s"];

    const BLOCK_ELEMENTS = ["address", "article", "aside", "blockquote", "canvas",
        "dd", "div", "dl", "fieldset", "figcaption", "figure", "footer",
        "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr",
        "li", "main", "nav", "noscript", "ol", "output", "p", "pre",
        "section", "table", "tfoot", "ul", "video"];

    const HEADER_TAGS = ["h1", "h2", "h3", "h4", "h5", "h6"];

    const MIME_TYPE_EXTENSIONS = {
        "image/jpeg": ["jpg", "jpeg", "jpe"],
        "image/png": ["png"],
        "image/gif": ["gif"],
        "image/webp": ["webp"],
        "image/bmp": ["bmp", "dib"],
        "image/tiff": ["tif", "tiff"],
        "image/svg+xml": ["svg"],
        "image/x-icon": ["ico"],
        "image/vnd.microsoft.icon": ["ico"],
        "image/heif": ["heif"],
        "image/heic": ["heic"],
        "image/x-xbitmap": ["xbm"],
        "image/x-portable-bitmap": ["pbm"],
        "image/x-portable-graymap": ["pgm"],
        "image/x-portable-pixmap": ["ppm"],
        "image/x-portable-anymap": ["pnm"],
        "image/x-cmu-raster": ["ras"],
        "image/x-tga": ["tga"],
        "image/jxr": ["jxr"],
        "image/ktx": ["ktx"],
        "image/apng": ["apng"],
        "image/avif": ["avif"]
    };

    const MIME_TYPE_SIGNATURES = {
        "/9j/": ["image/jpeg"],
        "iVBORw0KGgo=": ["image/png", "image/apng"],
        "R0lGODdh": ["image/gif"],
        "R0lGODlh": ["image/gif"],
        "UklGRg": ["image/webp"],
        "Qk0=": ["image/bmp"],
        "SUkqAA==": ["image/tiff"],
        "TU0AKg==": ["image/tiff"],
        "PD94bWw=": ["image/svg+xml"],
        "AAABAA==": ["image/x-icon", "image/vnd.microsoft.icon"],
        "ZnR5cGhlaWZj": ["image/heif"],
        "ZnR5cG1pZjE=": ["image/heif"],
        "ZnR5cGhlaWNj": ["image/heic"],
        "SUm8": ["image/jxr"],
        "q0tUWCAxMb0NCgo=": ["image/ktx"],
        "AAACAA==": ["image/x-tga"],
        "ZnR5cGF2aWY=": ["image/avif"],
        "UDAx": ["image/x-portable-bitmap"],
        "UDAy": ["image/x-portable-graymap"],
        "UDAz": ["image/x-portable-pixmap"],
        "UDA0": ["image/x-portable-anymap"],
        "WaZqlQ==": ["image/x-cmu-raster"]
    };

    return {
        XMLNS: XMLNS,
        INLINE_ELEMENTS: INLINE_ELEMENTS,
        BLOCK_ELEMENTS: BLOCK_ELEMENTS,
        HEADER_TAGS: HEADER_TAGS,
        sleep: sleep,
        sleepController: sleepController,
        randomInteger: randomInteger,
        isFirefox: isFirefox,
        extensionVersion: extensionVersion,
        createEmptyXhtmlDoc: createEmptyXhtmlDoc,
        createEmptyHtmlDoc: createEmptyHtmlDoc,
        populateHead: populateHead,
        createSvgImageElement: createSvgImageElement,
        clearIfDataUri: clearIfDataUri,
        resolveRelativeUrl: resolveRelativeUrl,
        log: log,
        extractHostName: extractHostName,
        extractFilename: extractFilename,
        extractFilenameFromUrl: extractFilenameFromUrl,
        getParamFromUrl: getParamFromUrl,
        setBaseTag: setBaseTag,
        decodeCloudflareProtectedEmails: decodeCloudflareProtectedEmails,
        replaceCloudflareProtectedLink: replaceCloudflareProtectedLink,
        decodeEmail: decodeEmail,
        removeElements: removeElements,
        removeChildElementsMatchingSelector: removeChildElementsMatchingSelector,
        removeComments: removeComments,
        removeEmptyDivElements: removeEmptyDivElements,
        removeTrailingWhiteSpace: removeTrailingWhiteSpace,
        removeLeadingWhiteSpace: removeLeadingWhiteSpace,
        removeHTMLUnknownElement: removeHTMLUnknownElement,
        removeScriptableElements: removeScriptableElements,
        removeMicrosoftWordCrapElements: removeMicrosoftWordCrapElements,
        flattenNode: flattenNode,
        removeEventHandlers: removeEventHandlers,
        removeHeightAndWidthStyleFromParents: removeHeightAndWidthStyleFromParents,
        removeHeightAndWidthStyle: removeHeightAndWidthStyle,
        removeUnwantedWordpressElements: removeUnwantedWordpressElements,
        removeShareLinkElements: removeShareLinkElements,
        convertPreTagToPTags: convertPreTagToPTags,
        prepForConvertToXhtml: prepForConvertToXhtml,
        replaceCenterTags: replaceCenterTags,
        replaceUnderscoreTags: replaceUnderscoreTags,
        replaceSTags: replaceSTags,
        convertElement: convertElement,
        moveChildElements: moveChildElements,
        copyAttributes: copyAttributes,
        fixDelayLoadedImages: fixDelayLoadedImages,
        fixBlockTagsNestedInInlineTags: fixBlockTagsNestedInInlineTags,
        isBlockElementInside: isBlockElementInside,
        moveElementsOutsideTag: moveElementsOutsideTag,
        isNodeInTag: isNodeInTag,
        isInlineElement: isInlineElement,
        isBlockElement: isBlockElement,
        getFirstImgSrc: getFirstImgSrc,
        makeRelative: makeRelative,
        makeStorageFileName: makeStorageFileName,
        extractHashFromUri: extractHashFromUri,
        makeHyperlinksRelative: makeHyperlinksRelative,
        resolveLazyLoadedImages: resolveLazyLoadedImages,
        isLocalHyperlink: isLocalHyperlink,
        findPrimaryStyleSettings: findPrimaryStyleSettings,
        removeStyleValue: removeStyleValue,
        setStyleToDefault: setStyleToDefault,
        removeUnusedHeadingLevels: removeUnusedHeadingLevels,
        isNullOrEmpty: isNullOrEmpty,
        wrapRawTextNode: wrapRawTextNode,
        hyperlinksToChapterList: hyperlinksToChapterList,
        removeTrailingSlash: removeTrailingSlash,
        removeAnchor: removeAnchor,
        normalizeUrlForCompare: normalizeUrlForCompare,
        hyperLinkToChapter: hyperLinkToChapter,
        createComment: createComment,
        addXmlDeclarationToStart: addXmlDeclarationToStart,
        addXhtmlDocTypeToStart: addXhtmlDocTypeToStart,
        iterateElements: iterateElements,
        getElement: getElement,
        getElements: getElements,
        moveIfParent: moveIfParent,
        safeForFileName: safeForFileName,
        styleSheetFileName: styleSheetFileName,
        isStringWhiteSpace: isStringWhiteSpace,
        isElementWhiteSpace: isElementWhiteSpace,
        isHeaderTag: isHeaderTag,
        isUrl: isUrl,
        isTextAreaField: isTextAreaField,
        isTextInputField: isTextInputField,
        isXhtmlInvalid: isXhtmlInvalid,
        dctermsToTable: dctermsToTable,
        parseHtmlAndInsertIntoContent: parseHtmlAndInsertIntoContent,
        extractUrlFromBackgroundImage: extractUrlFromBackgroundImage,
        extractSubstring: extractSubstring,
        findIndexOfClosingQuote: findIndexOfClosingQuote,
        findIndexOfClosingBracket: findIndexOfClosingBracket,
        locateAndExtractJson: locateAndExtractJson,
        createChapterTab: createChapterTab,
        syncLoadSampleDoc: syncLoadSampleDoc,
        xmlToString: xmlToString,
        zeroPad: zeroPad,
        sanitize: sanitize,
        sanitizeNode: sanitizeNode,
        removeAttributes: removeAttributes,
        removeEmptyAttributes: removeEmptyAttributes,
        removeSpansWithNoAttributes: removeSpansWithNoAttributes,
        replaceSemanticInlineStylesWithTags: replaceSemanticInlineStylesWithTags,
        wrapInnerContentInTag: wrapInnerContentInTag,
        getDefaultExtensionByMime: getDefaultExtensionByMime,
        detectMimeType: detectMimeType
    };
})();

================================================
FILE: plugin/js/debugging/FakeParser.js
================================================

"use strict";

/**
  This is a dummy parser, intended to act like a parser that reads a
  lot of chapters, slowly.  For testing other parts of WebToEpub
  Note, need to open the by looking at site rtd.moe
*/

parserFactory.register("rtd.moe", () => new FakeParser());

class FakeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls( /* dom */ ) {
        let chapters = [];
        for (let i = 1; i < 30; ++i) {
            chapters.push({
                sourceUrl:  `https://rtd.moe/Chapter/${i}.html`,
                title: `Chapter ${i}`,
                newArc: null
            });
        }
        return chapters;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        this.addTitleToChapter(newDoc, url);
        await new Promise(resolve => setTimeout(resolve, 1000));
        return newDoc.dom; 
    }

    addTitleToChapter(newDoc, url) {
        let title = newDoc.dom.createElement("h1");
        title.textContent = url;
        newDoc.content.appendChild(title);
    }

    getInformationEpubItemChildNodes( /* dom */ ) {
        return [];
    }    
}

================================================
FILE: plugin/js/parsers/230BookParser.js
================================================

"use strict";

//broken url
parserFactory.register("230book.net", () => new _230BookParser() );
parserFactory.register("38xs.com", () => new_38xsParser() );

class _230BookBaseParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("#info h1").textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector(".bookname h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#fmimg");
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gbk")
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#intro")];
    }
}

class _230BookParser extends_230BookBaseParser {
    constructor() {
        super();
    }

    async fetchChapter(url) {
        // site does not tell us gbk is used to encode text
        return (await HttpClient.wrapFetch(url, this.makeOptions())).responseXML;
    }
}

class _38xsParser extends_230BookBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("#list dd a")];
        return this.removeDuplicatesFromFrontOfList(links)
            .map(a => util.hyperLinkToChapter(a));
    }

    removeDuplicatesFromFrontOfList(list) {
        let keys = new Set();
        let filtered = [];
        while (0 < list.length) {
            let item = list.pop();
            if (!keys.has(item.href)) {
                keys.add(item.href);
                filtered.push(item);
            }
        }
        return filtered.reverse();
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom) {
        let nextUrl = dom.querySelector("a#pager_next");
        return (nextUrl != null && nextUrl.href.includes("_"))
            ? nextUrl.href
            : null;
    }

}

================================================
FILE: plugin/js/parsers/27kParser.js
================================================

"use strict";

parserFactory.register("27k.net", () => new _27kParser());

class _27kParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#chapterlist");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".txtnav");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("#article_list_content h3");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("#article_list_content label a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".baocuo, .bottom-ad");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".imgbox");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#article_list_content ol")];
    }
}

================================================
FILE: plugin/js/parsers/4kswParser.js
================================================

"use strict";

parserFactory.register("4ksw.com", () => new _4kswParser());

class _4kswParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.list-charts");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content-body");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".panel-heading");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".info1");
    }

    async fetchChapter(url) {
        let options = { makeTextDecoder: () => new TextDecoder("gbk") };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".info2 div")];
    }
}

================================================
FILE: plugin/js/parsers/69shuParser.js
================================================

"use strict";

parserFactory.registerUrlRule(
    url => (util.extractHostName(url).includes("69shu")),
    () => new ShuParser()
);
parserFactory.register("69yuedu.net", () => new _69yueduParser());

class ShuParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 1000;
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("a.more-btn").href;
        let toc = (await HttpClient.wrapFetch(tocUrl, this.makeOptions())).responseXML;
        let menu = toc.querySelector("#catalog ul");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.txtnav");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.booknav2 h1").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.bookbox");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelectorAll(".booknav2 a")[1];
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".txtinfo, #txtright, .bottom-ad");
        super.removeUnwantedElementsFromContentElement(element);
    }

    async fetchChapter(url) {
        // site does not tell us gb18030 is used to encode text
        return (await HttpClient.wrapFetch(url, this.makeOptions())).responseXML;
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gb18030")
        });
    }
}

class _69yueduParser extends ShuParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("a.btn").href;
        let toc = (await HttpClient.wrapFetch(tocUrl, this.makeOptions())).responseXML;
        let menu = toc.querySelector("#chapters ul");
        return util.hyperlinksToChapterList(menu);
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gbk")
        });
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findContent(dom) {
        return dom.querySelector("div.content");
    }
}

================================================
FILE: plugin/js/parsers/888novelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("888novel.com", () => new _888novelParser());

class _888novelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            _888novelParser.extractPartialChapterList,
            _888novelParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static getUrlsOfTocPages(dom) {
        let pagination = dom.querySelector("ul.pagination");
        let tocUrls = [];
        if (pagination != null ) {
            let tocLinks = [...pagination.querySelectorAll("a")]
                .filter(a => a.textContent !== "»");
            if (0 < tocLinks.length) {
                let maxPageUrl = tocLinks.pop().href;
                let index = maxPageUrl.lastIndexOf("/", maxPageUrl.length - 2);
                let base = maxPageUrl.substring(0, index + 1);
                let maxPage = parseInt(maxPageUrl.substring(index + 1).replace("#dsc", ""));
                if (1 < maxPage) {
                    for (let i = 2; i <= maxPage; ++i) {
                        tocUrls.push(`${base}${i}/`);
                    }
                }
            }
        }
        return tocUrls;
    }

    static extractPartialChapterList(dom) {
        let menu = dom.querySelector("#dsc ul.listchap");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.reading");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".book3d");
    }

    getInformationEpubItemChildNodes(dom) {
        let nodes = [...dom.querySelectorAll("div.tabs1")];
        for (let n of nodes) {
            n.setAttribute("style", null);
        }
        return nodes;
    }
}

================================================
FILE: plugin/js/parsers/88xiaoshuoParser.js
================================================

"use strict";

parserFactory.register("m.88xiaoshuo.net", () => new _88xiaoshuoParser());
parserFactory.register("88xiaoshuo.net", () => new_88xiaoshuoParser());
parserFactory.register("m.ilwxs.com", () => new _88xiaoshuoParser());
parserFactory.register("ilwxs.com", () => new_88xiaoshuoParser());
parserFactory.register("m.ttshu8.com", () => new _88xiaoshuoParser());
parserFactory.register("ttshu8.com", () => new_88xiaoshuoParser());
parserFactory.register("m.xpaoshuba.com", () => new _88xiaoshuoParser());
parserFactory.register("xpaoshuba.com", () => new_88xiaoshuoParser());
parserFactory.register("m.shuhaige.net", () => new _88xiaoshuoParser());
parserFactory.register("shuhaige.net", () => new_88xiaoshuoParser());
parserFactory.register("m.qbxsw.com", () => new _88xiaoshuoParser());
parserFactory.register("qbxsw.com", () => new_88xiaoshuoParser());
parserFactory.register("m.38xs.com", () => new _88xiaoshuoParser());

class _88xiaoshuoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let changedomurl = dom.baseURI;
        if (changedomurl.includes("https://www.")) {
            changedomurl = changedomurl.replace("https://www.","https://m.");
        }
        if (changedomurl != dom.baseURI) {
            dom = (await HttpClient.fetchHtml(changedomurl)).responseXML;
        }
        return this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    getUrlsOfTocPages(dom) {
        let lastPagespan = [...dom.querySelectorAll(".caption > span > a")];
        let lastPage = null;
        for (let node of lastPagespan) {
            if (node.innerText == "尾页" || node.innerText == "Last page") {
                lastPage = node;
            }
        }
        let urls = [];
        if (lastPage) {
            const lastPageNumber = parseInt(lastPage.href.substring(lastPage.href.search(/_[0-9]+\/?$/)).replace("_", "").replace("/", ""));
            const baseUrl = lastPage.baseURI.replace(/_[0-9]+\/$/, "").replace(/\/$/, "");
            for (let i = 2; i <= lastPageNumber; i++) {
                urls.push(`${baseUrl}_${i}`);
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        let chapterList = dom.querySelector(".read");
        return [...chapterList.querySelectorAll("a")].map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".name");
    }

    extractAuthor(dom) {
        let element = dom.querySelector("#maininfo a[href*=\"author\"], .author a");
        return (element === null) ? "" : element.textContent;
    }

    findChapterTitle(dom) {
        let element = dom.querySelector(".headline");
        return (element === null) ? null : element.textContent;
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom) {
        let isNextPageOfChapter = (link) => link.href.includes("_") && link.textContent == "下一页";
        let nextUrl = [...dom.querySelectorAll(".pager a")]
            .filter(isNextPageOfChapter)
            .map(a => a.href)
            .pop();
        return nextUrl ?? null;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".box_con img, .detail > img")?.src ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#maininfo, .detail")];
    }

    extractDescription(dom) {
        let element = dom.querySelector("#intro");
        return (element === null) ? null : element.textContent;
    }
}

================================================
FILE: plugin/js/parsers/ActiveTranslationsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("a-t.nu", () => new ActiveTranslationsParser());

class ActiveTranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.wp-manga-chapter.free-chap a")]
            .map(a => util.hyperLinkToChapter(a))
            .reverse();
    }

    findContent(dom) {
        let content = dom.querySelector("div.entry-content");
        if (content === null) {
            content = dom.querySelector("div.entry-content-container");
        }
        if (content === null) {
            content = dom.querySelector("div.nv-content-wrap");
        }
        if (content !== null) {
            util.removeChildElementsMatchingSelector(content, ".code-block, #comments");
        }
        return content;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1#chapter-heading");
    }

    preprocessRawDom(chapterDom) {
        this.unscrambleText(chapterDom, this.findContent(chapterDom));
    }

    unscrambleText(dom, content) {
        let style = content.querySelector("style");
        if (style == null) {
            return;
        }
        let rules = this.parseStyle(content);
        let spans = new Map();
        for (let span of [...content.querySelectorAll("p span")]) {
            spans.set(span.className.trim(), span);
        }
        this.addRuleContent(dom, spans, rules);
    }

    parseStyle(content) {
        let rules = new Map();
        let style = [...content.querySelectorAll("style")].pop();
        let lines = style.textContent.split(/;\s*}/)
            .map(l => l.trim())
            .filter(l => !util.isNullOrEmpty(l));
        for (let line of lines) {
            let index = line.indexOf("::before {");
            if (0 < index) {
                this.addPsudoElement(line, index, rules, "before");
                continue;
            }
            index = line.indexOf("::after {");
            if (0 < index) {
                this.addPsudoElement(line, index, rules, "after");
                continue;
            }
            break;
        }
        style.remove();
        return rules;
    }

    addPsudoElement(line, index, rules, name) {
        let className = line.substring(1, index);
        let context = this.extractContent(line);
        let rule = rules.get(className);
        if (rule === undefined) {
            rule = {};
            rules.set(className, rule);
        }
        rule[name] = context;
    }

    extractContent(contextLine) {
        let start = contextLine.indexOf("'");
        let end = contextLine.lastIndexOf("'");
        return contextLine.substring(start + 1, end).replace("\\a0", "");
    }

    addRuleContent(dom, spans, rules)
    {
        for (let span of spans.entries()) {
            let rule = rules.get(span[0]);
            if (rule != null) {
                let text = span[1].textContent;
                if (rule.before) {
                    text = rule.before + text;
                }
                if (rule.after) {
                    text += rule.after;
                }
                let textNode = dom.createTextNode(text);
                span[1].replaceWith(textNode);
            }
        }
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.tab-summary");
    }
}

================================================
FILE: plugin/js/parsers/AdultfanfictionParser.js
================================================

"use strict";

parserFactory.registerRule(
    (url) => AdultfanfictionParser.isAdultFanFiction(url) * 0.9,
    () => new AdultfanfictionParser()
);

class AdultfanfictionParser extends Parser {
    constructor() {
        super();
    }

    static isAdultFanFiction(url) {
        return (util.extractHostName(url).indexOf(".adult-fanfiction.org") != -1);
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul#dropdown1");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#contentdata");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h4");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "ul#dropdown1, a.dropdown-trigger, ul.pagination");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/AerialrainParser.js
================================================

"use strict";

parserFactory.register("aerialrain.com", () => new AerialrainParser());

class AerialrainParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.arconix-toggle-content a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.blog-detail-description");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.blog-detail-description p")];
    }
}

================================================
FILE: plugin/js/parsers/AkknovelParser.js
================================================

"use strict";

parserFactory.register("akknovel.com", () => new AkknovelParser());

class AkknovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.chapter-item a")]
            .map(link => this.linkToChapter(link));
    }

    linkToChapter(link) {
        let span = link.querySelector("span");
        let title = span.textContent.trim() + " " + span.nextSibling.textContent.trim();
        return ({
            sourceUrl:  link.href,
            title: title,
        });
    }

    findContent(dom) {
        return (
            dom.querySelector("#chr-content") || dom.querySelector("#chapter-content")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.aspect-h-4");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.leading-7")];
    }
}

================================================
FILE: plugin/js/parsers/AlphapolisParser.js
================================================

"use strict";
parserFactory.register("alphapolis.co.jp", () => new AlphapolisParser());
class AlphapolisParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 15000;
    }
    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.episodes");
        return util.hyperlinksToChapterList(menu);
    }
    findContent(dom) {
        return dom.querySelector("div#novelBody");
    }
    extractTitleImpl(dom) {
        return dom.querySelector("div.content-main .title");
    }
    extractAuthor(dom) {
        let authorLink = dom.querySelector("div.author a");
        return (authorLink === null) ? super.extractAuthor(dom) : authorLink.textContent;
    }
    extractLanguage() {
        return "jp";
    }
    findChapterTitle(dom) {
        return dom.querySelector("h2.episode-title");
    }
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.content-info .cover");
    }
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.abstract")];
    }
}

================================================
FILE: plugin/js/parsers/AmoryaoiParser.js
================================================

"use strict";

parserFactory.register("amor-yaoi.com", () => new AmoryaoiParser());

class AmoryaoiParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("#content a")]
            .filter(a => a.href.includes("&chapter="))
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "#jumpmenu, #pagelinks, #reviewform, #sort");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#output, blockquote")];
    }
}

================================================
FILE: plugin/js/parsers/AnythingNovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("anythingnovel.com", () => new AnythingNovelParser());

class AnythingNovelParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("div#content li a")]
            .reverse()
            .map(link => util.hyperLinkToChapter(link));
        return Promise.resolve(links);        
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div#content h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        super.removeUnwantedElementsFromContentElement(element);
        util.removeElements(element.querySelectorAll("div.ads, div#pagination, div.sharebar"));
        this.removeShareThisChapterLink(element);
    }

    removeShareThisChapterLink(element) {
        let share = element.querySelector("a h2");
        if (share != null) {
            share.parentElement.remove();
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#content div:not(.clearfix)")];
    }

    cleanInformationNode(node) {
        let strip = [...node.querySelectorAll("img")]
            .map(e => e.parentElement);
        util.removeElements(strip);
    }
}

================================================
FILE: plugin/js/parsers/AppYoruWorldParser.js
================================================

"use strict";

parserFactory.register("app.yoru.world", () => new AppYoruWorldParser());

class AppYoruWorldParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/story\/[0-9]+");
        let bookid = dom.baseURI.match(regex)?.[0].slice(7);
        let data = (await HttpClient.fetchJson("https://pxp-main-531j.onrender.com/api/v1/books/" + bookid)).json;
        let notInclude = data.paywall.first_n_chapters;
        let ChapterArray = data.chapters;
        let ChapterArrayFree = ChapterArray.map(a => ({
            sourceUrl: "https://app.yoru.world/en/story/"+bookid+"/read/" + a.id, 
            title: a.title,
            isIncludeable: (a.number <= notInclude || notInclude == null)
        }));
        return ChapterArrayFree.reverse();
    }
    
    async loadEpubMetaInfo(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/story\/[0-9]+");
        let bookid = dom.baseURI.match(regex)?.[0].slice(7);
        let bookinfo = (await HttpClient.fetchJson("https://pxp-main-531j.onrender.com/api/v1/books/" + bookid)).json;
        this.title = bookinfo.title;
        this.author = bookinfo.author.display_name;
        this.tags = bookinfo.tags.map(a => a.name);
        this.description = bookinfo.summary;
        this.img = (await HttpClient.fetchJson("https://pxp-main-531j.onrender.com/api/v1/aws/s3/"+bookinfo.cover.id+":sign_get")).json;
        return;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let documenturl = (await HttpClient.fetchJson(restUrl)).json;
        let rawHTML = (await HttpClient.fetchHtml(documenturl)).responseXML;
        return this.buildChapter(rawHTML, url);
    }

    toRestUrl(url) {
        let regex = new RegExp("[0-9]+$");
        let id = url.match(regex)[0];
        return "https://pxp-main-531j.onrender.com/api/v1/book_chapters/"+id+"/content";
    }

    buildChapter(rawHTML, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        newDoc.content.appendChild(rawHTML.body);
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#about-panel.synopsis")];
    }

    addTitleToContent(webPage, content) {
        let h2 = webPage.rawDom.createElement("h2");
        h2.innerText = webPage.title.trim();
        content.prepend(h2);
    }
}

================================================
FILE: plugin/js/parsers/ArchiveOfOurOwnParser.js
================================================

"use strict";

parserFactory.register("archiveofourown.org", () => new ArchiveOfOurOwnParser());

class ArchiveOfOurOwnParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let isSeries = dom.baseURI.includes("/series/");
        if (isSeries) {
            let chapters = [];
            let works = [...dom.querySelectorAll("ul.series.work > li")];
            for (let work of works) {
                let partialList = await this.processWorkElement(work);
                chapterUrlsUI.showTocProgress(partialList);
                chapters = chapters.concat(partialList);
            }
            return chapters;
        }
    
        let baseUrl = this.getBaseUrl(dom);
        let chaptersElement = dom.querySelector("li.chapter");
        if (chaptersElement === null) {
            return this.singleChapterStory(baseUrl, dom);
        } else {
            let chaptersUrl = dom.querySelector("ul#chapter_index a");
            return this.fetchChapterUrls(chaptersUrl);
        }
    }

    async processWorkElement(work) {
        let chaptersLink = work.querySelector("dd.chapters a");
        return chaptersLink === null 
            ? this.processSingleChapterWork(work)
            : this.processMultiChapterWork(chaptersLink);
    }

    async processSingleChapterWork(work) {
        let link = work.querySelector("h4.heading a");
        return [this.linkToTocEntry(link)];
    }

    async processMultiChapterWork(chaptersLink) {
        let url = this.linkToTocUrl(chaptersLink);
        return this.fetchChapterUrls(url);
    }

    async fetchChapterUrls(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        return [...dom.querySelectorAll("ol.chapter a")]
            .map(link => this.linkToTocEntry(link));
    }

    linkToTocEntry(link) {
        return ({
            sourceUrl: this.setViewAdultFlag(link.href),
            title: link.textContent
        });
    }

    setViewAdultFlag(url) {
        url = new URL(url);
        url.searchParams.set("view_adult", "true");
        return url.href;
    }

    linkToTocUrl(link) {
        let index = link.href.indexOf("/chapters/");
        return link.href.substring(0, index) + "/navigate";
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div#chapters");
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.heading");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("a[rel='author']")?.innerText;
        return author ?? super.extractAuthor(dom);
    }

    extractLanguage(dom) {
        return dom.querySelector("meta[name='language']").getAttribute("content");
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll(".meta .tags a")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.summary blockquote")?.textContent.trim();
    }

    findChapterTitle(dom) {
        let contentHasTitle = dom.querySelector("h3.title");
        return contentHasTitle
            ? null
            : dom.querySelector("h2.heading");
    }

    removeUnwantedElementsFromContentElement(element) {
        this.tagAuthorNotes(element.querySelectorAll(".notes"));
        if (this.userPreferences.removeAuthorNotes.value) {
            let notes = [...element.querySelectorAll(".chapter.preface.group")];
            let title = element.querySelector("h3.title");
            notes[0].replaceWith(title);
            util.removeElements(notes.slice(1));
        }

        util.removeChildElementsMatchingSelector(element, "h3.landmark.heading");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("dl.meta, div.summary, .notes.module")];
    }
}

================================================
FILE: plugin/js/parsers/AsianfanficsParser.js
================================================

"use strict";

parserFactory.register("asianfanfics.com", () => new AsianfanficsParser());

class AsianfanficsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("aside ul");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#user-submitted-body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1#story-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1#chapter-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#bodyText");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.fetchHtml(url)).responseXML;
        let postApi = this.findPostApi(dom);
        if (!util.isNullOrEmpty(postApi)) {
            let restUrl = "https://www.asianfanfics.com" + postApi;
            let json = (await HttpClient.fetchJson(restUrl)).json;
            if (!json.post) {
                json = (await HttpClient.fetchJson(restUrl + "?v=1")).json;                
            }
            this.addJsonToContent(json, dom);
        }
        return dom;
    }

    findPostApi(dom) {
        return [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.startsWith("var postApi"))
            .map(s => s.textContent.split("\"")[1])[0];
    }

    addJsonToContent(json, dom) {
        let content = this.findContent(dom);
        let post = util.sanitize("<div>" + json.post + "</div>")
            .querySelector("div");
        content.append(post);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#story-description, #story-foreword")];
    }
}

================================================
FILE: plugin/js/parsers/AsianHobbyistParser.js
================================================

"use strict";

parserFactory.register("asianhobbyist.com", () => new AsianHobbyistParser());

class AsianHobbyistParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.releases-wrap a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".post-title.entry-title a");
    }

    findContent(dom) {
        let content = super.findContent(dom);
        if (content == null) {
            content = dom.querySelector(".reader-content");
        }
        return content;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.code-block, div.osny-nightmode");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("header.page-header h2, header.page-header h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.details")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, ".btn");
    }    
}

================================================
FILE: plugin/js/parsers/AsianovelParser.js
================================================

"use strict";

parserFactory.register("asianovel.net", () => new AsianovelParser());

class AsianovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".chapter-group__list a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".story__identity-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter__title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".story__summary")];
    }
}

================================================
FILE: plugin/js/parsers/AsstrParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("asstr.org", () => new AsstrParser());

class AsstrParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("body tbody");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("body pre");
    }

    extractTitleImpl(dom) {
        return [...dom.querySelectorAll("h1")].pop();
    }

    customRawDomToContentStep(chapter, content) {
        if (content.tagName.toLowerCase() === "pre") {
            util.convertPreTagToPTags(chapter.rawDom, content, "\n\n");
        }
    }
}

================================================
FILE: plugin/js/parsers/BabelChainParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novel.babelchain.org", () => new BabelChainParser());
//dead url
parserFactory.register("babelnovel.com", () => new BabelChainParser());

class BabelChainParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapters = this.extractChapterList(dom);
        if (chapters.length === 0) {
            let url = dom.baseURI + "/chapters";
            let chapterDom = (await HttpClient.wrapFetch(url)).responseXML;
            chapters = this.extractChapterList(chapterDom);
        }
        return chapters;
    }

    findDiv(element, classPrefix) {
        let candidates = [...element.querySelectorAll("div")]
            .filter(e => e.className.startsWith(classPrefix));
        return 0 < candidates.length ? candidates[0] : null;
    }

    extractChapterList(dom) {
        let menu = this.findDiv(dom, "chapters_list__ttW1Q");
        return (menu === null)
            ? []
            :  util.hyperlinksToChapterList(menu);
    }

    static jsonToChapters(json, chapterUrlBase) {
        return json.data.map(e => ({
            sourceUrl: chapterUrlBase + e.canonicalName,
            title: e.name,
            newArc: null
        }));
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    findCoverImageUrl(dom) {
        let coverImage = this.findDiv(dom, "book-info_wrapper");
        return coverImage === null
            ? null
            : coverImage.querySelector("img").src;
    }

    getInformationEpubItemChildNodes(dom) {
        let synopsis = this.findDiv(dom, "book-info_synopsis-wrapper");
        return synopsis === null ? [] : [synopsis];
    }

    async fetchChapter(url) {
        const rateLimitTo20PagePerMinute = 3000;
        await util.sleep(rateLimitTo20PagePerMinute);
        let contentUrl = url.replace("//babelnovel.com/", "//api.babelnovel.com/v1/") + "/content";
        let xhr = await HttpClient.fetchJson(contentUrl);
        let doc = BabelChainParser.jsonToHtml(xhr.json, contentUrl);
        return doc;
    }
 
    static jsonToHtml(json, contentUrl) {
        let newDoc = Parser.makeEmptyDocForContent(contentUrl);
        let header = newDoc.dom.createElement("h1");
        header.textContent = json.data.name || json.data.canonicalName;
        newDoc.content.appendChild(header);
        let paragraphs = json.data.content.split("\n\n")
            .filter(p => !util.isNullOrEmpty(p));
        for (let text of paragraphs) {
            let p = newDoc.dom.createElement("p");
            p.appendChild(newDoc.dom.createTextNode(text));
            newDoc.content.appendChild(p);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/BakaTsukiParser.js
================================================

/*
  Parses "Full Text" web page on <www.baka-tsuki.org>
*/
"use strict";

parserFactory.registerManualSelect(
    "Baka-Tsuki Full Text Page",
    () => new BakaTsukiParser(new BakaTsukiImageCollector())
);

class BakaTsukiImageCollector extends ImageCollector {
    constructor() {
        super();
        this.selectImageUrlFromImagePage = this.getHighestResImageUrlFromImagePage;
    }

    onUserPreferencesUpdate(userPreferences) {
        super.onUserPreferencesUpdate(userPreferences);
        if (userPreferences.highestResolutionImages.value) {
            this.selectImageUrlFromImagePage = this.getHighestResImageUrlFromImagePage;
        } else {
            this.selectImageUrlFromImagePage = this.getReducedResImageUrlFromImagePage;
        }
    }

    getReducedResImageUrlFromImagePage(dom) {
        let img = dom.querySelector("div.fullImageLink img");
        return (img === null) ? null : util.resolveRelativeUrl(dom.baseURI, img.src);
    }

    getHighestResImageUrlFromImagePage(dom) {
        let link = dom.querySelector("div.fullMedia a");
        return (link === null) ? null : link.href;
    }
}

//==============================================================

class BakaTsukiParser extends Parser {
    constructor(imageCollector) {
        super(imageCollector);
        this.state.firstPageDom = null;
    }

    static register() {
        parserFactory.reregister("baka-tsuki.org", () => new BakaTsukiParser(new BakaTsukiImageCollector()));      
    }

    rebuildImagesToFetch() {
        // needed with Baka-Tsuki, in case user hits "Build EPUB" a second time
        this.imageCollector.reset();
        let content = this.findContent(this.state.firstPageDom).cloneNode(true);
        this.removeUnwantedElementsFromContentElement(content);
        this.imageCollector.findImagesUsedInDocument(content);
        this.imageCollector.setCoverImageUrl(CoverImageUI.getCoverImageUrl());
    }

    populateImageTable() {
        let enable = document.getElementById("coverFromUrlCheckboxInput").checked;
        CoverImageUI.onCoverFromUrlClick(enable, this.imageCollector.imageInfoList);
    }

    static splitContentOnHeadingTags(content) {
        let items = [];
        let nodesInItem = [];
        for (let i = 0; i < content.childNodes.length; ++i) {
            let node = util.wrapRawTextNode(content.childNodes[i]);
            if (BakaTsukiParser.isChapterStart(node)) {
                BakaTsukiParser.appendToItems(items, nodesInItem);
                nodesInItem = [];
            }
            nodesInItem.push(node);
        }
        BakaTsukiParser.appendToItems(items, nodesInItem);
        return items;
    }

    static isChapterStart(node) {
        return util.isHeaderTag(node);
    }

    static appendToItems(items, nodesInItem) {
        BakaTsukiParser.removeTrailingWhiteSpace(nodesInItem);
        if (0 < nodesInItem.length) {
            items.push({ nodes: nodesInItem});
        }
    }

    static removeTrailingWhiteSpace(nodesInItem) {
        let i = nodesInItem.length - 1;
        while ((0 <= i) && util.isElementWhiteSpace(nodesInItem[i])) {
            nodesInItem.pop();
            --i;
        }
    }

    static itemsToEpubItems(items, startAt, sourceUrl) {
        // ToDo: when have image files, this will probably need to be redone.
        let index = startAt;
        return items.map(function(item) {
            let epubItem = new EpubItem(sourceUrl);
            epubItem.setIndex(index);
            epubItem.nodes = item.nodes;
            ++index;
            return epubItem;
        });
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.firstHeading");
    }

    extractSeriesInfo(dom, metaInfo) {
        // assumes <title> element text is "<series name>:Volume <series index> - Baka Tsuki"
        let title = dom.title.trim();
        let splitIndex = title.indexOf(":");
        if (0 < splitIndex) {
            metaInfo.seriesName = title.substring(0, splitIndex);
            metaInfo.seriesIndex = this.extractVolumeIndex(title.substring(splitIndex));
        }
    }

    extractVolumeIndex(volumeString) {
        let volumeIndex = "";
        for (let ch of volumeString) {
            if (("0" <= ch) && (ch <= "9")) {
                volumeIndex += ch;
            }
        }
        return volumeIndex;
    }

    findContent(dom) {
        return dom.querySelector("div.mw-content-ltr");
    }

    onLoadFirstPage(url, firstPageDom) {
        this.state.firstPageDom = firstPageDom;
        this.state.chapterListUrl = url;

        let content = this.findContent(firstPageDom).cloneNode(true);
        this.removeUnwantedElementsFromContentElement(content);
        this.imageCollector.findImagesUsedInDocument(content);
        this.populateImageTable();
    }

    populateUIImpl() {
        document.getElementById("highestResolutionImagesRow").hidden = false;
        document.getElementById("unSuperScriptAlternateTranslations").hidden = false; 
        document.getElementById("imageSection").hidden = false;
        document.getElementById("outputSection").hidden = true;
        document.getElementById("translatorRow").hidden = false;
        document.getElementById("fileAuthorAsRow").hidden = false;
        document.getElementById("coverFromUrlCheckboxInput").onclick = this.populateImageTable.bind(this);
    }

    epubItemSupplier() {
        let content = this.findContent(this.state.firstPageDom).cloneNode(true);
        this.removeUnwantedElementsFromContentElement(content);
        util.fixBlockTagsNestedInInlineTags(content);
        this.replaceImageTags(content);
        util.removeUnusedHeadingLevels(content);
        if (this.userPreferences.unSuperScriptAlternateTranslations.value) {
            BakaTsukiParser.unSuperScriptAlternateTranslations(content);
        }
        util.prepForConvertToXhtml(content);
        util.removeEmptyDivElements(content);
        let epubItems = this.splitContentIntoEpubItems(content, this.state.firstPageDom.baseURI);
        BakaTsukiParser.fixupInternalHyperLinks(epubItems);
        return new EpubItemSupplier(this, epubItems, this.imageCollector);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeScriptableElements(element);

        // discard table of contents (will generate one from tags later)
        util.removeElements(element.querySelectorAll("div#toc"));

        // remove "Jump Up" text that appears beside the up arrow from translator notes
        util.removeElements(element.querySelectorAll("span.cite-accessibility-label"));

        util.removeComments(element);
        BakaTsukiParser.removeUnwantedTable(element);

        // hyperlinks that allow editing text
        util.removeElements(element.querySelectorAll("span.mw-editsection"));
    }

    // There's a table at end of content, with links to other stories on Baka Tsuki.
    // It's not wanted in the EPUB
    static removeUnwantedTable(element) {
        // sometimes the target table has other tables nested in it.
        let tables = [...element.querySelectorAll("table")];
        if (0 < tables.length) {
            let endTable = tables[tables.length - 1];
            let node = endTable;
            while (node.parentNode != null) {
                node = node.parentNode;
                if (node.tagName === "TABLE") {
                    endTable = node;
                }
            }
            if (BakaTsukiParser.isTableContainsHyperLinks(endTable)) {
                endTable.remove();
            }
        }
    }

    static isTableContainsHyperLinks(tableElement) {
        return tableElement.querySelector("a") !== null;
    }

    replaceImageTags(element) {
        BakaTsukiParser.stripGalleryBox(element);
        this.imageCollector.replaceImageTags(element);
    }

    // remove gallery text and move images out of the gallery box so images can take full screen.
    static stripGalleryBox(element) {

        let galleryBoxes = [...element.querySelectorAll("li.gallerybox")];
        if (0 < galleryBoxes.length) {
            BakaTsukiParser.removeTextBeforeGallery(galleryBoxes[0].parentNode);        
        }

        // move images out of the <ul> gallery
        let garbage = new Set();
        for (let listItem of galleryBoxes) {
            util.removeElements(listItem.querySelectorAll("div.gallerytext"));

            let gallery = listItem.parentNode;
            garbage.add(gallery);
            gallery.parentNode.insertBefore(listItem.firstElementChild, gallery);
        }

        // throw away rest of gallery  (note sometimes there are multiple galleries)
        for (let node of garbage) {
            node.remove();
        }
    }

    static removeTextBeforeGallery(gallery) {
        let previous = gallery.previousElementSibling; 
        while ((previous != null) && !util.isHeaderTag(previous)) {
            let temp = previous.previousElementSibling;
            if (previous.tagName.toLowerCase() === "p") {
                previous.remove();
            }
            previous = temp;
        }
    }

    splitContentIntoEpubItems(content, sourceUrl) {
        this.flattenContent(content);
        let items = BakaTsukiParser.splitContentOnHeadingTags(content);
        items = this.consolidateItems(items);
        items = this.discardItemsWithNoVisibleContent(items);
        return BakaTsukiParser.itemsToEpubItems(items, 0, sourceUrl);
    }

    flattenContent(content) {
        // most pages have all header tags as immediate children of the content element
        // where this is not the case, flatten them so that they are.
        for (let i = 0; i < content.childNodes.length; ++i) {
            let node = content.childNodes[i];
            if (this.nodeNeedsToBeFlattened(node)) {
                util.flattenNode(node);
                --i;
            }
        }
    }

    nodeNeedsToBeFlattened(node) {
        let numHeaders = this.numberOfHeaderTags(node);
        return ((1 < numHeaders) || ((numHeaders === 1) && !BakaTsukiParser.isChapterStart(node)));
    }

    numberOfHeaderTags(node) {
        let walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT); 
        let count = 0;
        do {
            if (BakaTsukiParser.isChapterStart(walker.currentNode)) {
                ++count;
            }
        } while (walker.nextNode());
        return count;
    }

    // If an item only holds a heading element, combine with following epubItem.
    // e.g. We're dealing with <h1> followed by <h2>
    consolidateItems(items) {
        let newItems = [ items[items.length - 1] ];
        let i = items.length - 2;
        while (0 <= i) {
            let item = items[i];
            if (item.nodes.length === 1) {
                newItems[0].nodes.unshift(item.nodes[0]);
            } else {
                newItems.unshift(item);
            }
            --i;
        }
        return newItems;
    }

    discardItemsWithNoVisibleContent(items) {
        return items.filter(item => this.hasVisibleContent(item.nodes));
    }

    hasVisibleContent(nodes) {
        for (let node of nodes) {
            if (!util.isElementWhiteSpace(node)) {
                return true;
            }
        }

        // if get here, no visible content
        return false;
    }

    static fixupInternalHyperLinks(epubItems) {
        let targets = BakaTsukiParser.findLinkTargets(epubItems);
        BakaTsukiParser.findAndFixHyperLinks(epubItems, targets);
    }

    static findLinkTargets(epubItems) {
        let targets = new Map();
        BakaTsukiParser.walkEpubItemsWithElements(
            epubItems, 
            targets,
            BakaTsukiParser.recordTarget
        );
        return targets;
    }

    static findAndFixHyperLinks(epubItems, targets) {
        BakaTsukiParser.walkEpubItemsWithElements(
            epubItems, 
            targets,
            BakaTsukiParser.fixHyperlink
        );
    }

    static walkEpubItemsWithElements(epubItems, targets, processFoundNode) {
        for (let epubItem of epubItems) {
            for (let element of epubItem.nodes.filter(e => e.nodeType === Node.ELEMENT_NODE)) {
                let walker = document.createTreeWalker(
                    element, 
                    NodeFilter.SHOW_ELEMENT
                );
                
                // assume first header tag we find is title of the chapter.
                if (util.isHeaderTag(element) && (epubItem.chapterTitle === null)) {
                    epubItem.chapterTitle = element.textContent;
                }
                do {
                    processFoundNode(walker.currentNode, targets, util.makeRelative(epubItem.getZipHref()));
                } while (walker.nextNode());
            }
        }
    }

    static unSuperScriptAlternateTranslations(element) {
        for (let s of util.getElements(element, "span", s => BakaTsukiParser.isPsudoSuperScriptSpan(s))) {
            let sibling = s.nextSibling;
            if ((sibling !== null) && (sibling.tagName.toLowerCase() === "span")) {
                sibling.textContent = sibling.textContent + " (" + s.textContent + ")";
                s.remove();
            }
        }
    }

    static isPsudoSuperScriptSpan(element) {
        let top = element.style.top;
        return (top != null) && (0 < top.length) && (top[0] === "-");
    }

    static recordTarget(node, targets, zipHref) {
        if (node.id != "") {
            targets.set(node.id, zipHref);
        }
    }

    static fixHyperlink(node, targets, unused) { // eslint-disable-line no-unused-vars
        if (node.tagName === "A") {
            let targetId = util.extractHashFromUri(node.href);
            let targetZipHref = targets.get(targetId);
            if (targetZipHref != null) {
                node.href = targetZipHref + "#" + targetId;
            }
        }
    }

    onFetchImagesClicked() {
        if (0 == this.imageCollector.imageInfoList.length) {
            ErrorLog.showErrorMessage(UIText.Error.noImagesFound);
        } else {
            this.fetchContent();
        }
    }

    fetchContent() {
        this.rebuildImagesToFetch();
        this.setUiToShowLoadingProgress(this.imageCollector.numberOfImagesToFetch());
        return this.imageCollector.fetchImages(() => this.updateProgressBarOneStep(), this.state.firstPageDom.baseURI)
            .then(function() {
                main.getPackEpubButton().disabled = false;
            }).catch(function(err) {
                ErrorLog.log(err);
            });
    }

    updateProgressBarOneStep() {
        ProgressBar.updateValue(1);
    }
}

//==============================================================

BakaTsukiParser.register();

================================================
FILE: plugin/js/parsers/BakaTsukiSeriesPageParser.js
================================================

/*
  Parses "Series Page" web page on <www.baka-tsuki.org>
  (i.e. Has volumes in a series and links to chapters)
*/
"use strict";

parserFactory.registerManualSelect(
    "Baka-Tsuki Series Page",
    () => new BakaTsukiSeriesPageParser()
);

class BakaTsukiSeriesPageParser extends Parser {
    constructor() {
        super(new BakaTsukiImageCollector());
    }

    static register() {
        parserFactory.reregister(
            "baka-tsuki.org", 
            function(url) {
                if (BakaTsukiSeriesPageParser.isFullTextPage(url)) {
                    return new BakaTsukiParser(new BakaTsukiImageCollector());
                } else {
                    return new BakaTsukiSeriesPageParser();
                }
            }
        );
    }

    static registerBakaParsers(includeSeriesPage) {
        if (includeSeriesPage) {
            BakaTsukiSeriesPageParser.register();
        } else {
            BakaTsukiParser.register();
        }
    }

    static isFullTextPage(url) {
        let param = util.getParamFromUrl(url, "title");
        return param.includes(":");
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div#content");
        return Promise.resolve(util.hyperlinksToChapterList(menu, 
            BakaTsukiSeriesPageParser.possibleChapterLink));
    }

    static possibleChapterLink(link) {
        let href = link.href;
        return !href.includes("#") && !href.includes("redlink=1");
    }

    findContent(dom) {
        return dom.querySelector("div#mw-content-text");
    }

    populateUIImpl() {
        document.getElementById("highestResolutionImagesRow").hidden = false;
        document.getElementById("unSuperScriptAlternateTranslations").hidden = false; 
        document.getElementById("translatorRow").hidden = false;
        document.getElementById("fileAuthorAsRow").hidden = false;
    }

    // title of the story  (not to be confused with title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector("#firstHeading");
    }

    customRawDomToContentStep(chapter, content) {
        BakaTsukiParser.stripGalleryBox(content);
        if (this.userPreferences.unSuperScriptAlternateTranslations.value) {
            BakaTsukiParser.unSuperScriptAlternateTranslations(content);
        }
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll("div#toc, div#printfooter"));

        // remove "Jump Up" text that appears beside the up arrow from translator notes
        util.removeElements(element.querySelectorAll("span.cite-accessibility-label"));

        BakaTsukiParser.removeUnwantedTable(element);

        // hyperlinks that allow editing text
        util.removeElements(element.querySelectorAll("span.mw-editsection"));
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("#firstHeading");
    }    
}

================================================
FILE: plugin/js/parsers/BetwixtedbutterflyParser.js
================================================

"use strict";

parserFactory.register("betwixtedbutterfly.com", () => new BetwixtedbutterflyParser());

class BetwixtedbutterflyParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.elementor-tab-content a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-inner");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.elementor-heading-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.post-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.elementor-text-editor")].slice(1, 2);
    }
}

================================================
FILE: plugin/js/parsers/BiqugetwParser.js
================================================

"use strict";

parserFactory.register("biquge.tw", () => new BiqugetwParser());

class BiqugetwParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("a.chapterlist").href;
        let tocHtml = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        let menu = tocHtml.querySelector("div.booklist ul");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#chaptercontent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".book h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".book .right h2 a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    findChapterTitle(dom) {
        return dom.querySelector(".book h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom) {
        let isNextPageOfChapter = (link) => link.href.includes("_");
        let nextUrl = [...dom.querySelectorAll("a#next_url")]
            .filter(isNextPageOfChapter)
            .map(a => a.href)
            .pop();
        return nextUrl ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.intro")];
    }
}

================================================
FILE: plugin/js/parsers/BlogspotParser.js
================================================

/*
  parses _.blogspot._
*/
"use strict";

parserFactory.register("sousetsuka.com", () => new BlogspotParser());

parserFactory.registerUrlRule(
    url => (util.extractHostName(url).indexOf(".blogspot.") != -1),
    () => new BlogspotParser()
);

parserFactory.registerRule(
    // return probability (0.0 to 1.0) web page is a Blogspot page
    function(url, dom) {
        return (util.extractHostName(url).indexOf(".blogspot.") != -1) ||
            ((BlogspotParser.findContentElement(dom) != null) * 0.5);
    },
    () => new BlogspotParser()
);

parserFactory.registerManualSelect(
    "Blogspot",
    () => new BlogspotParser()
);

class BlogspotParserImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    extractWrappingUrl(element) {
        let url = super.extractWrappingUrl(element);
        return this.convertToUrlOfOriginalSizeImage(url);
    }

    convertToUrlOfOriginalSizeImage(originalUrl) {
        let url = new URL(originalUrl);
        if (!url.hostname.toLowerCase().includes("blogspot")) {
            return originalUrl;
        }
        let path = url.pathname.split("/");
        path[path.length - 2] = "s0";
        url.pathname = path.join("/");
        return url.href;
    }
}

class BlogspotParser extends Parser {
    constructor() {
        super(new BlogspotParserImageCollector());
    }

    async getChapterUrls(dom) {
        let menu = this.findContent(dom);
        let chapters = util.hyperlinksToChapterList(menu);
        if (0 < chapters.length) {
            return chapters;
        }
        // try "Blog Archive" links
        chapters = [...dom.querySelectorAll("ul.posts a")]
            .map(link => util.hyperLinkToChapter(link));
        return chapters.reverse();
    }

    static findContentElement(dom) {
        return dom.querySelector("div.post-body") ||
            dom.querySelector("div.pagepost div.cover");
    }

    findContent(dom) {
        return BlogspotParser.findContentElement(dom) ||
            dom.querySelector("div.entry-content");
    }

    static findChapterTitleElement(dom) {
        return dom.querySelector("h3.post-title, h1.entry-title");
    }

    findChapterTitle(dom) {
        return BlogspotParser.findChapterTitleElement(dom);
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        let toRemove = util.moveIfParent(link, "span");
        return util.moveIfParent(toRemove, "div");
    }

    findCoverImageUrl(dom) {
        let url = super.findCoverImageUrl(dom);
        return url != null
            ? this.imageCollector.convertToUrlOfOriginalSizeImage(url)
            : null;
    }
}

================================================
FILE: plugin/js/parsers/BnatranslationsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("bnatranslations.com", () => new BnatranslationsParser());

class BnatranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".elementor-text-editor a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("article .post__content .elementor-widget-container");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".page__title h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".page__title h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".elementor-widget-container");
    }

    preprocessRawDom(chapterDom) {
        util.removeChildElementsMatchingSelector(chapterDom, ".elementor-button-wrapper");
        let containers = [...chapterDom.querySelectorAll("article .post__content .elementor-widget-container")];
        let container = containers[0];
        let i = 0;
        while (++i < containers.length) {
            let hasFollowButton = containers[i].querySelector(".wordpress-follow-button") != null;
            if (hasFollowButton) {
                break;
            }
            util.moveChildElements(containers[i], container);
            containers[i].remove();
        }
    }
}

================================================
FILE: plugin/js/parsers/Book18Parser.js
================================================

/*
  Parses files on <www.book18.org>
*/
"use strict";

parserFactory.register("book18.org", () => new Book18Parser());

class Book18Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".list-group");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "span.d-none");
    }
}

================================================
FILE: plugin/js/parsers/BookswithqianyaParser.js
================================================

"use strict";

parserFactory.register("bookswithqianya.com", () => new BookswithqianyaParser());

class BookswithqianyaParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.elementor-tab-content a")]
            .map(a => util.hyperLinkToChapter(a))
            .filter(c => this.isChapterUrl(c.sourceUrl));
    }

    isChapterUrl(url) {
        return !url.includes("/products/") 
            && !url.includes("/novels/")
            && !url.includes("myrics");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".elementor-image-box-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "button");
        super.removeUnwantedElementsFromContentElement(element);
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let footnotes = new FootnoteExtractor().scriptElementsToFootnotes(webPageDom);
        this.moveFootnotes(webPageDom, content, footnotes);
    }
}

================================================
FILE: plugin/js/parsers/Booktoki152Parser.js
================================================

"use strict";

parserFactory.registerUrlRule(
    url => (util.extractHostName(url).startsWith("booktoki")),
    () => new Booktoki152Parser()
);

class Booktoki152Parser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 1500;
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("ul.list-body a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        util.removeChildElementsMatchingSelector(link, "span");
        return ({
            sourceUrl:  link.href,
            title: link.textContent.trim()
        });
    }

    findContent(dom) {
        return dom.querySelector("#novel_content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.view-content span b");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.toon-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.view-title");
    }

    getInformationEpubItemChildNodes(dom) {
        let nodes = [...dom.querySelectorAll("div.view-content div.view-content")];
        return (nodes.length === 3)
            ? [nodes[1]]
            : [];
    }
}

================================================
FILE: plugin/js/parsers/BotitranslationParser.js
================================================

"use strict";

parserFactory.register("botitranslation.com", () => new BotitranslationParser());
parserFactory.register("mystorywave.com", () => new BotitranslationParser());

class BotitranslationParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/book\/[0-9]+");
        let bookid = dom.baseURI.match(regex)?.[0].slice(6);
        let data = (await HttpClient.fetchJson("https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/page?sortDirection=ASC&bookId=" + bookid + "&pageNumber=1&pageSize=100")).json;
        let totalCount = data.data.totalCount;
        if (totalCount > 100) {
            data = (await HttpClient.fetchJson("https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/page?sortDirection=ASC&bookId=" + bookid + "&pageNumber=1&pageSize=" + totalCount)).json;
        }
        let ChapterArray = data.data.list;
        let ChapterArrayFree = ChapterArray.map(a => ({
            sourceUrl: "https://www.botitranslation.com/chapter/" + a.id, 
            title: a.title, 
            isIncludeable: (a.paywallStatus == "free" && a.tier == 0)
        }));
        return ChapterArrayFree;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".book-name");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".author-name");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover-container");
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let leaves = url.split("/");
        let id = leaves[leaves.length - 1].split("-")[0];
        return "https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/" + id;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json.data.title;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.data.content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#about-panel.synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/BoxnovelOrgParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("boxnovel.org", () => new BoxnovelOrgParser());

class BoxnovelOrgParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = BoxnovelOrgParser.extractPartialChapterList(dom);
        let urlsOfTocPages  = BoxnovelOrgParser.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            BoxnovelOrgParser.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        ));
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.list-chapter a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static getUrlsOfTocPages(dom) {
        let urls = [];
        let paginateUrls = [...dom.querySelectorAll("ul.pagination li a:not([rel])")];
        if (0 < paginateUrls.length) {
            let lastUrl = paginateUrls.pop().href;
            let index = lastUrl.lastIndexOf("=");
            let maxPage = parseInt(lastUrl.substring(index + 1));
            let prefix = lastUrl.substring(0, index + 1);
            for (let i = 2; i <= maxPage; ++i) {
                urls.push(`${prefix}${i}`);
            }
        }
        return urls;
    }

    findContent(dom) {
        return dom.querySelector("div#chr-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("a.chr-title").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("div.info"),
            dom.querySelector("div.desc-text"),
        ].filter(n => n != null);
    }
}

================================================
FILE: plugin/js/parsers/BoyloveParser.js
================================================

"use strict";

parserFactory.register("boylove.cc", () => new BoyloveParser());

class BoyloveParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("ul#playlist__item_title_1_url li:not(.chapterOff) a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("section.reader-cartoon-chapter");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.stui-content div.title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.title");
    }

    findCoverImageUrl(dom) {
        let div = dom.querySelector("div.stui-content__thumb [style*=background-image]");
        return "https://boylove.cc" + util.extractUrlFromBackgroundImage(div);
    }

    preprocessRawDom(webPageDom) {
        util.resolveLazyLoadedImages(webPageDom, "article img.lazy", "data-original");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.desc")];
    }
}

================================================
FILE: plugin/js/parsers/Bqg225Parser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.bqg225.com", () => new Bqg225Parser());

class Bqg225Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("div.book_more a").href;
        let tocPage = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        let menu = tocPage.querySelector("div.book_last");
        this.removeToToBottomOfPageLink(menu);
        return util.hyperlinksToChapterList(menu);
    }
    
    removeToToBottomOfPageLink(menu) {
        menu.querySelector("a[style]")?.remove();
    }

    findContent(dom) {
        return dom.querySelector("div#chaptercontent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book_box dt.name")?.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("span.title")?.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.book_about")];
    }
}

================================================
FILE: plugin/js/parsers/Brittanypage43Parser.js
================================================

"use strict";

parserFactory.register("brittanypage43.com", () => new Brittanypage43Parser());

class Brittanypage43Parser extends Parser {
    constructor() {
        super();
    }

    disabled() {
        return UIText.Warning.parserDisabledNotification;
    }
    
    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("a.post-card-content-link")]
            .map(this.linkToChapter).reverse();
    }

    linkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.querySelector(".post-card-title").textContent.trim()
        };
    }

    findContent(dom) {
        return dom.querySelector(".gh-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".post-card-large header h2");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".article-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".post-card-image-link");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".post-card-excerpt")];
    }
}

================================================
FILE: plugin/js/parsers/BuntlsParser.js
================================================

"use strict";

parserFactory.register("buntls.com", () => new BuntlsParser());

class BuntlsParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 2600;
    }

    async getChapterUrls(dom) {
        let all = [...dom.querySelectorAll("#chapter-group-unassigned a")];

        let chapters = all.map(a => ({
            sourceUrl: a.href, 
            title: a.textContent
        }));
        return chapters;
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".story__identity-title h1")?.textContent ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".story__identity-title, .story__summary content-section")];
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".story__thumbnail img")?.src ?? null;
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter__title");
    }

    findContent(dom) {
        return dom.querySelector("#chapter-content");
    }

    removeUnwantedElementsFromContentElement(content) {
        let toremove = content.querySelectorAll("#load-content-button, .wpulike, script");
        for (let element of toremove) {
            element.remove();
        }
        this.makeHiddenElementsVisible(content);
        super.removeUnwantedElementsFromContentElement(content);
    }

    makeHiddenElementsVisible(content) {
        [...content.querySelectorAll("div")]
            .filter(e => (e.style.display === "none"))
            .forEach(e => e.removeAttribute("style"));
    }
}

================================================
FILE: plugin/js/parsers/CangjiParser.js
================================================

"use strict";

parserFactory.register("cangji.net", () => new CangjiParser());

class CangjiParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.walkTocPages(dom, 
            CangjiParser.chaptersFromDom, 
            CangjiParser.nextTocPageUrl, 
            chapterUrlsUI
        ));
    }

    static chaptersFromDom(dom) {
        return [...dom.querySelectorAll("#content .entry-title a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static nextTocPageUrl(dom) {
        let link = dom.querySelector("a.next");
        return link === null ? null : link.href;
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.archive-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".post-tags, .wp-block-ugb-container");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.post-img");
    }
}

================================================
FILE: plugin/js/parsers/CClawTranslationsParser.js
================================================

"use strict";

parserFactory.register(
    "cclawtranslations.home.blog",
    () => new CClawTranslationsParser()
);

class CClawTranslationsParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    // title of the story  (not to be confused with title of each chapter)
    extractTitleImpl(dom) {
        const re = /( \(LN\))|( ToC)/g;
        // regex for removing ToC and (LN) from series title
        return dom.querySelector("h1.entry-title").innerText.replace(re, "");
    }

    // chapter title
    findChapterTitle(dom) {
        const re = /(\w.*)(?<=Volume \d )/g;
        // regex for removing series name from chapter title
        return dom.querySelector("h1.entry-title").innerText.replace(re, "");
    }

    removeUnwantedElementsFromContentElement(element) {
        super.removeUnwantedElementsFromContentElement(element);
        util.removeElements(
            [...element.querySelectorAll("p")].filter(this.hasDiscordOrPatreon)
        );
    }

    hasDiscordOrPatreon(p) {
        let links = [...p.querySelectorAll("a")]
            .map(l => l.href.toLowerCase())
            .filter(h => h.includes("discord") || h.includes("patreon"));
        return 0 < links.length || p.textContent.toLowerCase().includes("patreon");
    }
}

================================================
FILE: plugin/js/parsers/ChaleuriaParser.js
================================================

"use strict";

parserFactory.register("chaleuria.com", () => new ChaleuriaParser());

class ChaleuriaParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let rows = dom.querySelectorAll("table.toctable tr.tocrow");
        if (rows.length>0) {
            return [...rows].map(row => this.rowToChapter(row));
        }
        else {
            let menu = dom.querySelector(".entry-content");
            return util.hyperlinksToChapterList(menu);
        }
    }
    
    rowToChapter(row) {
        let title = row.querySelector("td.toctitle").textContent;
        let link = row.querySelector("button").getAttribute("formaction");
        return {
            sourceUrl:  link,
            title: title
        };        
    }

    findContent(dom) {
        return dom.querySelector(".entry-content, div.elementor-widget-theme-post-content div.elementor-widget-container");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title, h1.elementor-heading-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title, h1.elementor-heading-title");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".entry-content p, div.elementor-widget-theme-post-content div.elementor-widget-container p")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "img");
    }
}

================================================
FILE: plugin/js/parsers/ChichipephParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("chichipeph.com", () => new ChichipephParser());

class ChichipephParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.entry-content a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("article header h3");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.entry-meta");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.entry-content p")]
            .filter(p => p.querySelector("a") === null);
    }
}

================================================
FILE: plugin/js/parsers/ChickengegeParser.js
================================================

"use strict";

parserFactory.register("chickengege.org", () => new ChickengegeParser());

class ChickengegeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul#novelList, ul#extraList, table#novelList");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("article div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".m-a-box, .m-a-box-container");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let footnotes = this.extractFootnotes(webPageDom);
        this.moveFootnotes(webPageDom, content, footnotes);
    }

    extractFootnotes(dom) {
        return [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes("{ toolTips("))
            .map(s => this.scriptToSpan(s, dom));
    }

    scriptToSpan(script, dom) {
        let span = dom.createElement("span");
        span.textContent = this.extractFootnoteText(script);
        return span;
    }

    extractFootnoteText(script) {
        let content = script.textContent.replace("jQuery(\"document\")", "");
        let start = content.indexOf("\"") + 1;
        let end = content.lastIndexOf("\",'");
        return content.substring(start, end);
    }
}

================================================
FILE: plugin/js/parsers/ChineseFantasyNovelsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.chinesefantasynovels.com", () => new ChineseFantasyNovelsParser());

class ChineseFantasyNovelsParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("dl.chapterlist");
        return Promise.resolve(util.hyperlinksToChapterList(menu).reverse());
    }

    findContent(dom) {
        return dom.querySelector("div#BookText");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.btitle h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.status");
        if (authorLabel != null) {
            let textStart = "Author:";
            let  author = authorLabel.textContent;
            if (author.startsWith(textStart)) {
                return author.substring(textStart.length);
            }
        }
        return super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        for (let e of element.querySelectorAll("div.ads, div.link, div.adsb")) {
            e.remove();
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("div#BookCon h1");
    }
}

================================================
FILE: plugin/js/parsers/ChosentwofanficParser.js
================================================

"use strict";

parserFactory.register("chosentwofanfic.com", () => new ChosentwofanficParser());

class ChosentwofanficParser extends Parser {
    constructor() {
        super();
        this.ChacheChapterTitle = new Map();
    }

    async getChapterUrls(dom) {
        let urlparams = new URL(dom.baseURI).searchParams;
        let bookid = urlparams.get("sid");
        let tocHtml = (await HttpClient.wrapFetch("https://chosentwofanfic.com/viewstory.php?sid="+bookid+"&index=1")).responseXML;
        let chapters = [...tocHtml.querySelectorAll("#output a")].filter(a => a.href.includes("viewstory.php?sid="+bookid+"&"));
        let ret = chapters.map(a => ({
            sourceUrl: a.href, 
            title: a.textContent
        }));
        return ret;
    }
    
    async loadEpubMetaInfo(dom) {
        let urlparams = new URL(dom.baseURI).searchParams;
        let bookid = urlparams.get("sid");
        let bookinfo = (await HttpClient.wrapFetch("https://chosentwofanfic.com/viewstory.php?sid="+bookid+"&index=1")).responseXML;
        let pagetitle = [...bookinfo.querySelectorAll("#pagetitle a")].filter(a => a.textContent != "");
        this.title = pagetitle[0].textContent;
        this.author = pagetitle[1].textContent;
        this.description = bookinfo.querySelectorAll("#output .content p")[0].textContent;
        this.img = dom.querySelector("#pagetitle img")?.src ?? null;
        return;
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#output div.content")];
    }

    findContent(dom) {
        return dom.querySelector("#story");
    }

    findChapterTitle(dom) {
        let tmptitle = this.ChacheChapterTitle.get(dom.baseURI);
        return tmptitle;
    }

    preprocessRawDom() {
        if (this.ChacheChapterTitle.size == 0) {
            let pagesToFetch = [...this.state.webPages.values()].filter(c => c.isIncludeable);
            pagesToFetch.map(a => (this.ChacheChapterTitle.set(a.sourceUrl, a.title)));
        }
    }
}

================================================
FILE: plugin/js/parsers/ChrysanthemumgardenParser.js
================================================

"use strict";

parserFactory.register("chrysanthemumgarden.com", () => new ChrysanthemumgardenParser());

class ChrysanthemumgardenParser extends WordpressBaseParser {
    constructor() {
        super();
        this.usedfonts = new Set();
    }

    onStartCollecting() {
        this.usedfonts = new Set();
    }

    populateUIImpl() {
        document.getElementById("passwordRow").hidden = false;
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    async fetchChapter(url) {
        let newDom = (await HttpClient.wrapFetch(url)).responseXML;
        let passwordForm = ChrysanthemumgardenParser.getPasswordForm(newDom);
        if (passwordForm) {
            let formData = ChrysanthemumgardenParser.makePasswordFormData(passwordForm);
            let options = {
                method: "POST",
                credentials: "include",
                body: formData
            };
            newDom = (await HttpClient.wrapFetch(url, {fetchOptions: options})).responseXML;
        }
        return newDom;
    }

    async fetchWebPageContent(webPage) {
        ChapterUrlsUI.showDownloadState(webPage.row, ChapterUrlsUI.DOWNLOAD_STATE_SLEEPING);
        await this.rateLimitDelay();
        ChapterUrlsUI.showDownloadState(webPage.row, ChapterUrlsUI.DOWNLOAD_STATE_DOWNLOADING);
        let pageParser = webPage.parser;
        try {
            let webPageDom = await pageParser.fetchChapter(webPage.sourceUrl);
            delete webPage.error;
            webPage.rawDom = webPageDom;
            pageParser.preprocessRawDom(webPageDom);
            pageParser.removeUnusedElementsToReduceMemoryConsumption(webPageDom);
            let content = pageParser.findContent(webPage.rawDom);
            if (content == null) {
                let errorMsg = UIText.Error.errorContentNotFound(webPage.sourceUrl);
                throw new Error(errorMsg);
            }
            //get fonts from content
            let allnodes = [...content.querySelectorAll("span")];
            let regex = new RegExp(".+style=\"font-family: ([a-zA-Z]+);\".+");
            allnodes = allnodes.map(a => a.outerHTML);
            allnodes = allnodes.filter(a => a.search(regex) != -1);
            allnodes = allnodes.map(a => a.replace(regex, "$1"));
            for (let i = 0; i < allnodes.length; i++) {
                if (!this.usedfonts.has(allnodes[i])) {
                    this.usedfonts.add(allnodes[i]);
                    try {
                        let xhr = await HttpClient.wrapFetch("https://chrysanthemumgarden.com/wp-content/plugins/chrys-garden-plugin/resources/fonts/used/"+allnodes[i]+".woff2");
                        let newfont = new FontInfo(allnodes[i]+".woff2");
                        newfont.arraybuffer = xhr.arrayBuffer;
                        this.imageCollector.imagesToPack.push(newfont);
                    } catch (error) {
                        //
                    }
                }
            }

            return pageParser.fetchImagesUsedInDocument(content, webPage);
        } catch (error) {
            if (this.userPreferences.skipChaptersThatFailFetch.value) {
                ErrorLog.log(error);
                webPage.error = error;
            } else {
                webPage.isIncludeable = false;
                throw error;
            }
        }
    }

    static getPasswordForm(dom) {
        return dom.querySelector("form#password-lock");
    }

    static makePasswordFormData(form) {
        let formData = new FormData();
        let password = document.getElementById("passwordInput").value; 
        formData.append("site-pass", password);
        formData.append("nonce-site-pass", ChrysanthemumgardenParser.getInputValue(form, "#nonce-site-pass"));
        formData.append("_wp_http_referer", ChrysanthemumgardenParser.getInputValue(form, "[name='_wp_http_referer']"));
        return formData;
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        if (!this.userPreferences.removeAuthorNotes.value) {
            let notes = [...webPageDom.querySelectorAll("div.tooltip-container")];
            for (let n of notes) {
                content.appendChild(n);
            }
            this.addLinksToFootnotes(webPageDom);
        }
        util.resolveLazyLoadedImages(webPageDom, "img.br-lazy", "data-breeze");
    }

    static getInputValue(form, selector) {
        return form.querySelector("input" + selector).getAttribute("value");
    }

    addLinksToFootnotes(dom) {
        let makeLink = (id) => {
            let link = dom.createElement("a");
            link.href = "#" + id;
            return link;
        };

        let addParent = (newParent, element) => {
            element.replaceWith(newParent);
            newParent.appendChild(element);
        };

        let addIndexToSpan = (span, index) => {
            let sup = dom.createElement("sup");
            sup.textContent = index;
            span.appendChild(sup);
        };

        let addHyperlinkToSpan = (span, id) =>
            addParent(makeLink(id), span);

        let updateSpan = (span, index, id, backRef) => {
            addIndexToSpan(span, index);
            span.id = backRef;
            addHyperlinkToSpan(span, id);
        };

        let addIndexToFootnote = (title, index) =>
            title.prepend(dom.createTextNode(index + " "));

        let addHyperlinkToFootnote = (title, backRef) => {
            let link = makeLink(backRef);
            util.moveChildElements(title, link);
            title.appendChild(link);
        };

        let updateFootnote = (footnote, index, backRef) => {
            let title = footnote.querySelector(".tooltip-title");
            addIndexToFootnote(title, index);
            addHyperlinkToFootnote(title, backRef);
        };

        let spans = [...dom.querySelectorAll("span.tooltip-toggle")];
        let index = 0;
        for (let span of spans) {
            let id = span.getAttribute("tooltip-target");
            let footnote = dom.querySelector("#" + id);
            let backRef = "back-" + id;
            if (id) {
                ++index;
                updateSpan(span, index, id, backRef);
                updateFootnote(footnote, index, backRef);
            }
        }
    }
}

================================================
FILE: plugin/js/parsers/ChyoaParser.js
================================================

"use strict";

parserFactory.register("chyoa.com", () => new ChyoaParser());

class ChyoaParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.story-map-content a.title")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.layout-content-wrapper");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("story-map-header h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "footer, div.chyoa-adzone, " 
            + "div.ratings, div.links" );
        super.removeUnwantedElementsFromContentElement(element);
    }

    removeNextAndPreviousChapterHyperlinks() {
        // Don't remove next or previous links
        // This is a "choose your own story" like site
        // So user picks links to next chapters
    }
}

================================================
FILE: plugin/js/parsers/ComrademaoParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("comrademao.com", () => new ComrademaoParser());

class ComrademaoParser extends Parser {
    constructor() {
        super();
    }

    disabled() {
        return UIText.Warning.parserDisabledNotification;
    }

    populateUIImpl() {
        document.getElementById("removeOriginalRow").hidden = false; 
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            ComrademaoParser.extractPartialChapterList,
            ComrademaoParser.getUrlsOfTocPages,
            chapterUrlsUI
        ).then(urls => urls.reverse());
    }

    static getUrlsOfTocPages(dom) {
        let pagination = dom.querySelector("nav.pagination");
        let tocUrls = [];
        if (pagination != null ) {
            let tocLinks = [...dom.querySelectorAll("a.page-numbers:not(.next)")]
                .map(a => a.href);
            if (0 < tocLinks.length) {
                let maxPageUrl = tocLinks[tocLinks.length - 1];
                let index = maxPageUrl.lastIndexOf("/", maxPageUrl.length - 2);
                let base = maxPageUrl.substring(0, index + 1);
                let maxPage = parseInt(maxPageUrl.substring(index + 1));
                if (1 < maxPage) {
                    for (let i = 2; i <= maxPage; ++i) {
                        tocUrls.push(`${base}${i}/`);
                    }
                }
            }
        }
        return tocUrls;
    }

    static extractPartialChapterList(dom) {
        let menu = dom.querySelector("table.table");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".site-main article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "button, nav, div#comments");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#thumbnail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#Description")];
    }
}

================================================
FILE: plugin/js/parsers/CoronatranslationParser.js
================================================

"use strict";

parserFactory.register("coronatranslation.com", () => new CoronatranslationParser());

class CoronatranslationParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.walkTocPages(dom, 
            CoronatranslationParser.chaptersFromDom, 
            CoronatranslationParser.nextTocPageUrl, 
            chapterUrlsUI
        )).reverse();
    }

    static chaptersFromDom(dom) {
        return [...dom.querySelectorAll("h2.post-title a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static nextTocPageUrl(dom) {
        let link = dom.querySelector("div.wp-pagenavi a.nextpostslink");
        return link === null ? null : link.href;
    }

    findContent(dom) {
        return dom.querySelector("div.entry");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.post-title");
    }

    getInformationEpubItemChildNodes() {
        return [];
    }
}

================================================
FILE: plugin/js/parsers/CreativeNovelsParser.js
================================================

"use strict";
parserFactory.register("creativenovels.com", () => new CreativeNovelsParser());
class CreativeNovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div#chapter_list_novel_page, div.post_box a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content.content");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll("div.team, div.x-donate-1,"+
            " div.navigation, div.navi, header.entry-header"));
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("header.entry-header h1");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("img.book_cover");
        return (img === null) ? util.getFirstImgSrc(dom, "header") : img.src;
    }

    makeHiddenNodesVisible(node) {
        node.removeAttribute("style");
    }
}

================================================
FILE: plugin/js/parsers/CrimsontranslationsParser.js
================================================

"use strict";

parserFactory.register("crimsontranslations.com", () => new CrimsontranslationsParser());

class CrimsontranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ol.grid");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#root");
    }

    async fetchChapter(url) {
        let contentUrl = url.replace(".com/", ".com/api/");
        let xhr = await HttpClient.fetchJson(contentUrl);
        let doc = this.jsonToHtml(xhr.json.chapterContent);
        return doc;
    }
 
    jsonToHtml(json) {
        let newDoc = Parser.makeEmptyDocForContent();
        let header = newDoc.dom.createElement("h1");
        header.textContent = json.title;
        newDoc.content.appendChild(header);
        this.insertParagraphs(json.content, newDoc.content, newDoc.dom);
        this.addSection(json.footnote, newDoc.content, newDoc.dom, "Footnote:");
        this.addSection(json.chapter_author_note, newDoc.content, newDoc.dom, "Author Note:");
        this.addSection(json.chapter_tl_note, newDoc.content, newDoc.dom, "TL Note:");
        return newDoc.dom;
    }

    addSection(paragraphs, content, dom, title) {
        if (paragraphs != null) {
            let header = dom.createElement("h2");
            header.textContent = title;
            content.appendChild(header);
            this.insertParagraphs(paragraphs, content, dom);
        }
    }

    insertParagraphs(paragraphs, content, dom) {
        for (let text of paragraphs.replace(/\n\n/g, "\r\n").split("\r\n")) {
            let p = dom.createElement("p");
            p.appendChild(dom.createTextNode(text));
            content.appendChild(p);
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.border-2.text-tertiary")];
    }
}

================================================
FILE: plugin/js/parsers/CzbooksParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("czbooks.net", () => new CzbooksParser());

class CzbooksParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-detail .title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".novel-detail span.author a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".name");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".novel-detail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".description")];
    }
}

================================================
FILE: plugin/js/parsers/DaoDivineTlParser.js
================================================

"use strict";

parserFactory.register("dao-divine-tl.com", () => new DaoDivineTlParser());

class DaoDivineTlParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 500;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        // eslint-disable-next-line
        let regex = new RegExp("\/book\/.+");
        let title = dom.baseURI.match(regex)?.[0].slice(6);
        let bookinfo = (await HttpClient.fetchJson("https://api.dao-divine-tl.com/api/bookdata/filter?b_name=" + title)).json;
        let novel_id = bookinfo.novel_id;
        let pageCount = 1;
        let Chapterjsons;
        let chapters = [];
        let partialList;
        for (let i = 1; i <= pageCount; i++) {
            await this.rateLimitDelay();
            Chapterjsons = (await HttpClient.fetchJson("https://api.dao-divine-tl.com/api/book/getChapterMetadata?b_name=" + novel_id + "&page=" + i)).json;
            partialList = this.chaptersFromJson(Chapterjsons);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
            if (i == 1) {
                pageCount = Chapterjsons.pageCount;
            }
        }
        return chapters;
    }

    chaptersFromJson(json) {
        return json.result.map(a => ({
            sourceUrl: "https://www.dao-divine-tl.com/book/" + a.b_name + "/" + a.chapter_no, 
            title: a.title, 
            isIncludeable: !a.is_locked
        }));
    }
    
    async loadEpubMetaInfo(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/book\/.+");
        let title = dom.baseURI.match(regex)?.[0].slice(6);
        let bookinfo = (await HttpClient.fetchJson("https://api.dao-divine-tl.com/api/bookdata/filter?b_name=" + title)).json;
        this.title = bookinfo.title;
        this.author = bookinfo.author;
        this.tags = bookinfo.tags;
        this.tags = this.tags.concat(bookinfo.status);
        this.tags = this.tags.concat(bookinfo.category);
        this.description = bookinfo.description;
        this.img = bookinfo.img;
        return;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let leaves = url.split("/");
        let id = leaves[leaves.length - 2];
        let chapternumber = leaves[leaves.length - 1];
        return "https://api.dao-divine-tl.com/api/book/getChapter?b_name=" + id +"&chapter=" + chapternumber;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json.title;
        newDoc.content.appendChild(title);
        let text = json.content.replace("\n\n", "\n");
        text = text.split("\n");
        let br = newDoc.dom.createElement("br");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/DarkNovelsParser.js
================================================

"use strict";

parserFactory.register("dark-novels.ru", () => new DarkNovelsParser());

class DarkNovelsParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("tr.chapter a")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-info-container h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-cover-container");
    }

    async fetchChapter(url) {
        let fetchUrl = "https://api.dark-novels.ru/v1/books/chapter/";
        let formData = DarkNovelsParser.convertUrlToForm(url);
        let options = {
            method: "POST",
            credentials: "include",
            body: formData
        };
        let xhr = await HttpClient.wrapFetch(fetchUrl, {fetchOptions: options});
        return DarkNovelsParser.buildContentHtml(xhr, fetchUrl);
    }

    static convertUrlToForm(url) {
        let pathName = new URL(url).pathname
            .split("/")
            .filter(p => p !== null)
            .reverse();
        let formData = new FormData();
        formData.append("b", pathName[1]);
        formData.append("f", "html");
        formData.append("c", pathName[0]);
        return formData;
    }

    static async buildContentHtml(xhr, fetchUrl) {
        let newDoc = Parser.makeEmptyDocForContent(fetchUrl);
        let rawContent = await DarkNovelsParser.getStringFromZip(xhr.arrayBuffer);
        let text = "<div id=\"raw\">" + rawContent + "</div>";
        let rawDom = util.sanitize(text);
        let content = rawDom.querySelector("div#raw");
        newDoc.content.appendChild(content);
        return newDoc.dom;
    }
    
    static async getStringFromZip(arrayBuffer) {
        // server is down so i am unable to test the code here is my guess
        let theFile = null;
        let zipreader = await new zip.Uint8ArrayReader(arrayBuffer);
        let Zip = new zip.ZipReader(zipreader, {useWebWorkers: false});
        let ZipContent = await Zip.getEntries();
        ZipContent = ZipContent.filter(a => a.directory == false);
        for (let element of ZipContent) {
            theFile = await element.getData(new zip.TextWriter());
        }
        return theFile;
        /* old implementation
        let zip = await new JSZip().loadAsync(arrayBuffer);
        let theFile = null;
        zip.forEach(function (relativePath, file) {
            if (!file.dir) {
                // can't call file.async() in here, because it's async
                theFile = file;
            }
        });
        return theFile.async("text");
        */
    }
    
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.description")];
    }
}

================================================
FILE: plugin/js/parsers/DasuitlParser.js
================================================

"use strict";

parserFactory.register("dasuitl.com", () => new DasuitlParser());

class DasuitlParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".card_title");
    }    

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".wp-block-buttons");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".card_title");
    }
}

================================================
FILE: plugin/js/parsers/DdxsParser.js
================================================

"use strict";

parserFactory.register("ddxs.com", () => new DdxsParser());

class DdxsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("table:nth-of-type(2) tr a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#contents");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".book h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("dd h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".pic");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".intro")];
    }
}

================================================
FILE: plugin/js/parsers/DefaultParser.js
================================================

/*
  Parser used when can't match a parser for the document
*/
"use strict";

parserFactory.registerManualSelect(
    "Default",
    () => new DefaultParser()
);

class DefaultParser extends Parser {
    constructor() {
        super();
        this.siteConfigs = new DefaultParserSiteSettings();
        this.logic = null;
    }

    getChapterUrls(dom) {
        return Promise.resolve(util.hyperlinksToChapterList(dom.body));
    }

    findContent(dom) {
        let hostName = util.extractHostName(dom.baseURI);
        this.logic = this.siteConfigs.constructFindContentLogicForSite(hostName);
        return this.logic.findContent(dom); 
    }

    populateUI(dom) {
        super.populateUI(dom);
        let hostname = util.extractHostName(dom.baseURI);
        DefaultParserUI.setupDefaultParserUI(hostname, this);
    }

    // override default (keep nearly everything, may be wanted)
    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll("script[src], iframe"));
        util.removeComments(element);
        util.removeUnwantedWordpressElements(element);
        util.removeMicrosoftWordCrapElements(element);
        this.logic.removeUnwanted(element);
    }

    findChapterTitle(dom) {
        return this.logic.findChapterTitle(dom);
    }
}

================================================
FILE: plugin/js/parsers/DeviantArtParser.js
================================================

"use strict";

parserFactory.register("deviantart.com", () => new DeviantArtParser());

class DeviantArtParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.folderview-art a.torpedo-thumb-link")]
            .map(DeviantArtParser.linkToChapter);
        return Promise.resolve(chapters);
    }

    static linkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.href.split("/").pop(),
            newArc: null
        };
    }

    findContent(dom) {
        let content = dom.querySelector("div.dev-view-deviation");
        if (content != null) {
            DeviantArtParser.removeUnwantedImages(content);
        }
        return content;
    }

    static removeUnwantedImages(content) {
        let images = [...content.querySelectorAll("img")];
        if (1 === images.length1) {
            return;
        }
        let wanted = content.querySelector("img.dev-content-full");
        if (wanted === null) {
            wanted = images[0];
        }
        for (let i of images) {
            i.remove();
        }
        content.appendChild(wanted);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.folderview-top h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.username");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }
}

================================================
FILE: plugin/js/parsers/DiurnisParser.js
================================================

"use strict";

parserFactory.register("diurnis.com", () => new DiurnisParser());

class DiurnisParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let baseUrl = dom.baseURI;
        let max = this.extractMaxToc(dom);
        let tocUrls = [];
        for (let i = 2; i <= max; ++i) {
            tocUrls.push(`${baseUrl}?page=${i}`);
        }
        return tocUrls;
    }

    extractMaxToc(dom) {
        let buttons = [...dom.querySelectorAll("main div.justify-center button")];
        return (buttons.length < 4) 
            ? 1
            : parseInt(buttons[buttons.length-2].textContent);
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector("table");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main picture");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        return this.buildChapter(dom, url);
    }

    buildChapter(dom, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = dom.querySelector("h1").textContent;
        newDoc.content.appendChild(title);
        let text = dom.querySelector("p.break-words").textContent
            .replace(/\n\n/g, "\n")
            .split("\n");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
        }
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".pb-4")];
    }
}

================================================
FILE: plugin/js/parsers/DudushugeParser.js
================================================

"use strict";

parserFactory.register("www.dudushuge.com", () => new DudushugeParser());

class DudushugeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = DudushugeParser.extractPartialChapterList(dom);
        let urlsOfTocPages  = DudushugeParser.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            DudushugeParser.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        ));
    }

    static getUrlsOfTocPages(dom) {
        return [...dom.querySelectorAll(".middle > select:nth-child(1) option")]
            .map(opt => new URL(opt.value, dom.baseURI).href);
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("div.section-box:nth-child(4) > ul:nth-child(1) li a")]
            .map(a => util.hyperLinkToChapter(a));
    }
    
    findContent(dom) {
        return dom.querySelector("#content");
    }
        
    extractTitleImpl(dom) {
        return dom.querySelector(".top > h1:nth-child(1)");
    }
    
    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.fix > p:nth-child(1)");
        
        return authorLabel?.textContent.replace("作者：", "").trim() ?? super.extractAuthor(dom);
    }
    
    extractLanguage() {
        return "zh-CN";
    }
    
    extractDescription(dom) {
        return dom.querySelector(".desc").textContent.trim();
    }
    
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".imgbox");
    }
}

================================================
FILE: plugin/js/parsers/DummynovelsParser.js
================================================

"use strict";

parserFactory.register("dummynovels.com", () => new DummynovelsParser());

class DummynovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.chapter-arc-accordion p a")]
            .map(link => ({
                sourceUrl:  link.href,
                title: link.querySelector("label").innerText.trim(),            
            }));
    }

    findContent(dom) {
        return dom.querySelector(".elementor-widget-theme-post-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".elementor-heading-title");
    }

    findChapterTitle(dom) {
        return [...dom.querySelectorAll(".chapter-heading")].pop();
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.site-content");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-synopsis-content")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script, iframe, .code-block");
    }    
}

================================================
FILE: plugin/js/parsers/EdanglarstranslationsParser.js
================================================

"use strict";

parserFactory.register("edanglarstranslations.com", () => new EdanglarstranslationsParser());

class EdanglarstranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("article a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("article div[property='schema:text']");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p")];
    }
}

================================================
FILE: plugin/js/parsers/EightMusesParser.js
================================================

"use strict";

parserFactory.register("www.8muses.com", () => new EightMusesParser());
parserFactory.register("comics.8muses.com", () => new EightMusesParser());

class EightMusesParserImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    initialUrlToTry(imageInfo) {
        return imageInfo.sourceUrl.replace(/\/th\//, "/fl/");
    }
}

class EightMusesParser extends Parser {
    constructor() {
        super(new EightMusesParserImageCollector());
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.gallery a")]
            .map(link => util.hyperLinkToChapter(link))
            .filter(c => !util.isNullOrEmpty(c.title));
    }

    findContent(dom) {
        let content = dom.querySelector("div#content");
        // this.removeOldPages(content);
        for (let i of content.querySelectorAll("img")) {
            if (i.src === "") {
                i.src = i.getAttribute("data-src");
            }
        }
        return content;
    }

    removeOldPages(content) {
        for (let a of [...content.querySelectorAll("a")]) {
            let path = a.href.split("/");
            let file = parseInt(path[path.length - 1]);
            if (file < 63) {
                a.remove();
            }
        }
    }

    findCoverImageUrl() {
        return null;
    }
}

================================================
FILE: plugin/js/parsers/EmpirenovelParser.js
================================================

"use strict";

parserFactory.register("empirenovel.com", () => new EmpirenovelParser());

class EmpirenovelParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let indices = [...dom.querySelectorAll(".pagination a")]
            .map(item => new URL(item?.href)?.searchParams?.get("page"))
            .filter(item => item !== null)
            .map(item => parseInt(item));
        if (0 < indices.length) {
            let urlbuilder = new URL(dom.querySelector(".pagination a").href);
            let lastIndex = Math.max(...indices);
            for (let i = 2; i <= lastIndex; ++i) {
                urlbuilder.searchParams.set("page", i);
                urls.push(urlbuilder.href);
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("a.chapter_link")]
            .map((link) => {
                link.querySelector(".small")?.remove();
                return ({
                    sourceUrl: link.href,
                    title: link.innerText.trim(),
                });
            });
    }

    findContent(dom) {
        return dom.querySelector("#read-novel");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div:nth-child(2) > div > span > a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div:nth-child(1) > ul a")]);
        let regex = new RegExp("^#");
        return tags.map(e => e.textContent.trim().replace(regex, "")).join(", ");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1:not(.show_title)");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [
            ...dom.querySelectorAll("div.col-sm.pe-sm-0 > div:nth-child(1)"),
            ...dom.querySelectorAll("div.bg_dark.p-3.my-2.rounded-3.show_details.max-sm-250.w-100")
        ];
    }
}

================================================
FILE: plugin/js/parsers/EngnovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("engnovel.com", () => new EngnovelParser());

class EngnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = EngnovelParser.extractPartialChapterList(dom);
        let formData = EngnovelParser.getTocFetchInfo(dom);
        chapterUrlsUI.showTocProgress(chapters);
        for (let i = 2; i <= formData.maxPage; ++i) {
            let partialList = await EngnovelParser.fetchPartialChapterList(formData.id, i);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    static getTocFetchInfo(dom) {
        let pagination = [...dom.querySelectorAll("div#pagination a")]
            .map(a => parseInt(a.getAttribute("data-page")));

        return {
            id: dom.querySelector("input#id_post").getAttribute("value"),
            maxPage: Math.max(1, ...pagination)
        };
    }

    static async fetchPartialChapterList(id, page) {
        let fetchUrl = "https://engnovel.com/wp-admin/admin-ajax.php";
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json, text/javascript, */*; q=0.01",
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            credentials: "include",
            body: `action=tw_ajax&type=pagination&id=${id}&page=${page}`
        };
        let json = (await HttpClient.fetchJson(fetchUrl, options)).json;
        let dom = util.sanitize(json.list_chap);
        return EngnovelParser.extractPartialChapterList(dom);
    }

    static extractPartialChapterList(dom) {
        let chapterlist = [...dom.querySelectorAll("ul.list-chapter")].pop();
        return util.hyperlinksToChapterList(chapterlist);
    }    

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("a.chapter-title").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc-text")];
    }
}

================================================
FILE: plugin/js/parsers/ErofusParser.js
================================================

"use strict";

parserFactory.register("erofus.com", () => new ErofusParser());

class ErofusParserImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    selectImageUrlFromImagePage(dom) {
        let img = dom.querySelector("div#picture-full img");
        if (img != null)
        {
            return dom.querySelector("div#picture-full img").src;
        }
    }
}

class ErofusParser extends Parser {
    constructor() {
        super(new ErofusParserImageCollector());
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div a div.thumbnail")]
            .map(div => util.hyperLinkToChapter(div.parentElement))
            .filter(c => !util.isNullOrEmpty(c.title));
    }

    findContent(dom) {
        return dom.querySelector("div.content");
    }

    findCoverImageUrl() {
        return null;
    }
}

================================================
FILE: plugin/js/parsers/EstarParser.js
================================================

"use strict";

parserFactory.register("estar.jp", () => new EstarParser());

class EstarParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let rule = 
        [{
            "id": 1,
            "priority": 1,
            "action": {
                "type": "modifyHeaders",
                "requestHeaders": [{ "header": "origin", "operation": "remove" }]
            },
            "condition": { "urlFilter" : "estar.jp"}
        }];
        await HttpClient.setDeclarativeNetRequestRules(rule);

        let leaves = dom.baseURI.split("/");
        let id = leaves[leaves.length - 1];
        let fetchUrl = "https://estar.jp/api/graphql";
        let formData = {"query":"pages/novels/workId/episodes","data":{"workId":id,"first":30,"page":1}};
        let header = {"Content-Type": "application/json;charset=UTF-8", "x-from": "https://estar.jp/"};
        let options = {
            method: "POST",
            credentials: "include",
            body: JSON.stringify(formData),
            headers: header
        };
        let bookinfo = (await HttpClient.fetchJson(fetchUrl, options)).json;
        formData = {"query":"pages/novels/workId/episodes","data":{"workId":id,"first":bookinfo.data.novel.episodeCount,"page":1}};
        options = {
            method: "POST",
            credentials: "include",
            body: JSON.stringify(formData),
            headers: header
        };
        bookinfo = (await HttpClient.fetchJson(fetchUrl, options)).json;
        let chapters = bookinfo.data.novel.episodes.nodes.map(a => ({
            sourceUrl: "https://estar.jp/novels/"+bookinfo.data.novel.workId+"/viewer?page="+a.pageNo, 
            title: a.title
        }));
        return chapters;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.info .title").textContent;
    }

    extractAuthor(dom) {
        return dom.querySelector("div.info .nickname").textContent;
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll(".tags a")];
        return tags.map(a => a.textContent).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector(".description").textContent.trim();
    }

    findCoverImageUrl(dom) {
        let pic = dom.querySelector(".novelData picture meta");
        return pic.content;
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        return this.buildChapter(dom, url);
    }

    buildChapter(dom, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = dom.querySelector("h1.subject").textContent;
        newDoc.content.appendChild(title);
        let text = dom.querySelector(".mainBody .content").textContent;
        text = text.replace("\n\n", "\n");
        text = text.split("\n");
        let br = newDoc.dom.createElement("br");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/ExiledrebelsscanlationsParser.js
================================================

"use strict";

parserFactory.register("exiledrebelsscanlations.com", () => new ExiledrebelsscanlationsParser());

class ExiledrebelsscanlationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.lcp_catlist a")]
            .map((a) => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#wtr-content")
            || dom.querySelector("div.entry-content");
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }

    preprocessRawDom(webPageDom) {
        if (!this.userPreferences.removeAuthorNotes.value) {
            let notes = [...webPageDom.querySelectorAll("div.easy-footnote-title, ol.easy-footnotes-wrapper")];
            let content = this.findContent(webPageDom);
            this.tagAuthorNotes(notes);
            for (let e of notes) {
                content.appendChild(e);
            }
        }
    }
}

================================================
FILE: plugin/js/parsers/FanFicParadiseParser.js
================================================

"use strict";

parserFactory.register("fanficparadise.com", () => new FanFicParadiseParser());

class FanFicParadiseParser extends Parser {
    constructor() {
        super();
        this.cache = new FetchCache();
        this.minimumThrottle = 50; //182 at 20
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("li.threadmarkListItem a")]
            .filter(this.isLinkToChapter);
        return chapters.map(a => util.hyperLinkToChapter(a));
    }

    isLinkToChapter(link) {
        return !link.querySelector("date")
            && !(new URL(link.href).pathname.startsWith("/awards/award"));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.p-title-value");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.username");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    async fetchChapter(url) {
        let fetchedDom = await this.cache.fetch(url);
        let newDoc = Parser.makeEmptyDocForContent(url);
        let newUrl = new URL(url);
        let id = newUrl.hash.substring(1) || newUrl.href.substring(newUrl.href.lastIndexOf("/") + 1);
        let parent;
        if (id == "") {
            parent = fetchedDom.querySelector("li.hasThreadmark");
        } else {
            parent = fetchedDom.querySelector(`li.hasThreadmark[id='${id}']`);
        }
        this.addTitleToChapter(newDoc, parent);
        let content = parent.querySelector(".messageContent article");
        util.resolveLazyLoadedImages(content, "img.lazyload");
        newDoc.content.appendChild(content);
        return newDoc.dom;
    }

    addTitleToChapter(newDoc, parent) {
        let titleElement = parent.querySelector("span.label");
        let title = newDoc.dom.createElement("h1");
        title.textContent = titleElement.textContent.trim();
        newDoc.content.appendChild(title);
    }
}

================================================
FILE: plugin/js/parsers/FanFictionParser.js
================================================

/*
  Parses files on <www.fanfiction.net>
*/
"use strict";

parserFactory.register("www.fanfiction.net", () => new FanFictionParser());

// fictionpress.com has same format as fanfiction.net
parserFactory.register("www.fictionpress.com", () => new FanFictionParser());

class FanFictionParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 3050;
    }

    async getChapterUrls(dom) {
        let baseUrl = this.getBaseUrl(dom);
        let options = this.getOptions(dom);
        // no list of chapters found, assume it's a single chapter story
        return (options.length === 0) 
            ? this.singleChapterStory(baseUrl, dom)
            : options.map(option => this.optionToChapterInfo(baseUrl, option));
    }

    getOptions(dom) {
        return [...dom.querySelectorAll("select#chap_select option")];
    }

    optionToChapterInfo(baseUrl, optionElement) {
        // constructing the URL is a bit complicated as the value is only part of URL.
        let onchange = optionElement.parentElement.getAttribute("onchange");
        onchange = onchange.split("'");
        let url = new URL(baseUrl);
        url.pathname = onchange[1] + optionElement.getAttribute("value") + onchange[3];
        return {
            sourceUrl:  url.href,
            title: optionElement.innerText
        };
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div.storytext");
    }

    extractTextFromProfile(dom, tag) {
        return dom.querySelector("div#profile_top " + tag).textContent.trim();
    }

    extractTitleImpl(dom) {
        return this.extractTextFromProfile(dom, "b");
    }

    extractAuthor(dom) {
        return this.extractTextFromProfile(dom, "a");
    }

    async fetchChapter(url) {
        let dom = await super.fetchChapter(url);
        this.addTitleToChapter(url, dom);
        return dom;
    }

    async fetchWebPageContent(webPage)
    {
        try
        {
            return await super.fetchWebPageContent(webPage);
        }
        catch (ex)
        {
            //Determine if path contains extra parameters. Immediately fail if already shortened.
            //Shortened URI is not always ideal solution; apparently related to caching on server. 
            let regex = /(https?:\/\/(?:www\.)?\w+\.\w+\/s\/\d+\/\d+\/)[a-z\-0-9]+/i;
            let shortUri = regex.exec(webPage.sourceUrl);
            if (shortUri)
            {
                //Primary failure condition - catch where fanfiction controller fails to forward view
                console.log(`Failed to load URI [${webPage.sourceUrl}] - Attempting alternative. [${shortUri[1]}]`);
                //Await throttle timer again for second page fetch.
                await this.rateLimitDelay();
                webPage.sourceUrl = shortUri[1];
                return await this.fetchWebPageContent(webPage);
            }
            else if (webPage.sourceUrl.endsWith("/"))
            {
                //Secondary failure condition - catch where fanfiction controller failed to load from cache
                let newUrl = webPage.sourceUrl.slice(0, -1);
                console.log(`Failed to load URI [${webPage.sourceUrl}] - Attempting alternative. [${newUrl}]`);
                //Await throttle timer again for second page fetch.
                await this.rateLimitDelay();
                webPage.sourceUrl = newUrl;
                return await this.fetchWebPageContent(webPage);
            }
            else
            {
                throw ex;
            }
        }
    }

    addTitleToChapter(url, dom) {
        let path = url.split("/");
        let chapterId = path[path.length - 2];
        for (let option of this.getOptions(dom)) {
            if (chapterId === option.getAttribute("value")) {
                let title = dom.createElement("H1");
                title.appendChild(dom.createTextNode(option.textContent));
                let content = this.findContent(dom);
                content.insertBefore(title, content.firstChild);
                break;
            }
        }
    }

    populateInfoDiv(infoDiv, dom) {
        for (let n of this.getInformationEpubItemChildNodes(dom).filter(n => n != null)) {
            let clone = util.sanitizeNode(n);
            this.cleanInformationNode(clone);
            if (clone != null) {
                // convert dates to avoid '19hours ago'
                for (let s of clone.querySelectorAll("span[data-xutime]")) {
                    let time = new Date(1000*s.getAttribute("data-xutime"));
                    s.textContent = time.toLocaleString();
                }
                // fix relative url links.
                for (let a of clone.querySelectorAll("a[href]")) {
                    a.href = new URL(a["href"], dom.baseURI).href;
                }
                // Fix for > from CSS
                for (let s of clone.querySelectorAll("span.icon-chevron-right")) {
                    s.textContent = " > ";
                }
                infoDiv.appendChild(clone);
            }
        }
        // this "page" doesn't go through image collector, so strip images
        util.removeChildElementsMatchingSelector(infoDiv, "img");
    }

    findCoverImageUrl(dom) {
        let big = dom.querySelector("div#img_large img");
        if (big !== null) {
            let img = big.getAttribute("data-original");
            if (!util.isNullOrEmpty(img)) {
                return "https://www.fanfiction.net" + img;
            }
        }
        return util.getFirstImgSrc(dom, "div#profile_top");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#pre_story_links, div#profile_top")];
    }

    extractSubject(dom) {
        let tags = [...dom.querySelector("#profile_top  span.xgray").childNodes].filter(a => a.nodeName == "#text")[1].textContent;
        let regex = new RegExp(/( - Chapters: .*)|( - Words: .*)/);
        tags = tags.replace(regex, "").replaceAll(",", ";").replaceAll(" - ", ", ").split(",");
        return tags.map(e => e.trim()).filter(a => a != "").join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("#profile_top div.xcontrast_txt").textContent.trim();
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "button, span[title]");
    }
}

================================================
FILE: plugin/js/parsers/FanficusParser.js
================================================

"use strict";

parserFactory.register("fanficus.com", () => new FanficusParser());

class FanficusParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".ff-chapters-body");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let path = new URL(url).pathname;
        let contentUrl = "https://fanficus-server-mirror-879c30cd977f.herokuapp.com/api/v1" + path;
        let xhr = await HttpClient.fetchJson(contentUrl);
        let doc = this.jsonToHtml(xhr.json);
        return doc;
    }
 
    jsonToHtml(json) {
        let newDoc = Parser.makeEmptyDocForContent();
        let header = newDoc.dom.createElement("h1");
        header.textContent = json.value.title;
        newDoc.content.appendChild(header);
        let doc = util.sanitize("<div id='start'>" + json.value.text + "</div>");
        newDoc.content.appendChild(doc.querySelector("div#start"));
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("app-post-main-info")];
    }
}

================================================
FILE: plugin/js/parsers/FastNovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("fastnovel.net", () => new FastNovelParser());
//dead url
parserFactory.register("novelgate.net", () => new FastNovelParser());

class FastNovelParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div#list-chapters li a")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.film-info h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.film-info ul.meta-data a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.episode-name");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("div.book-cover");
        return img === null ? null : img.getAttribute("data-original");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.film-content")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "div.tags");
    }    
}

================================================
FILE: plugin/js/parsers/FenrirealmParser.js
================================================

"use strict";

parserFactory.register("fenrirealm.com", () => new FenrirealmParser());

class FenrirealmParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".grid-chapter");
        return [...menu.querySelectorAll("a")]
            .map(a => this.hyperLinkToChapter(a))
            .reverse();
    }

    hyperLinkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector("span").textContent.trim(),
        });
    }

    findContent(dom) {
        return dom.querySelector("[id^='reader-area-']");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".main-area > .container h1");
    }

    findChapterTitle(dom) {
        let titleText = dom.querySelector("h1").textContent;
        return this.removeDuplicatedChapterPrefix(titleText);
    }

    removeDuplicatedChapterPrefix(titleText) {
        let parts = titleText.split(":");
        return (parts.length >= 2) && (parts[0].trim() === parts[1].trim())
            ? parts.slice(1).join(":")
            : titleText;
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector(".main-area .container:nth-of-type(2) img:nth-of-type(2)");
        return img?.src || null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/Ffxs8Parser.js
================================================

"use strict";

parserFactory.register("ffxs8.com", () => new Ffxs8Parser());

class Ffxs8Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.catalog");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.article h1");
    }
    
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover");
    }

    async fetchChapter(url) {
        return (await HttpClient.wrapFetch(url, this.makeOptions())).responseXML;
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gb2312")
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.descInfo")];
    }
}

================================================
FILE: plugin/js/parsers/FicbookParser.js
================================================

"use strict";

parserFactory.register("ficbook.net", () => new FicbookParser());
parserFactory.register("fic.fan", () => new FicbookParser());
parserFactory.register("fanfictionero.com", () => new FicbookParser());
parserFactory.register("ficador.com", () => new FicbookParser());

class FicbookParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let links = [...dom.querySelectorAll("a.part-link")];
        if (links.length == 0) {
            return [{
                sourceUrl: dom.baseURI, 
                title: dom.querySelector("#part_content > div.title-area.text-center.word-break > h2").textContent
            }];
        }
        let chapters = [];
        for (let link of links) {
            chapters.push({
                sourceUrl: link.href,
                title: link.innerText
            });
            chapterUrlsUI.showTocProgress(chapters);
        }
        return chapters;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("meta[property='og:image']").getAttribute("content");
    }
    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("#content");
    }
    customRawDomToContentStep(chapter, content) {
        let paragraphed_text = content.innerText.split("\n\n").map(x=>"<p>" + x + "</p>").join("");
        let sanitized_text = util.sanitize("<div id='content'>" + paragraphed_text + "</div>")
            .querySelector("#content");
        content.replaceChildren();
        util.moveChildElements(sanitized_text, content);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.heading");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("a.creator-username")?.innerText;
        return author ?? super.extractAuthor(dom);
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.description strong, div.description a")]);
        return tags.map(e => e.textContent).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("meta[name='description']")?.textContent;
    }
    extractSeriesInfo(dom, metaInfo) {  // eslint-disable-line no-unused-vars
        metaInfo.fileName = this.extractTitleImpl(dom).textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("#part_content h2[itemprop='headline']");
    }
}

================================================
FILE: plugin/js/parsers/FictioneerParser.js
================================================

"use strict";

// This is for the Fictioneer WordPress theme: <https://github.com/Tetrakern/fictioneer>

//dead urls
parserFactory.register("blossomtranslation.com", () => new FictioneerParser());
parserFactory.register("igniforge.com", () => new FictioneerParser());
parserFactory.register("razentl.com", () => new FictioneerParser());
//these still exist
parserFactory.register("emberlib731.xyz", () => new FictioneerParser());
parserFactory.register("lilyonthevalley.com", () => new FictioneerParser());
parserFactory.register("novelib.com", () => new FictioneerParser());
parserFactory.register("smeraldogarden.com", () => new FictioneerParser());
parserFactory.register("springofromance.com", () => new FictioneerParser());

parserFactory.registerRule(
    (url, dom) => FictioneerParser.isFictioneerTheme(dom) * 0.7,
    () => new FictioneerParser()
);

class FictioneerParser extends Parser {
    constructor() {
        super();
    }

    static isFictioneerTheme(dom) {
        // the html tag has the class "fictioneer-theme"
        return (dom.querySelector("html.fictioneer-theme") !== null);
    }

    async getChapterUrls(dom) {
        let chapters = [];
        // Put free chapters first
        [...dom.querySelectorAll(".chapter-group__list ._publish a")].map(a => chapters.push(({
            sourceUrl: a.href,
            title: a.textContent,
            isIncludeable: true
        })));
        // Put scheduled chapters after free and don't select them
        [...dom.querySelectorAll("._future a")].map(a => chapters.push(({
            sourceUrl: a.href,
            title: a.textContent,
            isIncludeable: false
        })));

        if (chapters.length === 0) {
            chapters = [...dom.querySelectorAll(".chapter-group__list-item a")]
                .map(a => util.hyperLinkToChapter(a));
        }

        return chapters;
    }

    // the element holding chapter content
    findContent(dom) {
        const content =
            dom.querySelector(".chapter-formatting") ||
            dom.querySelector("#chapter-content");

        const footnotes = dom.querySelector(".chapter__footnotes");
        if (footnotes) { content.appendChild(footnotes); }

        return content;
    }

    // title of the story (not title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector(".story__identity-title");
    }

    extractAuthor(dom) {
        let author =
            dom.querySelector("a.author").textContent ||
            dom.querySelector(".story__identity-meta").textContent;
        // remove "by " from the beginning if it exists
        author = author.replace(/^by /, "");
        return author;
    }

    // story description
    extractDescription(dom) {
        return dom.querySelector(".story__summary").textContent.trim();
    }

    findChapterTitle(dom) {
        // some sites use subtitles and chapter groups and info is lost without them
        let title = dom.querySelector(".chapter__title")?.textContent;
        let subtitle =
            dom.querySelector(".chapter__second-title")?.textContent ||
            dom.querySelector(".chapter__group")?.textContent;
        if (subtitle) { title += ": " + subtitle; }
        return title;
    }

    findCoverImageUrl(dom) {
        let img =
            dom.querySelector(".wp-post-image") ||
            dom.querySelector("figure.story__thumbnail img");

        if (!img?.src) return null;

        // Strip off the arguments for smaller sizes
        let url = img.src;
        const pos = url.indexOf("?");
        return pos !== -1 ? url.substring(0, pos) : url;
    }

    preprocessRawDom(chapterDom) {
        let antiScrape = chapterDom.querySelector(".tiv-anti-scrape")?.parentNode;
        if (!antiScrape) return;

        let payloadEl = antiScrape.querySelector("script");
        if (!payloadEl) return;

        let data = JSON.parse(payloadEl.textContent || payloadEl.innerText || "{}");
        antiScrape.replaceChildren();
        let cryptNode = chapterDom.createElement("p");
        cryptNode.className = "encryptedPayload";
        cryptNode.textContent = data.data;
        antiScrape.appendChild(cryptNode);
    }

    customRawDomToContentStep(chapter, content) {
        content.querySelectorAll("*").forEach(element => {
            if (element.tagName === "P") {
                element.removeAttribute("id");
                element.removeAttribute("data-paragraph-id");
            }
            // remove style attribute if style="font-weight: 400;" - it"s just noise
            if (element.hasAttribute("style") && element.getAttribute("style") === "font-weight: 400;") {
                element.removeAttribute("style");
            }
        });
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll("iframe, .eoc-chapter-groups, .chapter-nav, .related-stories-block"));
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".story__header, .story__summary")];
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll(".story__taxonomies .tag-pill")]);
        return tags.map(t => t.textContent?.trim()).join(", ");
    }
}

================================================
FILE: plugin/js/parsers/FictionhuntParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("fictionhunt.com", () => new FictionhuntParser());

class FictionhuntParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("a.StoryContents__chapter-name")]
            .map(this.linkToChapter);
    }

    linkToChapter(link) {
        let label = link.querySelector(".chapter-number").textContent;
        let title = link.querySelector(".chapter-title").textContent;
        return ({
            sourceUrl:  link.href,
            title: label + ": " + title
        });
    }

    findContent(dom) {
        return dom.querySelector("div.StoryChapter__text");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        return dom.querySelector(".Story__meta a")?.textContent ?? null;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2.js-chapter-title");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.text-justify")];
    }
}

================================================
FILE: plugin/js/parsers/FictionManiaParser.js
================================================

/*
  parses fictionmania.tv
  Notes:

- For this to work, need to go to page with set of chapters.
- If book has more than 25 chapters, will need to get each set to chapters and
    put them together manually using "Edit Chapter URLs"
*/
"use strict";

parserFactory.register("fictionmania.tv", () => new FictionManiaParser());

class FictionManiaParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = util.hyperlinksToChapterList(dom.body, this.isChapterHref);
        return Promise.resolve(chapters.reverse());
    }

    isChapterHref(link) {
        return (link.pathname.indexOf("/stories/readhtmlstory.html") != -1) ||
            (link.pathname.indexOf("/stories/readtextstory.html") != -1);
    }

    findContent(dom) {
        let content = util.getElement(dom, "div", e => (e.style.marginLeft !== ""));
        if (content === null) {
            // older versions have text in a <pre> element
            content = dom.querySelector("pre");
        }
        return content;
    }

    customRawDomToContentStep(chapter, content) {
        if (content.tagName.toLowerCase() === "pre") {
            util.convertPreTagToPTags(chapter.rawDom, content, "\n\n");
        }
    }

    extractTitleImpl(dom) {
        return util.getElement(dom.body, "a", e => this.isChapterHref(e));
    }

    extractAuthor(dom) {
        let author = dom.querySelector("a[href*='/searchdisplay/authordisplay.html?word=']");
        return (author === null) ? super.extractAuthor(dom) : author.innerText;
    }
}

================================================
FILE: plugin/js/parsers/FicwadParser.js
================================================

/*
  Parses files on ficwad.com
*/
"use strict";

parserFactory.register("ficwad.com", () => new FicwadParser());

class FicwadParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        if (this.isStoryIndexPage(dom)) {
            return Promise.resolve(this.getChaptersFromStoryIndex(dom));
        }

        let baseUrl = this.getBaseUrl(dom);
        let options = [...dom.querySelectorAll("form[name='chapterlist'] option")];
        if (options.length ===0) {
            // no list of chapters found, assume it's a single chapter story
            return Promise.resolve(this.singleChapterStory(baseUrl, dom));
        } else {
            return Promise.resolve(
                options.map(option => this.optionToChapterInfo(baseUrl, option))
            );
        }
    }

    isStoryIndexPage(dom) {
        return this.findContent(dom) === null;
    }
    
    getChaptersFromStoryIndex(dom) {
        return [...dom.querySelectorAll("div#chapters h4 a")]
            .map(a => util.hyperLinkToChapter(a));
    }
    
    optionToChapterInfo(baseUrl, optionElement) {
        let relativeUrl = optionElement.getAttribute("value");
        let url = util.resolveRelativeUrl(baseUrl, relativeUrl);
        return {
            sourceUrl:  url,
            title: optionElement.innerText
        };
    }

    findContent(dom) {
        return dom.querySelector("div#storytext");
    }

    extractTitleImpl(dom) {
        if (this.isStoryIndexPage(dom)) {
            return dom.querySelector("div.storylist h4");
        }

        // assume dom is first chapter of story
        let titles = [...dom.querySelectorAll("div#story h2 a")];
        if (0 < titles.length) {
            return titles.pop();
        }
    }

    extractAuthor(dom) {
        return dom.querySelector("span.author a").textContent.trim();
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("div.storylist h4");
        if (title !== null) {
            let s = title.textContent;
            for (let link of title.querySelectorAll("a")) {
                link.remove();
            }
            title.textContent = s;
        }
        return title;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.storylist")];
    }
}

================================================
FILE: plugin/js/parsers/FimfictionParser.js
================================================

"use strict";

parserFactory.register("fimfiction.net", () => new FimfictionParser());

class FimfictionParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("ul.chapters a.chapter-title")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#chapter");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("a.story_name").textContent;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.info-container a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "h1.chapter-title div[style='float:right']");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.story_container__story_image");
    }

    getInformationEpubItemChildNodes(dom) {
        let likes = dom.querySelector("span.likes");
        likes.textContent = "Likes: " + likes.textContent;
        return [...dom.querySelectorAll("span.description-text, "
            + "div.chapters-footer div.word_count")].concat(likes);
    }
}

================================================
FILE: plugin/js/parsers/FlyingLinesParser.js
================================================

"use strict";

parserFactory.register("flying-lines.com", () => new FlyingLinesParser());

class FlyingLinesParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.chapter-container");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.title h2");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("ul.profile li");
        if (authorLabel === null) {
            return super.extractAuthor(dom);
        }
        util.removeChildElementsMatchingSelector(authorLabel, "span");
        return authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-thumb");
    }

    // this is basically identical to NovelSpread
    fetchChapter(url) {
        return HttpClient.wrapFetch(url).then(function(xhr) {
            let restUrl = FlyingLinesParser.extractRestUrl(xhr.responseXML);
            return HttpClient.fetchJson(restUrl);
        }).then(function(handler) {
            return FlyingLinesParser.buildChapter(handler.json.data);
        });
    }

    static extractRestUrl(dom) {
        let chapterId = dom.querySelector("div.main_body")
            .getAttribute("data-chapter-id");
        return `https://www.flying-lines.com/chapter/${chapterId}`;
    }

    static buildChapter(json) {
        let base = "https://www.flying-lines.com" + json.path;
        let newDoc = Parser.makeEmptyDocForContent(base);
        let title = newDoc.dom.createElement("h1");
        title.textContent = `${json.chapter_number}. ${json.chapter_title}`;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.chapter_content);
        for (let n of [...content.body.childNodes]) {
            if (n.className !== "siteCopyrightInfo") {
                newDoc.content.appendChild(n);
            }
        }
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-info, div.synopsis-detail")];
    }
}

================================================
FILE: plugin/js/parsers/FoxaholicParser.js
================================================

"use strict";

parserFactory.registerUrlRule(
    url => (util.extractHostName(url).endsWith("foxaholic.com")),
    () => new FoxaholicParser()
);

class FoxaholicParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.page-content-listing a")]
            .map(a => util.hyperLinkToChapter(a))
            .reverse();
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("ol.breadcrumb li.active");
        return (title === null) 
            ? dom.querySelector(".item-title")
            : title.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.description-summary")];
    }    
}

================================================
FILE: plugin/js/parsers/FoxtellerParser.js
================================================

"use strict";

parserFactory.register("foxteller.com", () => new FoxtellerParser());

class FoxtellerParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".card li a")]
            .map(link => util.hyperLinkToChapter(link));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.novel-title h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "figure.novel-featureimg");
    }

    async fetchChapter(url) {
        let chapterDom = (await HttpClient.wrapFetch(url)).responseXML;
        let content = (await this.fetchContentForChapter(chapterDom));
        let newDoc = Parser.makeEmptyDocForContent(url);
        let header = newDoc.dom.createElement("h1");
        header.textContent = chapterDom.querySelector("div.page-header h3").textContent;
        newDoc.content.appendChild(header);
        newDoc.content.appendChild(content.querySelector("article"));
        return newDoc.dom;        
    }

    async fetchContentForChapter(dom) {
        let novelRegex = /.*?novel_id'\s?:\s?'([\w\s]+)'/i;
        let chapRegex = /.*?chapter_id'\s?:\s?'([\w\s]+)'/i;

        let html = dom.head.innerText;
        let storyID = html.match(novelRegex)[1];
        let chapterID = html.match(chapRegex)[1];
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },
            credentials: "include",
            body: JSON.stringify({x1: storyID, x2: chapterID})
        };
        let json = (await HttpClient.fetchJson("https://www.foxteller.com/aux_dem", options)).json;
        let decoded = this.decodeFoxteller(json);
        let rawHtml = "<article>" + decoded + "</article>";
        return util.sanitize(rawHtml);
    }

    decodeFoxteller(json) {
        var n = json.aux.replace(/%Ra&/g, "A").replace(/%Rc&/g, "B").replace(/%Rb&/g, "C").replace(/%Rd&/g, "D").replace(/%Rf&/g, "E").replace(/%Re&/g, "F");
        return decodeURIComponent(Array.prototype.map.call(atob(n), function(e) {
            return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2);
        }).join(""));   
    }    

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-description")];
    }
}

================================================
FILE: plugin/js/parsers/FreelightnovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("freelightnovel.net", () => new FreelightnovelParser());
//dead url
parserFactory.register("m.freelightnovel.net", () => new MFreelightnovelParser());

class FreelightnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div#list a")]
            .filter(a => a.parentNode.parentNode.id !== "newchapter")
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return [...dom.querySelectorAll(".con_top a")].pop()?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#fmimg");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#intro")];
    }
}

class MFreelightnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul#chapterlist");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#BookText");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("p.title")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".baseinfo");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".intro")];
    }
}

================================================
FILE: plugin/js/parsers/FreeWebNovelParser.js
================================================

"use strict";

parserFactory.register("freewebnovel.com", () => new FreeWebNovelComParser());
parserFactory.register("bednovel.com", () => new FreeWebNovelParser());
parserFactory.register("innnovel.com", () => new FreeWebNovelParser());
parserFactory.register("libread.com", () => new FreeWebNovelParser());
parserFactory.register("novellive.com", () => new NovelliveParser());
parserFactory.register("novellive.app", () => new NovelliveParser());
parserFactory.register("novellive.net", () => new NovelliveParser());
parserFactory.register("readwn.org", () => new NovelliveParser());

class FreeWebNovelParser extends Parser {

    constructor() {
        super();
        this.minimumThrottle = 1000;
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul#idData");
        return util.hyperlinksToChapterList(menu);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.tit");
    }

    extractAuthor(dom) {
        return dom.querySelector("[title=Author]").parentNode.querySelector("a").textContent;
    }

    extractSubject(dom) {
        let tags = [...dom.querySelector("[title=Genre]").parentNode.querySelectorAll("a")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.pic");
    }

    findChapterTitle(dom) {
        return dom.querySelector("span.chapter");
    }

    findContent(dom) {
        return dom.querySelector("div.txt");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.inner")];
    }
}

class NovelliveParser extends FreeWebNovelParser {

    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    getUrlsOfTocPages(dom) {
        // lastUrl should be example https://novellive.com/book/<some-novel-name>/<index>
        let lastUrl = [...dom.querySelectorAll(".page a.index-container-btn")]?.pop()?.href;
        let urls = [];
        if (lastUrl) {
            let lastTocIndex = lastUrl.lastIndexOf("/");
            let lastIndexPageName = lastUrl.substring(lastTocIndex + 1);
            let lastIndex = parseInt(lastIndexPageName);
            let tocHasMultiplePages = !isNaN(lastIndex);
            if (tocHasMultiplePages) {
                let baseUrl = lastUrl.substring(0, lastTocIndex + 1);
                for (let i = 2; i <= lastIndex; ++i) {
                    urls.push(baseUrl + i);
                }
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelector(".m-newest2").querySelectorAll("ul li a")]
            .map(a => util.hyperLinkToChapter(a));
    }
}

class FreeWebNovelComParser extends FreeWebNovelParser {
    constructor() {
        super();
    }
    removeUnwantedElementsFromContentElement(content) {
        util.removeChildElementsMatchingSelector(content, "p sub");
        super.removeUnwantedElementsFromContentElement(content);
    }
}

================================================
FILE: plugin/js/parsers/FuhuzzParser.js
================================================

"use strict";

parserFactory.register("fuhuzz.pro", () => new FuhuzzParser());

class FuhuzzParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let leaves = [...dom.querySelectorAll("tbody a")];
        return leaves.map(a => ({
            sourceUrl: a.href, 
            title: a.textContent
        })).reverse();
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img")?.src ?? null;
    }
    
    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let startString = "fid";
        let scriptElement = [...dom.querySelectorAll("script")].map(a => a.textContent).filter(s => s.includes(startString));
        let json = this.parseNextjsHydration(scriptElement[0]);
        let id = this.flatObjFn2(json, "json");
        let restURL = "https://static.ripfuhu.xyz/api/fttps:webp/"+id.fid;
        let chapjson = (await HttpClient.fetchJson(restURL)).json;
        return this.buildChapter(chapjson.images[0], url, id.currentTitle);
    }

    flatObjFn2(obj) {
        var finalObj = {}; 
        for (let key in obj) {
            if (typeof obj[key] === "object") {
                Object.assign(finalObj, this.flatObjFn2(obj[key], key));
            } else {
                finalObj[key] = obj[key];
            }
        }
        return finalObj;
    }

    parseNextjsHydration(nextjs) {
        let malformedjson = nextjs.match(/{.*}/s);
        let json;
        if (malformedjson == null) {
            malformedjson = nextjs.match(/\[.*\]/s);
            let ret = malformedjson[0];
            json = JSON.parse(ret);
            json.webtoepubformat = "backslash";
        } else {
            let ret = malformedjson[0];
            ret = ret.replaceAll("\\\\\\\"", "[webtoepubescape\"]");
            ret = ret.replaceAll("\\", "");
            ret = ret.replaceAll("[webtoepubescape\"]","\\\"");
            json = JSON.parse(ret);
            json.webtoepubformat = "array";
        }
        return json;
    }

    buildChapter(chapcontent, url, chaptitle) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = chaptitle;
        newDoc.content.appendChild(title);
        let text = chapcontent;
        text = text.replaceAll("\n\n", "\n");
        text = text.split("\n");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/FullnovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("fullnovel.co", () => new FullnovelParser());

class FullnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.text-xs")];
    }
}

================================================
FILE: plugin/js/parsers/GamefaqsGamespotParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("gamefaqs.gamespot.com", () => new GamefaqsGamespotParser());

class GamefaqsGamespotParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let toc = dom.querySelector(".ftoc");
        if (toc !== null) {
            return this.linksToChapters(dom.baseURI, toc);
        }
        toc = dom.querySelector("div.main_content");
        if (toc !== null) {
            util.removeChildElementsMatchingSelector(toc, "nav.content_nav_wrap");
            return this.linksToChapters(dom.baseURI, toc);
        }
        return [];
    }

    linksToChapters(base, toc) {
        if (!base.endsWith("/")) {
            base += "/";
        }
        let baseUrl = new URL(base);
        return [...toc.querySelectorAll("a")].map(link => ({
            sourceUrl:  new URL(link.getAttribute("href"), baseUrl).toString(),
            title: link.innerText.trim(),
        }));
    }

    findContent(dom) {
        return dom.querySelector("#faqwrap");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.platform-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.contrib1");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".ftoc");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/GenesiStudioParser.js
================================================

/*
  Parses files on <https://genesistudio.com>
*/
"use strict";

parserFactory.register("genesistudio.com", () => new GenesiStudioParser());

class GenesiStudioParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 2000;
    }
    populateUIImpl() {
        document.getElementById("removeChapterNumberRow").hidden = false;
    }

    async getChapterUrls(dom) {
        let data = (await HttpClient.fetchJson(dom.baseURI + "/__data.json")).json;
        let tmpids = data.nodes[2].data[0].chapters;
        let freeids = data.nodes[2].data[data.nodes[2].data[tmpids].free];
        let paidids = data.nodes[2].data[data.nodes[2].data[tmpids].premium];

        let chapters = freeids.map(a => ({
            sourceUrl:  "https://genesistudio.com/viewer/"+data.nodes[2].data[data.nodes[2].data[a].id],
            title: document.getElementById("removeChapterNumberCheckbox").checked ? data.nodes[2].data[data.nodes[2].data[a].chapter_title]: "Chapter " + data.nodes[2].data[data.nodes[2].data[a].chapter_number]+ ": " + data.nodes[2].data[data.nodes[2].data[a].chapter_title],
            isIncludeable: true    
        }));

        let pchapters = paidids.map(a => ({
            sourceUrl:  "https://genesistudio.com/viewer/"+data.nodes[2].data[data.nodes[2].data[a].id],
            title: document.getElementById("removeChapterNumberCheckbox").checked ? data.nodes[2].data[data.nodes[2].data[a].chapter_title]: "Chapter " + data.nodes[2].data[data.nodes[2].data[a].chapter_number]+ ": " + data.nodes[2].data[data.nodes[2].data[a].chapter_title],
            isIncludeable: false    
        }));

        return chapters.concat(pchapters);
    }
    
    async loadEpubMetaInfo(dom) {
        // eslint-disable-next-line
        let data = (await HttpClient.fetchJson(dom.baseURI + "/__data.json")).json;
        let tmpids = data.nodes[2].data[data.nodes[2].data[0].novel];
        this.title = data.nodes[2].data[tmpids.novel_title];
        this.author = data.nodes[2].data[tmpids.author];
        let genre = data.nodes[2].data[tmpids.genres];
        genre = genre.map(a => data.nodes[2].data[a]);
        this.tags = genre;
        this.description = data.nodes[2].data[tmpids.synopsis];
        this.img = data.nodes[2].data[tmpids.cover];
        return;
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        return url + "/__data.json";
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let index = json.nodes[2].data[0].content;
        let content = util.sanitize(json.nodes[2].data[index]);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    addTitleToContent(webPage, content) {
        let h2 = webPage.rawDom.createElement("h2");
        h2.innerText = webPage.title.trim();
        content.prepend(h2);
    }
    
    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }
}

================================================
FILE: plugin/js/parsers/GlobalNovelpiaParser.js
================================================

"use strict";

parserFactory.register("global.novelpia.com", () => new GlobalNovelpiaParser());

class GlobalNovelpiaParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 3000;
    }

    async getChapterUrls(dom) {
        const rows = 9999;
        const sort = "ASC";
        const regex = /\/novel\/(\d+)/;
        const novelId = dom.baseURI.match(regex)?.[0].slice(7);
        const apiUrl = `https://api-global.novelpia.com/v1/novel/episode/cursor-list?novel_no=${novelId}&rows=${rows}&sort=${sort}`;
        try {
            const response = (await HttpClient.fetchJson(apiUrl)).json;
            const data = response.result.list;
            return data.map(chapter => {
                return {
                    sourceUrl: `https://global.novelpia.com/viewer/${chapter.episode_no}`,
                    title: chapter.epi_num + " - " + chapter.epi_title
                };
            });
        } catch (error) {
            ErrorLog.showErrorMessage(error);
        }
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".nv-tit");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".info-author");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll(".nv-tag")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector(".synopsis-text").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector(".in-ch-txt");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover-box");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.fetchHtml(url)).responseXML;
        let chapNumber = dom.querySelector("span.in-chapter-number")?.textContent;
        let chapTitle = dom.querySelector("span.in-chapter-title")?.textContent;
        let token = this.findChapterContentToken(dom);
        let contentUrl = `https://api-global.novelpia.com/v1/novel/episode/content?_t=${token}`;
        let contentJson = (await HttpClient.fetchJson(contentUrl)).json;
        return this.jsonToHtml(url, contentJson.result.data, chapNumber + " - " + chapTitle);
    }

    findChapterContentToken(dom) {
        let regex = new RegExp("eyJhb[^\"]*");
        let getToken = dom.querySelector("script#__NUXT_DATA__")?.outerHTML;
        let chapToken = getToken?.match(regex);
        return chapToken;
    }

    jsonToHtml(pageUrl, data, title) {
        let newDoc = Parser.makeEmptyDocForContent(pageUrl);
        let header = newDoc.dom.createElement("h1");
        header.textContent = title;
        newDoc.content.appendChild(header);
        let fragments = Object.keys(data)
            .filter(k => k.startsWith("epi_content"))
            .map(k => data[k]);
        let content = util.sanitize("<div>" + fragments.join("") + "</div>");
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".next-epi-btn");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".nv-synopsis")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "button");
        return node;
    }
}

================================================
FILE: plugin/js/parsers/GoodNovelParser.js
================================================

"use strict";

parserFactory.register("goodnovel.com", () => new GoodNovelParser());

class GoodNovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let bookid = GoodNovelParser.extractBookID(dom);
        let tocUrl = new URL(dom.baseURI).origin + "/book_catalog/" + bookid + "/";
        let chapters = [];
        let tocDom = (await HttpClient.wrapFetch(tocUrl + "1")).responseXML;
        let urlsOfTocPages = GoodNovelParser.extractTocPageUrls(tocDom, tocUrl);
        return (await this.getChaptersFromAllTocPages(chapters, 
            this.extractPartialChapterList, urlsOfTocPages, chapterUrlsUI));
    }

    static extractBookID(dom) {
        let url = dom.baseURI;
        let retid = null;
        retid = url.match(new RegExp("_[0-9]+$"))?.[0].match(new RegExp("[0-9]+$"))?.[0];
        if (retid == null) {
            // eslint-disable-next-line
            retid = url.match(new RegExp("book_catalog\/[0-9]+\/"))?.[0].match(new RegExp("[0-9]+"))?.[0];
        }
        return retid;
    }

    static extractTocPageUrls(dom, baseUrl) {
        let max = GoodNovelParser.extractMaxToc(dom);
        let tocUrls = [];
        for (let i = 1; i <= max; ++i) {
            tocUrls.push(`${baseUrl}${i}`);
        }
        return tocUrls;
    }

    static extractMaxToc(dom) {
        let query = [...dom.querySelectorAll("a.pagiation-item")].map(a => parseInt(a.textContent));
        let linkElement = Math.max(...query);
        return (Infinity == linkElement || -Infinity == linkElement) ? 0 : linkElement;
    }

    extractPartialChapterList(dom) {
        let ChapterlistNodes = dom.querySelectorAll(".catalog>div.catalog-box");
        let Chapterlist = [];
        for (let element of ChapterlistNodes) {
            Chapterlist.push(GoodNovelParser.hyperLinkToChapter(element));
        }
        return Chapterlist;
    }

    static hyperLinkToChapter(link, newArc) {
        return {
            sourceUrl:  link.querySelector("a").href,
            title: link.querySelector("a").innerText.trim(),
            newArc: (newArc === undefined) ? null : newArc,
            isIncludeable: GoodNovelParser.isLinkLocked(link)
        };
    }
    
    static isLinkLocked(link) {
        return (link.querySelector(".cat-lock") == null) ? true : false;
    }

    findContent(dom) {
        return dom.querySelector(".read-chapter > .read-content");
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector(".bib_info>h1");
        return title;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".auth > a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("h1.title");
        return title.textContent;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".bib_img>img").src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.bid_tit, div.bid_p")];
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll(".bid_tit a")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }
    
    extractDescription(dom) {
        return dom.querySelector(".bid_p").textContent.trim();
    }
}

================================================
FILE: plugin/js/parsers/GraverobbertlParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("graverobbertl.site", () => new GraverobbertlParser());

class GraverobbertlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("div.post-entry ul a")]
            .filter(a => a.host !== "graverobbertl.wordpress.com");
        return links.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.post-entry");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.wp-block-column");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.post-header h1");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let content = this.findContent(dom);

        // if only a couple of chapters, and there's a link, with "click me", chase the link
        let paragraphCount = [...content.querySelectorAll("p")].length;
        let links = [...content.querySelectorAll("a")]
            .filter(a => (a.host === "graverobbertl.site") && 
                a.textContent.toLowerCase().includes("click here"));
        if ((paragraphCount < 20) && (0 < links.length)) {
            dom = (await HttpClient.wrapFetch(links[0].href)).responseXML;
        }
        return dom;
    }

    getInformationEpubItemChildNodes(dom) {
        let children = dom.querySelector("div.post-entry").children;
        let filtered = [];
        for (let i = 0; i < children.length; ++i) {
            let e = children[i];
            if (e.tagName === "P") {
                filtered.push(e);
            }
            if (e.tagName === "H2" || e.tagName === "UL") {
                break;
            }
        }
        return filtered;
    }
}

================================================
FILE: plugin/js/parsers/GravityNovelsParser.js
================================================

"use strict";

parserFactory.register("gravitynovels.com", () => new GravityNovelsParser());

class GravityNovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("section#chapters a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return (
            dom.querySelector(".entry-content") || dom.querySelector("#chapter-content")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.story__identity-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".author");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.chapter__title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "figure.story__thumbnail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section.story__summary")];
    }

}

================================================
FILE: plugin/js/parsers/GravityTalesParser.js
================================================

"use strict";

parserFactory.register("gravitytales.com", () => new GravityTalesParser());

class GravityTalesParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chaptersElement = dom.querySelector("ul.list");
        if (chaptersElement) {
            return util.hyperlinksToChapterList(chaptersElement);
        }

        // logic as @ 2018-06-10
        chaptersElement = dom.querySelector("div#chapters div.tab-content");
        let chapters = util.hyperlinksToChapterList(chaptersElement);
        if (0 < chapters.length) {
            return Promise.resolve(chapters);
        }

        // older logic
        let novelId = GravityTalesParser.getNovelId(dom);
        if (novelId !== null) {
            return GravityTalesParser.fetchUrlsOfChapters(novelId, dom.baseURI, HttpClient.fetchJson); 
        }
        let content = this.findContent(dom) ||
            dom.querySelector("chapters") ||
            dom.body;
        return util.hyperlinksToChapterList(content, this.isChapterHref);
    }

    isChapterHref(link) {
        return (link.hostname === "gravitytales.com") &&
            (link.search === "");
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector("meta[property='og:title']");
        if (title !== null) {
            return title.getAttribute("content");
        }
        return dom.querySelector("h3");
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div.entry-content")
            || dom.querySelector("div.content")
            || dom.querySelector("section#chapter-content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title") ||
            dom.querySelector("#single h1") ||
            dom.querySelector("h1.chapter__title");
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        // "previous" chapter may be immediate child of <p> tag to remove
        // "next" chapter has a <strong> tag wrapping it, then the maybe a <p> tag
        let toRemove = util.moveIfParent(link, "strong");
        return util.moveIfParent(toRemove, "p");
    }

    static getNovelId(dom) {
        let contentElement = dom.querySelector("div#contentElement");
        let init = (contentElement === null) ? null : contentElement.getAttribute("ng-init");
        let valArray = [];
        if (!util.isNullOrEmpty(init)) {
            valArray = init.split(";")
                .map(s => GravityTalesParser.splitAtEquals(s))
                .filter(a => (a.length === 2) && a[0] === "novelId")
                .map(a => parseInt(a[1]));
        }
        if (valArray.length === 1) {
            return valArray[0];
        }
        return GravityTalesParser.searchForNovelIdinScriptTags(dom);
    }

    /**
     * Convert string like "novel = 7" into ["novel", "7"]
     */
    static splitAtEquals(param) {
        return param.split("=").map(s => s.trim());
    }

    static fetchUrlsOfChapters(novelId, baseUri, fetchJson) {
        let chapterGroupsUrl = `https://gravitytales.com/api/novels/chaptergroups/${novelId}`;
        return fetchJson(chapterGroupsUrl).then(function(handler) {
            return Promise.all(
                handler.json.map(group => GravityTalesParser.fetchChapterListForGroup(novelId, group, fetchJson))
            );
        }).then(function(chapterLists) {
            return GravityTalesParser.mergeChapterLists(chapterLists, baseUri);
        });
    } 

    static fetchChapterListForGroup(novelId, chapterGroup, fetchJson) {
        let groupId = chapterGroup.ChapterGroupId;
        let chaptersUrl = `https://gravitytales.com/api/novels/chaptergroup/${groupId}`;
        return fetchJson(chaptersUrl).then(function(handler) {
            return {
                groupTitle: chapterGroup.Title,
                chapters: handler.json
            };
        });
    }

    static mergeChapterLists(chapterLists, baseUri) {
        let uniqueChapters = new Set();
        return chapterLists.reduce(function(chapters, chapterList) {
            let groupTitle = chapterList.groupTitle;
            for (let c of chapterList.chapters) {
                let url = util.removeTrailingSlash(baseUri + "/" + c.Slug);
                if (!uniqueChapters.has(url)) {
                    uniqueChapters.add(url);
                    chapters.push(GravityTalesParser.makeChapter(url, c.Name, groupTitle));
                    // only first chapter in each group gets the arc name
                    if (groupTitle != null) {
                        groupTitle = null; 
                    }
                }
            }
            return chapters;
        }, []);
    }

    static makeChapter(sourceUrl, title, newArc) {
        return {
            sourceUrl: sourceUrl,
            title: title,
            newArc: newArc
        };
    }

    static searchForNovelIdinScriptTags(dom) {
        for (let e of dom.querySelectorAll("script")) {
            let novelId = GravityTalesParser.searchForNovelIdinString(e.innerText);
            if ( novelId !== null) {
                return novelId;
            }
        }
        return null;
    }

    static searchForNovelIdinString(s) {
        let searchFor = "novelId:";
        let startIndex = s.indexOf(searchFor);
        if (0 <= startIndex)
        {
            let novelId = s.substring(startIndex + searchFor.length);
            novelId = GravityTalesParser.removeStringAfterChar(novelId, ",");
            novelId = GravityTalesParser.removeStringAfterChar(novelId, "}").trim();
            return parseInt(novelId);
        }
        return null;
    }

    static removeStringAfterChar(s, c) {
        let endIndex = s.indexOf(c);
        return (0 <= endIndex) ? s.substring(0, endIndex) : s;
    }

    findCoverImageUrl(dom) {
        if (dom.querySelector("div.cover")) {
            return util.getFirstImgSrc(dom, "div.cover");            
        }

        let img = dom.querySelector("div#coverImg");
        if (img !== null) {
            let style = img.getAttribute("style");
            if (!util.isNullOrEmpty(style)) {
                let startIndex = style.indexOf("url(") + 4;
                let endIndex = style.indexOf(");", startIndex);
                if (startIndex < endIndex) {
                    return style.substring(startIndex, endIndex);
                }
            }
        }

        return util.getFirstImgSrc(dom, "figure.story__thumbnail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("div.desc, p.description, .story__summary")];
    }
}

================================================
FILE: plugin/js/parsers/GunnerkriggParser.js
================================================

"use strict";

parserFactory.register("gunnerkrigg.com", () => new GunnerkriggParser());

class GunnerkriggParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("select[name='page'] option")]
            .map(this.optionToChapter);
    }

    optionToChapter(option) {
        return {
            sourceUrl:  "https://www.gunnerkrigg.com/?p=" + option.value,
            title: option.textContent.trim(),
        };
    }

    findContent(dom) {
        let content = dom.querySelector("div.comic");
        if (content !== null) {
            util.removeChildElementsMatchingSelector(content, ".nav, .extra");
        }
        return content;
    }
}

================================================
FILE: plugin/js/parsers/GutenbergDEParser.js
================================================

/*
  Parser for gutenberg.spiegel.de.
  Start at Chapter 1, frequently a link like /buch/nnn/1, where nnn is the gutenberg book number.
  Derived from:
  Template to use to create a new parser
*/
"use strict";

// Use one or more of these to specify when the parser is to be used

// Use this function if site's host name is sufficient.  
// i.e. All pages are on same site, and use same format.
//dead url/ parser
parserFactory.register("gutenberg.spiegel.de", () => new GutenbergDEParser());

class GutenbergDEParser extends Parser {
    constructor() {
        super();
    }

    // returns promise with the URLs of the chapters to fetch
    // promise is used because may need to fetch the list of URLs from internet
    
    getChapterUrls(dom) {
        // Most common implementation is to find element holding the hyperlinks to 
        // the web pages holding the chapters.  Then call util.hyperlinksToChapterList()
        // to convert the links into a list of URLs the parser will collect.
        let menu = dom.querySelector("ul.gbnav");
        return Promise.resolve(util.hyperlinksToChapterList(menu));        
    }
    

    // returns the element holding the story content in a chapter
    
    findContent(dom) {
        // typical implementation is find node with all wanted content
        // return is the element holding just the wanted content.
        return dom.querySelector("div#gutenb");
    }
    

    // title of the story  (not to be confused with title of each chapter)
    
    extractTitleImpl(dom) {
        // typical implementation is find node with the Title and return name from title
        // NOTE. Return Title as a string, not a HTML element

        // this works if chapter 1 contains a cover with separate class attributes 
        let titleElem=dom.querySelector("h2.title");
        if (null != titleElem) return titleElem.textContent.trim();

        // else rely on the div showing a breadcrumb 
        let gbbreadcrumb=dom.querySelector("div.gbbreadcrumb");
        let titleE=gbbreadcrumb.firstElementChild.nextElementSibling.nextElementSibling;
        return titleE;
    }
    

    // author of the story
    // Optional, if not provided, will default to "<unknown>"
    
    extractAuthor(dom) {
        // typical implementation is find node with the author's name and return name from title
        // Major points to note

        let authorElem=dom.querySelector("h3.author");
        if (null != authorElem) return authorElem.textContent.trim();

        let gbbreadcrumb=dom.querySelector("div.gbbreadcrumb");
        let authorA=gbbreadcrumb.firstElementChild.nextElementSibling;
        if (authorA) return authorA.textContent.trim();

        return super.extractAuthor(dom);
    }
}

================================================
FILE: plugin/js/parsers/GzbpParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.gzbpi.com", () => new GzbpParser());

class GzbpParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let url = dom.baseURI.replace("/info/", "/wapbook/");
        let newDom = (await HttpClient.wrapFetch(url)).responseXML;
        return (await this.walkTocPages(newDom,
            this.getChapterUrlsFromTocPage,
            this.nextTocPageUrl,
            chapterUrlsUI
        ));
    }

    getChapterUrlsFromTocPage(dom) {
        return [...dom.querySelectorAll("ul.fk li a")]
            .filter(a => a.href.includes("wapbook"))
            .map(a => util.hyperLinkToChapter(a));
    }

    nextTocPageUrl(dom) {
        let link = dom.querySelector("div.xypa a");
        return link === null ? null : link.href;
    }

    findContent(dom) {
        return dom.querySelector("div#content-txt");
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector("div.xx li");
        return title === null ? null : title.textContent;
    }

    // language used
    // Optional, if not provided, will default to ISO code for English "en"
    /*
    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }
    */

    removeUnwantedElementsFromContentElement(element) {
        let toRemove = [...element.querySelectorAll("div")]
            .filter(d => d.textContent.includes("本章未完，点击下一篇继续阅读！"));
        util.removeElements(toRemove);
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("div.c_title");
        return title === null ? null : title.textContent.trim();
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.xsfm");
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom, url, count) {
        // finding next page URL, need to sse if any script holds 
        // the expected value

        let nextUrl = url.replace(".html", "-" + count + ".html");
        let leaf = nextUrl.split("/").pop();

        let scripts = [...dom.querySelectorAll("script")]
            .filter(script => script.textContent.includes(leaf));
        
        return (0 < scripts.length) ? nextUrl : null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.jianjie")];
    }
}

================================================
FILE: plugin/js/parsers/HelheimscansParser.js
================================================

"use strict";

//dead urls
parserFactory.register("helheimscans.com", () => new HelheimscansParser());
parserFactory.register("helheimscans.org", () => new HelheimscansParser());
//Helheim Scans moved to Helio Scans
parserFactory.register("helioscans.com", () => new HelheimscansParser());

class HelheimscansParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("#chapters_panel a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        let title = link.querySelector("span").textContent.trim();
        let coinimg = link.querySelector("img");
        return ({
            sourceUrl:  link.href,
            title: title,
            isIncludeable: (coinimg == null)
        });
    }

    findContent(dom) {
        return dom.querySelector("#pages");
    }

    preprocessRawDom(dom) {
        let imgs = [...dom.querySelectorAll("#pages img.lazy[uid]")];
        for (let img of imgs) {
            img.src = `https://image.meowing.org/uploads/${img.getAttribute("uid")}`;
        }
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("title");
    }

    findCoverImageUrl(dom) {
        let url = dom.querySelector("div[style^=--photo]");
        url = url.getAttribute("style").split("(")[1];
        return url
            ? url.substring(0, url.length - 1)
            : null;
    }

    getInformationEpubItemChildNodes(dom) {
        let meta = dom.querySelector("meta[name='description']");
        if (meta) {
            let p = dom.createElement("p");
            p.textContent = meta.getAttribute("content");
            return [p];
        }
        return [];
    }
}

================================================
FILE: plugin/js/parsers/HellpingParser.js
================================================

/*
  parses hellping.org
*/
"use strict";

//dead url/ parser
parserFactory.register("hellping.org", () => new HellpingParser());

class HellpingParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocEntries = [...dom.querySelectorAll("div.entry-content a")]
            .filter(a => a.textContent.trim() !== "");
        let menuEntries = [...dom.querySelectorAll("#primary-menu a")];
        return tocEntries.concat(menuEntries)
            .map(a => util.hyperLinkToChapter(a));
    }
}

================================================
FILE: plugin/js/parsers/HentaiFoundryParser.js
================================================

"use strict";

parserFactory.register("hentai-foundry.com", () => new HentaiFoundryParser());

class HentaiFoundryParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let content = dom.querySelector("#yw0");
        if (content.className === "storiesView") {
            return [];
        } else if (content.className === "galleryView") {
            return this.selectChapterUrls(content, "div.thumbTitle a");
        } else {
            return this.selectChapterUrls(content, "div.boxbody a");
        }
    }

    async selectChapterUrls(content, linkSelector) {
        return [...content.querySelectorAll(linkSelector)]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        let content = dom.querySelector("section#viewChapter div.boxbody");
        if (content === null) {
            content = dom.querySelector("section#picBox div.boxbody");
        }
        return content;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.titleSemantic");
    }

    extractAuthor(dom) {
        let author = null;
        let label = [...dom.querySelectorAll("td.storyInfo span.label")]
            .filter(l => l.textContent.trim() === "Author");
        if (0 < label.length) {
            author = label[0].parentElement.querySelector("a");
        }
        return (author === null) ? super.extractAuthor(dom) : author.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.titleSemantic");
    }

    getInformationEpubItemChildNodes(dom) {
        let desc = dom.querySelector("td.storyDescript");
        util.removeChildElementsMatchingSelector(desc, "div");
        let info = dom.createElement("table");
        info.appendChild(desc.cloneNode(true));
        return [info];
    }
}

================================================
FILE: plugin/js/parsers/HiscensionParser.js
================================================

"use strict";

parserFactory.register("hiscension.com", () => new HiscensionParser());

class HiscensionParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("table.wp-block-table td a")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return dom.querySelector("div.blog-post-single-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("article h1");
    }
}

================================================
FILE: plugin/js/parsers/HostednovelParser.js
================================================

"use strict";

parserFactory.register("hostednovel.com", () => new HostednovelParser());

class HostednovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let urlsOfTocPages = this.extractTocPageUrls(dom);
        let chapters = this.extractPartialChapterList(dom);
        return (await this.getChaptersFromAllTocPages(chapters, 
            this.extractPartialChapterList, urlsOfTocPages, chapterUrlsUI))
            .concat(this.chapterUrlsOnPage(dom));
    }

    extractTocPageUrls(dom) {
        let pagination = dom.querySelector("nav[aria-label='Pagination']");
        if (pagination === null) {
            return [];
        }
        let urls = [];
        let lastLink = [...pagination.querySelectorAll("a")].pop();
        if (lastLink !== null) {
            let url = new URL(lastLink.href);
            let maxPage = parseInt(url.searchParams.get("page"));
            for (let i = 2; i <= maxPage; ++i) {
                url.searchParams.set("page", i);
                urls.push(url.href);
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("li.flow-root.my-1 a")]
            .map(a => ({
                sourceUrl:  a.href,
                title: HostednovelParser.formatTitle(a)
            }));
    }

    static formatTitle(link) {
        let div = link.querySelector("div");
        util.removeChildElementsMatchingSelector(div, "span, p");
        return div.textContent.trim();
    }

    chapterUrlsOnPage(dom) {
        return [...dom.querySelectorAll(".chaptergroup a:not([rel])")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.fontchanger");
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    extractTitleImpl(dom) {
        let link = dom.querySelector("h1");
        util.removeChildElementsMatchingSelector(link, "a");
        return link;
    }

    removeUnwantedElementsFromContentElement(element) {
        this.tagAuthorNotesBySelector(element, "div.bg-light-200");
        util.removeChildElementsMatchingSelector(element, "div.adbox");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1 span.fontchanger");
    }

    findCoverImageUrl() {
        // CDN blocks attempt to fetch cover image
        return null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".prose")];
    }
}

================================================
FILE: plugin/js/parsers/Hui3rParser.js
================================================

"use strict";

parserFactory.register("hui3r.wordpress.com", () => new Hui3rParser());

class Hui3rParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.single-entry-content ul a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.single-entry-content");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "#jp-post-flair, footer.entry-meta");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }
}

================================================
FILE: plugin/js/parsers/IdleturtletranslationsParser.js
================================================

"use strict";

parserFactory.register("idleturtle-translations.com", () => new IdleturtletranslationsParser());

class IdleturtletranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.pt-cv-wrapper");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div[itemprop='articleBody']");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("article h3");
    }

    findChapterTitle(dom) {
        return dom.querySelector("article h1");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let footnotes = new FootnoteExtractor().scriptElementsToFootnotes(webPageDom);
        this.moveFootnotes(webPageDom, content, footnotes);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }
}

================================================
FILE: plugin/js/parsers/IdnovelmyidParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("idnovel.my.id", () => new IdnovelmyidParser());

class IdnovelmyidParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.bxcl");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.text-left");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.infox h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "center");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.maincontent b");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script");
    }
}

================================================
FILE: plugin/js/parsers/ImgurParser.js
================================================

/*
  parses imgur galleries
*/
"use strict";

parserFactory.register("imgur.com", () => new ImgurParser());

parserFactory.registerUrlRule(
    url => Imgur.isImgurHostName(util.extractHostName(url).toLowerCase()),
    () => new ImgurParser()
);

class ImgurParser extends Parser {
    constructor() {
        super();
    }

    findContent(dom) {
        return Imgur.convertGalleryToConventionalForm(dom);
    }
}

================================================
FILE: plugin/js/parsers/IndomtlParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("indomtl.com", () => new IndomtlParser());

class IndomtlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("div#panelchapterlist div[role='list'] a")];
        return links.map(IndomtlParser.linkToChapter).reverse();
    }

    static linkToChapter(link) {
        util.removeChildElementsMatchingSelector(link, "span.time");
        return util.hyperLinkToChapter(link);
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "amp-ad, p.china, .pub-date, .chapter-nav, .snpconainer, .overlay");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.info")];
    }
}

================================================
FILE: plugin/js/parsers/IndowebnovelParser.js
================================================

"use strict";

parserFactory.register("indowebnovel.id", () => new IndowebnovelParser());

class IndowebnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.lightnovel-episode");
        return util.hyperlinksToChapterList(menu)
            .map(this.adjustChapterTitle)
            .reverse();
    }

    adjustChapterTitle(chapter) {
        let title = chapter.title.replace(/\r\n|\r|\n|Bahasa Indonesia/g, "");
        let index = title.indexOf("Chapter");
        if (0 < index) {
            title = title.substring(index);
        }
        chapter.title = title.trim();
        return chapter;
    }

    findContent(dom) {
        return [...dom.querySelectorAll("div")]
            .filter(d => d.className === "123")[0];
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.lightnovel-thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".lightnovel-info, .lightnovel-synopsis")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script");
    }
}

================================================
FILE: plugin/js/parsers/InkittParser.js
================================================

"use strict";

parserFactory.register("inkitt.com", () => new InkittParser());

class InkittParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".chapters-list a")]
            .map(this.linkToChapter);
    }

    linkToChapter(link) {
        let title = link.querySelector("span.chapter-nr.chapter-nr").textContent
            + " " + link.querySelector(".chapter-title").textContent;
        return {
            sourceUrl:  link.href,
            title: title
        };
    }

    findContent(dom) {
        return dom.querySelector("#story-text-container");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.story-title");
    }

    extractAuthor(dom) {
        return dom.querySelector("span[id='storyAuthor']")?.textContent ?? super.extractAuthor(dom);
    }

    findCoverImageUrl(dom) {
        let div = dom.querySelector("div.story-horizontal-cover__front");
        return util.extractUrlFromBackgroundImage(div);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.story-summary")];
    }
}

================================================
FILE: plugin/js/parsers/InoveltranslationParser.js
================================================

"use strict";

parserFactory.register("inoveltranslation.com", () => new InoveltranslationParser());

class InoveltranslationParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("section[class^='styles_chapter_list'] div:has(>a):not(:has(> div))")]
            .map(link => this.linkToChapter(link)).reverse();
    }

    linkToChapter(link) {
        let a = link.querySelector("a");

        return ({
            sourceUrl: a.href,
            title: a.textContent,
        });
    }

    findContent(dom) {
        return dom.querySelector("section[data-sentry-component='RichText']");
    }

    preprocessRawDom(webPageDom) {
        // notes can preceed content.  Move them into content
        let notes = [...webPageDom.body.querySelectorAll("div.rounded-xl")];
        if (0 < notes.length) {
            notes.forEach(n => n.remove());
            let content = this.findContent(webPageDom);
            let footnoteTitle = webPageDom.createElement("h2");
            footnoteTitle.appendChild(webPageDom.createTextNode("Author Notes"));
            content.appendChild(footnoteTitle);
            notes.forEach(n => content.appendChild(n));
        }
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section[class^='styles_details_container'] dl:last-child")];
    }
}

================================================
FILE: plugin/js/parsers/IsekaiScanParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("isekaiscan.com", () => new IsekaiScanParser());

class IsekaiScanParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.version-chap");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        let content = dom.querySelector("div.reading-content");
        for (let i of content.querySelectorAll("img")) {
            let data_src = i.getAttribute("data-src");
            if (!util.isNullOrEmpty(data_src)) {
                i.src = data_src;
            }
        }
        return content;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("divsummary__content")];
    }
}

================================================
FILE: plugin/js/parsers/IsotlsParser.js
================================================

"use strict";

parserFactory.register("isotls.com", () => new IsotlsParser());

class IsotlsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.table-of-contents");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("header h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "header, nav, footer");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.title;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "section.project-information");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section.project-information > div")];
    }
}

================================================
FILE: plugin/js/parsers/IxdzsParser.js
================================================

"use strict";

parserFactory.register("ixdzs.tw", () => new IxdzsParser());
parserFactory.register("ixdzs8.com", () => new Ixdzs8Parser());

class IxdzsParser extends Parser {
    constructor() {
        super();
        this.tocPathName = "/novel/html/";
    }

    async getChapterUrls(dom) {
        var tocUrl = new URL(dom.baseURI);
        var bid = this.extractBid(tocUrl.pathname);
        tocUrl.pathname = this.tocPathName;
        let options = {
            method: "POST",
            credentials: "include",
            body: this.makeFormData(bid)
        };
        return await this.fetchChapterUrls(tocUrl.href, options, dom.baseURI);
    }

    async fetchChapterUrls(url, options, baseUri) { // eslint-disable-line no-unused-vars
        let xhr = await HttpClient.wrapFetch(url, {fetchOptions: options});
        return util.hyperlinksToChapterList(xhr.responseXML.body);
    }

    makeFormData(bid) {
        let formData = new FormData();
        formData.append("bid", bid);
        return formData;
    }

    extractBid(path) {
        return path.split("/")
            .filter(s => !util.isNullOrEmpty(s))
            .pop();
    }

    findContent(dom) {
        return dom.querySelector("section");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.bauthor");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    findChapterTitle(dom) {
        return dom.querySelector("h3");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.n-img");
    }

    getInformationEpubItemChildNodes(dom) {
        let epubDescription = ([...dom.querySelectorAll("p.pintro")]);
        return epubDescription.map(e => e.textContent.replace(/(^\s*)|(\s*$)/gi, "").replace(/[ ]{2,}/gi, "\n\n").replace(/\u3000/g, ""));
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "p.abg");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

class Ixdzs8Parser extends IxdzsParser {
    constructor() {
        super();
        this.tocPathName = "/novel/clist/";
    }

    async fetchChapterUrls(url, options, baseUri) {
        if (!baseUri.endsWith("/")) {
            baseUri += "/";
        }
        let json = (await HttpClient.fetchJson(url, options)).json;
        return json.data.map(d => ({
            sourceUrl: `${baseUri}p${d.ordernum}.html`,
            title: d.title,
        }));
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let count = 0;
        while (!this.findContent(dom)) {
            let responseUrl = this.buildChallengeResponseUrl(dom, url);
            dom = (await HttpClient.wrapFetch(responseUrl)).responseXML;
            if (++count > 10) {
                break;
            }
        }
        return dom;
    }

    buildChallengeResponseUrl(dom, url) {
        let script = dom.querySelector("script")?.textContent;
        let token = script.split("\"")[1];
        return url +"?challenge=" + encodeURIComponent(token);
    }
}

================================================
FILE: plugin/js/parsers/JadeRabbitParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("jade-rabbit.net", () => new JadeRabbitParser());

class JadeRabbitParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.walkTocPages(dom, 
            JadeRabbitParser.chaptersFromDom, 
            JadeRabbitParser.nextTocPageUrl, 
            chapterUrlsUI
        );
    }

    static chaptersFromDom(dom) {
        return [...dom.querySelectorAll("h2.entry-title a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static nextTocPageUrl(dom) {
        let link = dom.querySelector("div.older a");
        return link === null ? null : link.href;
    }

    findContent(dom) {
        return dom.querySelector("div.post-entry");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.wp-block-ugb-container, "
            + "div.wp-block-uagb-buttons, div.notranslate, div.post-tags");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.post-img");
    }

    getInformationEpubItemChildNodes(dom) {
        let summary = dom.querySelector("div.post-entry");
        return summary === null ? [] : [summary];
    }
}

================================================
FILE: plugin/js/parsers/JadeScrollsParser.js
================================================

/*
  Parses web novels from jadescrolls.com

  JadeScrolls is a Next.js/React SPA where content is rendered client-side.
  This parser uses the JadeScrolls API endpoints instead of HTML parsing.

  API Endpoints:

- Novel data: <https://api.jadescrolls.com/api/public/get-novel-by-slug>
- Chapter data: <https://api.jadescrolls.com/api/user/get-chapter-by-slug>

  URL structure: /novel/{novel-slug}/{chapter-slug}
*/
"use strict";

parserFactory.register("jadescrolls.com", () => new JadeScrollsParser());

class JadeScrollsParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 1500;
    }

    async loadEpubMetaInfo(dom) {
        await this.fetchNovelMetadata(dom);
        super.loadEpubMetaInfo(dom);
    }

    async fetchNovelMetadata(dom) {
        let novelSlug = this.extractNovelSlug(dom.baseURI);
        if (!novelSlug || this.novelData) {
            return;
        }

        try {
            let apiUrl = "https://api.jadescrolls.com/api/public/get-novel-by-slug?slug=" + novelSlug + "&chapterSort=ASC";
            let novelData = (await HttpClient.fetchJson(apiUrl)).json;
            this.novelData = novelData.data;
        } catch (error) {
            ErrorLog.log(error);
        }
    }

    async getChapterUrls(dom) {
        await this.fetchNovelMetadata(dom);
        let novelSlug = this.extractNovelSlug(dom.baseURI);
        let chapters = [];

        if (this.novelData?.chapter) {
            chapters = this.novelData.chapter.map(chapter => ({
                sourceUrl: "https://jadescrolls.com/novel/" + novelSlug + "/" + chapter.slug,
                title: JadeScrollsParser.makeTitle(chapter)
            }));
        }
        return chapters;
    }

    static makeTitle(chapter) {
        return chapter.title
            ? chapter.chapterNo + ": " + chapter.title
            : ("Episode " + chapter.chapterNo);
    }

    extractNovelSlug(url) {
        let match = url.match(/\/novel\/([^/]+)/);
        return match ? match[1] : null;
    }

    extractEpisodeNumber(url) {
        let match = url.match(/episode-(\d+)/) || url.match(/chapter-(\d+)/) || url.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.novelData?.title;
    }

    extractAuthor() {
        return this.novelData?.OriginalNovelAuthor || this.novelData?.TranslateNovelAuthor;
    }

    async fetchChapter(url) {
        let match = url.match(/\/novel\/([^/]+)\/([^/?#]+)/);
        if (!match) {
            throw new Error("Invalid JadeScrolls chapter URL format: " + url);
        }

        let novelSlug = match[1];
        let chapterSlug = match[2];
        let apiUrl = "https://api.jadescrolls.com/api/user/get-chapter-by-slug?novelSlug=" + novelSlug + "&chapterSlug=" + chapterSlug;

        let chapterData = (await HttpClient.fetchJson(apiUrl)).json;
        return this.buildDomFromChapterData(chapterData, url);
    }

    buildDomFromChapterData(chapterData, sourceUrl) {
        let newDoc = Parser.makeEmptyDocForContent(sourceUrl);
        let data = chapterData.data || chapterData;

        if (data.title) {
            let titleElement = newDoc.dom.createElement("h1");
            titleElement.textContent = JadeScrollsParser.makeTitle(data);
            newDoc.content.appendChild(titleElement);
        }

        let rawHtml = data.content || data.body || "";
        if (rawHtml) {
            let sanitized = util.sanitize(rawHtml);
            util.moveChildElements(sanitized.body, newDoc.content);
        }
        return newDoc.dom;
    }

    findCoverImageUrl(dom) {
        return this.novelData?.coverImg || util.getFirstImgSrc(dom, ".novel-detils-wrapper");
    }

    extractDescription() {
        return this.novelData?.description || this.novelData?.synopsis || "";
    }

    extractSubject() {
        let genre = this.novelData?.genre;
        if (Array.isArray(genre)) {
            return genre.join(", ");
        }
        return genre || "";
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".novel-detils-wrapper")];
    }
}

================================================
FILE: plugin/js/parsers/JaptemParser.js
================================================

/*
  parses japtem.com
*/
"use strict";

parserFactory.register("japtem.com", () => new JaptemParser());

class JaptemParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = this.findContent(dom);
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div.post-content");
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        return util.moveIfParent(link, "h2");
    }
}

================================================
FILE: plugin/js/parsers/JjwxcParser.js
================================================

"use strict";

parserFactory.register("jjwxc.net", () => new JjwxcParser());

class JjwxcParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("table.cytable a")]
            .filter(a => this.fixupVip(a))
            .map(a => util.hyperLinkToChapter(a));
    }

    fixupVip(link) {
        let rel = link.getAttribute("rel");
        if (rel) {
            link.href = rel;
        }
        return link.href.includes("onebook")
            ? link
            : null;
    }

    findContent(dom) {
        return dom.querySelector("div.novelbody");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span[itemprop='author']");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "cn";
    }

    removeUnwantedElementsFromContentElement(element) {
        element.querySelector("#report_box")?.parentElement?.remove();
        util.removeChildElementsMatchingSelector(element, ".readsmall, div[align='right']");
        this.fixupAuthorNote(element);
        for (let div of element.querySelectorAll("div")) {
            div.style = null;
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    fixupAuthorNote(element) {
        let wrapper = element.querySelector("#note_danmu_wrapper");
        if (wrapper) {
            let note = wrapper.querySelector("#note_str");
            note.setAttribute("style", null);
            let title = document.createElement("div");
            title.innerText = "作者有话说";
            title.appendChild(note);
            wrapper.replaceWith(title);
        }
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.smallreadbody");
    }

    async fetchChapter(url) {
        let options = ({makeTextDecoder: () => new TextDecoder("gb18030")});
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#novelintro")];
    }
}

================================================
FILE: plugin/js/parsers/JonaxxstoriesParser.js
================================================

"use strict";

parserFactory.register("jonaxxstories.com", () => new JonaxxstoriesParser());

class JonaxxstoriesParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let lastLink = [...dom.querySelectorAll(".nav-links a:not(.next)")]
            .slice(-1);
        if (0 < lastLink.length)
        {
            let max = parseInt(lastLink[0].textContent);
            let href = lastLink[0].href;
            let index = href.lastIndexOf("/", href.length - 2);
            href = href.substring(0, index + 1);
            for (let i = 2; i <= max; ++i) {
                urls.push(href + i + "/");
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll(".entry-title a")]
            .map(a => util.hyperLinkToChapter(a));
    }
}

================================================
FILE: plugin/js/parsers/JpmtlParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("jpmtl.com", () => new JpmtlParser());

class JpmtlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("a.book-ccontent__content")];
        return chapters.map(this.linkToChapter);
    }

    linkToChapter(link) {
        let chapterNum = link.querySelector("div.book-ccontent__index").textContent;
        let titleText = link.querySelector("div.book-ccontent__title").textContent;
        return {
            sourceUrl:  link.href,
            title: `${chapterNum}: ${titleText}`,
            newArc: null
        };
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content__content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.book-sidebar__title");
    }

    removeUnwantedElementsFromContentElement(element) {
        [...element.querySelectorAll("p")]
            .filter(p => p.textContent.includes("This novel has been translated by JPMTL.com"))
            .forEach(p => p.remove());
        [...element.querySelectorAll("p")]
            .forEach(this.removeWatermark);
        super.removeUnwantedElementsFromContentElement(element);
    }

    removeWatermark(paragraph) {
        let text = paragraph.textContent.substring(0, 80).toLowerCase();
        let index = text.indexOf("y");
        if (index === -1 ) {
            return;
        }
        let watermark = text.substring(0, index + 1).replace(/\s+/g, "");
        const watermarkLength = 21;
        if (watermark === "translatedby") {
            let count = 12;
            while (index < text.length) {
                if (text[++index] !== " ") {
                    if (++count === watermarkLength) {
                        paragraph.textContent = paragraph.textContent.substring(index + 1);
                        return;
                    }
                }
            }
        }
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.chapter-content__title").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-sidebar__cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.main-book__container")];
    }

    cleanInformationNode(node) {
        [...node.querySelectorAll("svg")]
            .forEach(p => p.remove());
        return node;
    }
}

================================================
FILE: plugin/js/parsers/KakaoParser.js
================================================

"use strict";

parserFactory.registerUrlRule(
    url => KakaoParser.isValidUrl(url),
    () => new KakaoParser()
);

class KakaoParser extends Parser {
    constructor() {
        super();
    }

    async setAuthorizationToken() {
        if (typeof this.token === "undefined") {
            const jsonUrl = "https://page.kakao.com/api/login";

            const fetchOptions = {
                method: "POST",
                credentials: "include"
            };

            return HttpClient.fetchJson(jsonUrl, fetchOptions);
        }
    }

    async wrapFetch(jsonUrl) {
        // disable doing authentication, seems to have changed.
        return HttpClient.fetchJson(jsonUrl);        

        // return this.setAuthorizationToken().then(jsonResponse => {
        //     this.token = this.token || jsonResponse.json.accessToken;
        // }).then(() => {
        //     const fetchOptions = (this.token) ?
        //         {
        //             credentials: "include",
        //             headers: {
        //                 "Authorization": this.token
        //             }
        //         } : {credentials: "include"};

        //     return HttpClient.fetchJson(jsonUrl, fetchOptions);
        // });
    }

    static isValidUrl(url) {
        // Return true when is on the table of contents page.
        // Perhaps narrow this down so it can't execute on the chapters, but needs
        // to execute on the chapter api
        if (util.extractHostName(url).includes("api-pagestage.kakao.com")) {
            return true;
        }

        return (util.extractHostName(url).includes("pagestage.kakao.com")
            && !url.includes("episode")
            && url.includes("novel"));
    }

    async fetchChapter(url) {
        let jsonUrl;
        if (!url.includes("api-pagestage")) {
            jsonUrl = url.replace("pagestage", "api-pagestage") + "/body";
        } else {
            jsonUrl = url + "/body";
        }

        return this.wrapFetch(jsonUrl).then((jsonResponse) => {
            let json = jsonResponse.json;

            let doc = Parser.makeEmptyDocForContent(url);

            let metaChapId = doc.dom.createElement("meta");
            metaChapId.id = "chapterId";
            metaChapId.content = url.split("/")[6];
            doc.content.appendChild(metaChapId);

            let metaNovelId = doc.dom.createElement("meta");
            metaNovelId.id = "novelId";
            metaNovelId.content = url.split("/")[4];
            doc.content.appendChild(metaNovelId);

            let novelTitle = doc.dom.createElement("meta");
            novelTitle.id = "novelTitle";
            novelTitle.content = json.novelTitle;
            doc.content.appendChild(novelTitle);

            let body = json.body.split("\n").filter(s => !util.isNullOrEmpty(s));

            let title = doc.dom.createElement("h1");
            title.id = "title";
            title.textContent = json.title + " - " + body[0];
            doc.content.appendChild(title);

            let div = doc.dom.createElement("div");
            div.id = "content";
            for (let i = 1; i < body.length; ++i) {
                let p = doc.dom.createElement("p");
                p.textContent = body[i];
                div.appendChild(p);
            }
            doc.content.appendChild(div);

            return doc.dom;
        });
    }

    findContent(dom) {
        return dom.getElementById("content");
    }

    async getChapterUrls(dom) {
        let jsonUrl = dom.baseURI.replace("pagestage", "api-pagestage");
        return this.wrapFetch(jsonUrl).then(jsonResponse => {
            let json = jsonResponse.json;

            jsonUrl = dom.baseURI.replace("pagestage", "api-pagestage")
                + "/episodes?size=" + json.publishedEpisodeCount
                + "&sort=publishedAt,id,asc";
            return this.wrapFetch(jsonUrl);
        }).then(jsonResponse => {
            let json = jsonResponse.json;

            let chapterList = [];
            for (let chapter of json.content) {
                let url = dom.baseURI.replace("pagestage", "api-pagestage")
                    + "/episodes/" + chapter.id;
                let chapterInfo = {
                    sourceUrl: url,
                    title: chapter.title,
                    newArc: null
                };
                chapterList.push(chapterInfo);
            }

            return chapterList;
        });
    }

    // extractAuthor
    extractAuthor(dom) {
        return dom.querySelector("[property='article:author']").content;
    }
    // extractSubject
    extractSubject(dom) {
        return dom.querySelector("[name='tiara-pageMeta-category']").content;
    }
    // extractDescription
    extractDescription(dom) {
        return dom.querySelector("[property='og:description']").content;
    }
    // findChapterTitle
    findChapterTitle(dom) {
        return dom.getElementById("title");
    }

    // findCoverImageUrl
    findCoverImageUrl(dom) {
        return dom.querySelector("[property='og:image']").content;
    }
}

================================================
FILE: plugin/js/parsers/KakuyomuParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("kakuyomu.jp", () => new KakuyomuParser());

class KakuyomuParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return this.buildToc(dom);
    }

    buildToc(dom) {
        let script = dom.querySelector("script#__NEXT_DATA__").innerHTML;
        let json = JSON.parse(script).props.pageProps.__APOLLO_STATE__;
        let work = json["Work:" + this.extractWorkId(dom)];
        let chapters = [];
        for (let tocc of work.tableOfContents) {
            this.buildSubToc(chapters, json[tocc.__ref], json, dom.baseURI);
        }
        return chapters;
    }

    extractWorkId(dom) {
        let url = dom.baseURI;
        let index = url.lastIndexOf("/");
        return url.substring(index + 1);
    }

    buildSubToc(chapters, tocc, json, baseURI) {
        let arcStartIndex = chapters.length;
        for (let episoderef of tocc.episodeUnions) {
            let episode = this.buildEpisode(json[episoderef.__ref], baseURI);
            chapters.push(episode);
        }
        this.addArcTitleToEpisode(chapters[arcStartIndex], tocc, json);
    }

    buildEpisode(episode, baseURI) {
        return ({
            sourceUrl: baseURI + "/episodes/" + episode.id,
            title: episode.title,
        });   
    }

    addArcTitleToEpisode(episode, tocc, json) {
        let id = tocc?.chapter?.__ref;
        if (id && episode) {
            episode.newArc = json[id].title;
        }
    }

    findContent(dom) {
        return dom.querySelector("div.widget-episode");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("a[title]");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".partialGiftWidgetActivityName a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        let title = "";
        let chapterTitle = dom.querySelector("p.chapterTitle");
        if (chapterTitle !== null) {
            title = chapterTitle.textContent.trim();
        }
        let episode = dom.querySelector("p.widget-episodeTitle");
        if (episode !== null) {
            title += " " + episode.textContent.trim();
        }
        return util.isNullOrEmpty(title) ? null : title;
    }

    getInformationEpubItemChildNodes(dom) {
        let info = [...dom.querySelectorAll("div")]
            .filter(i => i.className.startsWith("CollapseTextWith"));
        return (0 < info.length) ? [info[0]] : [];
    }
}

================================================
FILE: plugin/js/parsers/KariStudioParser.js
================================================

"use strict";

parserFactory.register("karistudio.com", () => new KariStudioParser());

class KariStudioParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.novel_index a")]
            .map(link => util.hyperLinkToChapter(link)).reverse();
    }

    findContent(dom) {
        return (
            dom.querySelector("article.small")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#novel_info_left");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc_div p")];
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".confuse, #novel_nav, .post-rating-wrapper, #donation-msg, .clearfix, .navigation, #font-options-bar");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/KaystlsParser.js
================================================

"use strict";

parserFactory.register("kaystls.site", () => new KaystlsParser());

class KaystlsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.wp-block-columns a.wp-block-navigation-item__content")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.wp-block-columns");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.wp-block-columns.alignwide h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, 
            "div.code-block, #nav_inner_page_backwards, #nav_inner_page_forwards, #message_content, .donate");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.wp-block-cover");
    }
}

================================================
FILE: plugin/js/parsers/KemonopartyParser.js
================================================

"use strict";

parserFactory.registerRule(
    (url, dom) => KemonopartyParser.isKemono(dom),
    () => new KemonopartyParser()
);

class KemonopartyParser extends Parser {
    constructor() {
        super();
    }

    static isKemono(dom) {
        let baseurl = new URL(dom.baseURI); 
        return baseurl.hostname.split(".")[0] == "kemono";
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = [];
        let urlsOfTocPages = await this.getUrlsOfTocPages(dom);
        let baseUrl = new URL(dom.baseURI);
        baseUrl.searchParams.delete("tag");
        for (let url of urlsOfTocPages) {
            await this.rateLimitDelay();
            let json = await this.fetchJson(url);
            let partialList = this.extractPartialChapterList(json, baseUrl);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
            if (partialList.length == 0) {
                break;
            }
        }
        return chapters.reverse();
    }

    async fetchChapter(url) {
        let jsonUrl = new URL(url);
        jsonUrl.pathname = "/api/v1" + jsonUrl.pathname;
        let json = await this.fetchJson(jsonUrl.href);
        return this.buildChapter(json, url);
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let header = newDoc.dom.createElement("h1");
        newDoc.content.appendChild(header);
        header.textContent = json.post.title;
        let attachments = json.attachments;
        if (attachments && attachments.length > 0) {
            let attachHeader = newDoc.dom.createElement("h2");
            newDoc.content.appendChild(attachHeader);
            attachHeader.textContent = "Attachments";
            for (let att of attachments) {
                let link = newDoc.dom.createElement("a");
                link.href = att.server + "/data" + att.path;
                link.textContent = att.name;
                newDoc.content.appendChild(link);
                newDoc.content.appendChild(newDoc.dom.createElement("br"));
            }
        }
        let content = util.sanitize(json.post.content);
        util.moveChildElements(content.body, newDoc.content);        
        this.copyImagesIntoContent(newDoc.dom);
        this.addFileImages(json, newDoc);
        return newDoc.dom;
    }

    findCoverImageUrl(dom) {
        let cover = dom.querySelector(".user-header__avatar img");
        return cover.src ?? null;
    }

    async getUrlsOfTocPages(dom) {
        let baseurl = new URL(dom.baseURI);
        let urlbuilder = new URL(dom.baseURI);

        for (const [key] of baseurl.searchParams.entries()) {
            urlbuilder.searchParams.delete(key);
        }
        let regex = new RegExp("/?$");
        urlbuilder.href = urlbuilder.href.replace(`https://${baseurl.hostname}`, `https://${baseurl.hostname}/api/v1`).replace(regex, "/posts");
        
        for (const [key, value] of baseurl.searchParams.entries()) {
            urlbuilder.searchParams.set(key, value);
        }
        urlbuilder.searchParams.set("o", 0);
        let lastPageOffset = await this.getLastPageOffset(dom, urlbuilder);
        let urls = [];
        for (let i = 0; i <= lastPageOffset; i += 50) {
            urlbuilder.searchParams.set("o", i);
            urls.push(urlbuilder.href);
        }
        return urls;
    }

    async getLastPageOffset(dom, urlbuilder) {
        let offsets = [...dom.querySelectorAll("#paginator-top a")];
        offsets = offsets.map(item => new URL(item?.href)?.searchParams?.get("o"));
        offsets = offsets.filter(item => item !== null);
        offsets = offsets.map(item => parseInt(item));
        return 0 < offsets.length
            ? Math.max(...offsets)
            : await this.getLastPageOffsetAlternative(urlbuilder);
    }

    async getLastPageOffsetAlternative(urlbuilder) {
        let regex1 = new RegExp("/posts?.+");
        let profile = await this.fetchJson(urlbuilder.href.replace(regex1, "/profile"));
        return profile?.post_count;
    }

    async fetchJson(url) {
        let options = {
            headers: {
                "Accept": "text/css"
            }
        };
        return (await HttpClient.fetchJson(url, options)).json;
    }

    extractPartialChapterList(data, baseUrl) {
        let buildUrl = (row) => {
            baseUrl.pathname = `/${row.service}/user/${row.user}/post/${row.id}`;
            return baseUrl.href;
        };
        try {
            return data.map((row) => ({
                sourceUrl: buildUrl(row),
                title: row.title
            }));
        } catch (e) {
            return [];
        }
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    copyImagesIntoContent(dom) {
        let content = this.findContent(dom);
        let images = [...dom.querySelectorAll("div.post__files div.post__thumbnail figure a img")];
        for (let img of images) {
            content.append(img);
        }
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    addFileImages(json, newDoc) {
        let images = json?.previews?.filter(p => p.type == "thumbnail");
        if (!images || images.length == 0) {
            return;
        }
        let filesheader = newDoc.dom.createElement("h2");
        newDoc.content.appendChild(filesheader);
        filesheader.textContent = "Files";
        for (let i of images) {
            let img = newDoc.dom.createElement("img");
            img.src = i.server + "/data" + i.path;
            newDoc.content.append(img);
        }
    }
}

================================================
FILE: plugin/js/parsers/KobatochanParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("kobatochan.com", () => new KobatochanParser());

class KobatochanParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    fetchChapter(url) {
        return HttpClient.wrapFetch(url).then((xhr) => {
            let newDom = xhr.responseXML;
            let extraPageUrls = KobatochanParser.findAdditionalPageUrls(newDom);
            KobatochanParser.removePaginationElements(newDom);
            return this.fetchAdditionalPages(newDom, extraPageUrls.reverse());
        });
    }

    static findAdditionalPageUrls(dom) {
        let pages = [];
        for (let a of dom.querySelectorAll("div.pgntn-page-pagination-block a")) {
            if (!pages.includes(a.href)) {
                pages.push(a.href);
            }
        }
        return pages;
    }

    fetchAdditionalPages(dom, extraPageUrls) {
        if (extraPageUrls.length === 0) {
            return Promise.resolve(dom);
        }
        return HttpClient.wrapFetch(extraPageUrls.pop()).then((xhr) => {
            let newDom = xhr.responseXML;
            KobatochanParser.removePaginationElements(newDom);
            let dest = this.findContent(dom);
            let src = this.findContent(newDom);
            for (let node of [...src.childNodes]) {
                dest.appendChild(node);
            }
            return this.fetchAdditionalPages(dom, extraPageUrls);
        });
    }

    static removePaginationElements(dom) {
        return util.removeChildElementsMatchingSelector(dom, "div.page-link, div.pgntn-multipage, div.g-dyn");
    }
}

================================================
FILE: plugin/js/parsers/KrytykalParser.js
================================================

/*
  parses krytykal.org
*/
"use strict";

parserFactory.register("krytykal.org", () => new KrytykalParser());

class KrytykalParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.nav-menu");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div#content article");
    }
}

================================================
FILE: plugin/js/parsers/LanrySpaceParser.js
================================================

"use strict";

parserFactory.register("lanry.space", () => new LanrySpaceParser());

class LanrySpaceParser extends Parser {
    constructor() {
        super();
        this.bookid = "";
    }

    async getChapterUrls(dom) {
        let slug = this.getSlug(dom);
        let bookinfo = await this.fetchBookinfo(dom);
        this.bookid = bookinfo.id;
        let unlocked = new Set();
        bookinfo.chapter_unlocks.map(a => unlocked.add(a.chapter_number));
        let currenttime = Date.now();
        let chapterlist = [...bookinfo.chapters];
        chapterlist = chapterlist.sort((a,b) => (a.part_number==null?0:a.part_number) - (b.part_number==null?0:b.part_number));
        chapterlist = chapterlist.sort((a,b) => a.chapter_number - b.chapter_number);
        chapterlist = [...chapterlist.map(a => ({
            sourceUrl: this.sourceURL(a, slug),
            title: this.chtitle(a),
            isIncludeable: (a.publish_at == null || Date.parse(a.publish_at) < currenttime)
        }))];
        return chapterlist;
    }

    async fetchBookinfo(dom) {
        let slug = this.getSlug(dom);
        let apikey = "&apikey=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZrZ2toaXBhc3hxeGl0d2xrdHd6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzAyMzE4MzMsImV4cCI6MjA0NTgwNzgzM30.mHBd2yrRm934yPGy4pui3p7cW4FxfIf6yxh7b2TpUA8";
        let apibasetoc = "https://vkgkhipasxqxitwlktwz.supabase.co/rest/v1/novels?select=*%2Cchapter_unlocks%21left%28chapter_number%2Cprofile_id%29%2Ccategories%3Acategories_on_novels%28category%3Acategory_id%28id%2Cname%2Ccreated_at%2Cupdated_at%29%29%2Ctags%3Atags_on_novels%21left%28novel_id%2Ctag_id%2Ccreated_at%2Ctag%3Atag_id%28id%2Cname%2Cdescription%29%29%2Cchapters%28id%2Ctitle%2Ccreated_at%2Cchapter_number%2Cpart_number%2Cpublish_at%2Ccoins%2Cvolume_id%2Cage_rating%29";
        return (await HttpClient.fetchJson(apibasetoc+slug+apikey)).json[0];
    }

    getSlug(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/novels\/.+");
        let slug = "&slug=eq."+dom.baseURI.match(regex)?.[0].slice(8);
        const suffix = "/chapters";
        return slug.endsWith(suffix)
            ? slug.substring(0, slug.length - suffix.length)
            : slug;
    }

    sourceURL(a, slug) {
        if (a.part_number == null) {
            return "https://www.lanry.space/novels/"+slug+"/c" + a.chapter_number;
        } else {
            return "https://www.lanry.space/novels/"+slug+"/c" + a.chapter_number + "-p" + a.part_number;
        }
    }

    chtitle(a) {
        let chapNum = (a.part_number == null)
            ? `Ch. ${a.chapter_number}`
            : `Ch. ${a.chapter_number}-${a.part_number}`;
        return (a.title != "")
            ? chapNum + " " + a.title
            : chapNum;
    }
    
    async loadEpubMetaInfo(dom) {
        let bookinfo = await this.fetchBookinfo(dom);
        this.title = bookinfo.title;
        this.author = bookinfo.author;
        this.tags = bookinfo.tags.map(a => a.tag.name);
        this.tags = this.tags.concat(bookinfo.categories.map(a => a.category.name));
        this.description = bookinfo.description;
        this.img = bookinfo.cover_image_url ;
        return;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json[0];
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let partregex = new RegExp("-p[0-9]+");
        let partnumber = url.match(partregex)?.[0].slice(2);
        // eslint-disable-next-line
        let chapterregex = new RegExp("\/c[0-9]+");
        let chapterid = url.match(chapterregex)[0].slice(2);
        let apikey = "&apikey=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZrZ2toaXBhc3hxeGl0d2xrdHd6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzAyMzE4MzMsImV4cCI6MjA0NTgwNzgzM30.mHBd2yrRm934yPGy4pui3p7cW4FxfIf6yxh7b2TpUA8";
        let ret = "https://vkgkhipasxqxitwlktwz.supabase.co/rest/v1/chapters?select=*%2Cnovel%3Anovels%28id%2Ctitle%2Cauthor%2Cauthor_profile_id%29&novel_id=eq."+this.bookid+"&chapter_number=eq."+chapterid+"&part_number=";
        if (partnumber == undefined) {
            ret+= "is.null" + apikey;
        } else {
            ret+= "eq." + partnumber + apikey;
        }
        return ret;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = this.chtitle(json);
        newDoc.content.appendChild(title);
        let text = json.content.replace("\n\n", "\n");
        text = text.split("\n");
        let br = newDoc.dom.createElement("br");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/LeafStudioParser.js
================================================

"use strict";
parserFactory.register("leafstudio.site", () => new LeafStudioParser());

class LeafStudioParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".novel_index");
        return util.hyperlinksToChapterList(menu).reverse();
    }
    
    findContent(dom) {
        return dom.querySelector(".small");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".title");
    }

    // Remove unwanted elements from fetched content
    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "#font-options-bar, .confuse, .post-rating-wrapper, #donation-msg, .novel_nav_item, .text-center, .navigation");
        super.removeUnwantedElementsFromContentElement(element);
    }

    extractDescription(dom) {
        return dom.querySelector(".desc_div").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector(".title");
    }
}

================================================
FILE: plugin/js/parsers/LibersparkParser.js
================================================

/*
  parser for liberspark.com
*/
"use strict";

//dead url/ parser
parserFactory.register("liberspark.com", () => new LibersparkParser());
//dead url
parserFactory.register("veratales.com", () => new LibersparkParser());

class LibersparkParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        // Page in browser has chapter links reduced to 5
        // Fetch page again to get all chapter links.
        return HttpClient.wrapFetch(dom.baseURI).then(function(xhr) {
            let table = xhr.responseXML.querySelector("table#novel-chapters-list");
            return util.hyperlinksToChapterList(table).reverse();
        });
    }

    findContent(dom) {
        return dom.querySelector("div#chapter_body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.card-header");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-synopsis")];
    }    
}

================================================
FILE: plugin/js/parsers/Libri7Parser.js
================================================

"use strict";

parserFactory.register("libri7.com", () => new Libri7Parser());

class Libri7Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.c-chapter");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".p-book-detail h3");
    }

    async fetchChapter(url) {
        return (await HttpClient.fetchHtml(url)).responseXML;
    }

    customRawDomToContentStep(chapter, content) {
        let toParse = content.querySelector("p.pre-line");
        if (toParse !== null) {
            util.convertPreTagToPTags(chapter.rawDom, toParse, "\n\n");
            let div = chapter.rawDom.createElement("div");
            util.convertElement(toParse, div);
        }
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".c-book-cover__wrap");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".book-panel-info__desc")];
    }
}

================================================
FILE: plugin/js/parsers/LightNovelBastionParser.js
================================================

"use strict";

parserFactory.register("lightnovelbastion.com", () => new LightNovelBastionParser());

class LightNovelBastionParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.listing-chapters_wrap");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.reading-content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("ol.breadcrumb li.active").textContent;
    }

    extractTitleImpl(dom) {
        let element = dom.querySelector("div.post-title");
        if (element !== null) {
            util.removeChildElementsMatchingSelector(element, "span");
            return element.textContent;
        }
        return null;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.lnbad-tag");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content p:not(.zeno_font_resizer)")];
    }
}

================================================
FILE: plugin/js/parsers/LightnovelboxParser.js
================================================

"use strict";

parserFactory.register("lightnovelbox.com", () => new LightnovelboxParser());

class LightnovelboxParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let links = [...dom.querySelectorAll("ul.chapter-list a")];
        let chapters = LightnovelboxParser.linksToChapters(links);
        let urls = LightnovelboxParser.getUrlsOfTocPages(dom);
        for (let url of urls) {
            let rawDom = (await HttpClient.fetchJson(url)).json.chapters;
            links = [...util.sanitize(rawDom).querySelectorAll("a")];
            let partialList = LightnovelboxParser.linksToChapters(links);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    static getUrlsOfTocPages(dom) {
        let ids = [...dom.querySelectorAll("div.pagination-container a[id]")]
            .map(a => parseInt(a.id));
        let last = Math.max(...ids);
        let urls = [];
        if (last !== null) {
            let name = new URL(dom.baseURI).pathname.split("/").pop();
            let prefix = `https://lightnovelbox.com/api/novels/${name}/chapters?page=`;
            for (let i = 2; i <= last; ++i) {
                urls.push(prefix + i);
            }
        }
        return urls;
    }

    static linksToChapters(links) {
        return links.map(link => ({
            sourceUrl:  "https://lightnovelbox.com" + new URL(link.href).pathname,
            title: link.querySelector(".chapter-title").textContent.trim(),
        }));
    }

    findContent(dom) {
        return dom.querySelector("div.chapter__content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.main-head h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "figure.cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary")];
    }
}

================================================
FILE: plugin/js/parsers/LightnovelfrParser.js
================================================

"use strict";

parserFactory.register("lightnovelfr.com", () => new LightnovelfrParser());

class LightnovelfrParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".eplister a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector(".epl-num").textContent + " " + link.querySelector(".epl-title").textContent
        });
    }

    findContent(dom) {
        return dom.querySelector(".entry-content")
            || dom.querySelector(".postbody");
    }

    findChapterTitle(dom) {
        let epheader = dom.querySelector(".epheader");
        if (epheader !== null) {
            let h1 = epheader.querySelector("h1");
            let cat = epheader.querySelector(".cat-series");
            return h1.textContent + " " + cat.textContent;
        }
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".sertothumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".sersys")];
    }
}

================================================
FILE: plugin/js/parsers/LightnovelreaderParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("lightnovelreader.org", () => new LightnovelreaderParser());
//dead url
parserFactory.register("lnreader.org", () => new LightnovelreaderParser());
//dead url
parserFactory.register("readlitenovel.com", () => new LightnovelreaderParser());

class LightnovelreaderParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".novels-detail-chapters a")]
            .map(a => util.hyperLinkToChapter(a)).reverse();
    }

    findContent(dom) {
        return dom.querySelector("#chapterText");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".section-header-title h2");
    }

    extractAuthor(dom) {
        let authorLabel = [...dom.querySelectorAll("a[href*='author']")].map(x => x.textContent.trim());
        return (authorLabel.length === 0) ? super.extractAuthor(dom) : authorLabel.join(", ");
    }

    removeUnwantedElementsFromContentElement(element) {
        let toRemove = [...element.querySelectorAll("center, p")]
            .filter(s => s.textContent.trim().toLowerCase() === "sponsored content");
        util.removeElements(toRemove);
        util.removeChildElementsMatchingSelector(element, ".display-hide, .hidden");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return [...dom.querySelectorAll(".cm-breadcrumb li")].pop();
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".novels-detail-left");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.empty-box:not(.gray-bg-color)")];
    }
}

================================================
FILE: plugin/js/parsers/LightnovelreadParser.js
================================================

"use strict";

//dead url
parserFactory.register("lightnovelread.com", () => new LightnovelreadParser());
parserFactory.register("goblinsguide.com", () => new GoblinsguideParser());

class LightnovelreadParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let cat_id, countPosts, baseUrl;
        [cat_id, countPosts, baseUrl] = this.extractScript(dom);
        let chapters = [];
        for (let offset = 0; offset < countPosts; offset += 100) {
            let formData = this.createFormData(cat_id, offset);
            let partialList = await (this.fetchToc(formData, baseUrl));
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    extractScript(dom) {
        let baseUrl = dom.baseURI.replace("light-novels", "novel")
            .replace("goblinsguide.com/category", "goblinsguide.com");
        let search = "const cat_id = ";
        let script = [...dom.querySelectorAll("script")]
            .filter(s => s.innerText.includes(search))
            .map(s => s.innerText);
        script = script[0].split("\n");
        let cat_id = this.extractNumber(script, search);
        let countPosts = this.extractNumber(script, "const countPosts = ");
        return [cat_id, countPosts, baseUrl];
    }

    extractNumber(strings, search) {
        let s = strings.filter(s => s.includes(search))
            .map(s => s.replace(search, ""))
            .map(s => parseInt(s.replace(";", "")));
        return s[0];
    }

    async fetchToc(formData, baseUrl) {
        let options = {
            method: "POST",
            credentials: "include",
            body: formData
        };
        let json = (await HttpClient.fetchJson(this.tocPostUrl(), options)).json;
        return json.map(j => this.jsonToChapter(j, baseUrl));
    }

    tocPostUrl() {
        return "https://lightnovelread.com/wp-content/themes/lightnovelread/template-parts/post/menu-query.php";
    }

    createFormData(cat_id, offset) {
        let formData = new FormData();
        formData.append("cat_id", cat_id);
        formData.append("offset", offset);
        formData.append("limit", 100);
        return formData;
    }

    jsonToChapter(json, baseUrl) {
        return ({
            sourceUrl:  baseUrl + json.post_name,
            title: json.post_title || json.post_name
        });
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.js-bookcard");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".category-exerpt.description")];
    }
}

class GoblinsguideParser extends LightnovelreadParser {
    constructor() {
        super();
    }

    tocPostUrl() {
        return "https://goblinsguide.com/wp-content/themes/goblinsguide/template-parts/category/chapters-query.php";
    }

    removeUnwantedElementsFromContentElement(element) {
        let child = element.children[0];
        if (child.tagName === "A") {
            child.remove();
        }
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/LightnovelsmeParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("lightnovels.me", () => new LightnovelsmeParser());
//dead url
parserFactory.register("pandapama.com", () => new LightnovelsmeParser());
//dead url
parserFactory.register("lightnovels.live", () => new LightnovelsmeParser());

class LightnovelsmeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("main div.overflow-hidden")];
    }
}

================================================
FILE: plugin/js/parsers/LightNovelsTranslationsParser.js
================================================

"use strict";

parserFactory.register("lightnovelstranslations.com", () => new LightNovelsTranslationsParser());

class LightNovelsTranslationsParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.chapter-item a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.text_story");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.novel_title h3");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel_info");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel_text")];
    }

    extractAuthor(dom) {
        const authorEl = dom.querySelector("div.novel_detail_info > ul > li:nth-child(1)");
        if (authorEl) {
            return authorEl.textContent.replace("Author: ", "");
        }

        return "<unknown>";
    }
}

================================================
FILE: plugin/js/parsers/LightNovelWorldParser.js
================================================

"use strict";

parserFactory.register("findnovel.net", () => new FindNovelParser());
parserFactory.register("lightnovelcave.com", () => new LightNovelWorldParser());
parserFactory.register("lightnovelworld.co", () => new LightNovelWorldParser());
parserFactory.register("lightnovelworld.com", () => new LightNovelWorldParser());
parserFactory.register("lightnovelpub.com", () => new LightNovelPubParser());
parserFactory.register("lightnovelpub.fan", () => new LightNovelWorldParser());
parserFactory.register("novelfire.docsachhay.net", () => new LightNovelWorldParser());
parserFactory.register("novelbob.org", () => new LightNovelWorldParser());
parserFactory.register("novelpub.com", () => new LightNovelWorldParser());
parserFactory.register("novelfire.net", () => new NovelfireParser());
parserFactory.register("webnovelpub.com", () => new LightNovelWorldParser());
parserFactory.register("webnovelpub.pro", () => new LightNovelWorldParser());
parserFactory.register("pandanovel.co", () => new LightNovelWorldParser());

class LightNovelWorldParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        if (!dom.baseURI.endsWith("/chapters")) {
            dom = (await HttpClient.wrapFetch(dom.baseURI + "/chapters")).responseXML;
        }
        let chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);

        for (let url of urlsOfTocPages) {
            await this.rateLimitDelay();
            let newDom = (await HttpClient.wrapFetch(url)).responseXML;
            let partialList = this.extractPartialChapterList(newDom);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    getVerificationToken(dom) {
        let element = dom.querySelector("input[name='__RequestVerificationToken']");
        return element.getAttribute("value");
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.chapter-list a")]
            .map(this.linkToChapterIfo);
    }

    linkToChapterIfo(link) {
        let title = link.querySelector(".chapter-title").textContent.trim();
        const isChapter = title.toLowerCase().includes("chapter");
        let chaperNo = link.querySelector(".chapter-no")?.textContent?.trim() ?? "";
        if (!isChapter && chaperNo !== "") {
            chaperNo += ": ";
        } else {
            chaperNo = "";
        }
        return {
            sourceUrl:  link.href,
            title: chaperNo + title,
            newArc: null
        };
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let paginateUrls = [...dom.querySelectorAll("ul.pagination li a")]
            .map(a => a.href);
        if (0 < paginateUrls.length) {
            let maxPage = this.maxPageId(paginateUrls);
            let url = new URL(paginateUrls[0]);
            for (let i = 2; i <= maxPage; ++i) {
                url.searchParams.set("page", i);
                urls.push(url.href);
            }
        }
        return urls;
    }

    // last URL isn't always last ToC page
    maxPageId(urls) {
        let pageNum = function(url) {
            let pageNo = new URL(url).searchParams.get("page");
            return parseInt(pageNo);
        };
        return urls.reduce((p, c) => Math.max(p, pageNum(c)), 0);
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content")
            || dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.novel-info h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span[itemprop='author']");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        let toRemove = [...element.querySelectorAll("p")]
            .filter(this.isWatermark);
        util.removeElements(toRemove);

        toRemove = [...element.querySelectorAll("strong")]
            .filter(e => e.parentNode.tagName == "STRONG")
            .map(e => e.parentNode);
        util.removeElements(toRemove);

        toRemove = [...element.querySelectorAll("div > dl > dt")]
            .map(e => e.parentNode.parentNode);
        util.removeElements(toRemove);

        super.removeUnwantedElementsFromContentElement(element);
    }

    isWatermark(element) {
        return !!element.className;
    }

    findChapterTitle(dom) {
        return dom.querySelector("span.chapter-title");
    }

    findCoverImageUrl(dom) {
        let metaImage = dom.querySelector("meta[property*='og:image']");
        if (metaImage)
        {
            metaImage = metaImage.content;
        }
        return metaImage || util.getFirstImgSrc(dom, "div.header-body");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-info, section#info")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "nav.links");
    }
}

class LightNovelPubParser extends LightNovelWorldParser {
    constructor() {
        super();
        this.minimumThrottle = 1200;
    }
}

class FindNovelParser extends LightNovelWorldParser {
    constructor() {
        super();
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeHTMLUnknownElement(element);
        super.removeUnwantedElementsFromContentElement(element);
    }
}

class NovelfireParser extends FindNovelParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        if (!dom.baseURI.endsWith("/chapters")) {
            dom = (await HttpClient.wrapFetch(dom.baseURI + "/chapters")).responseXML;
        }

        let chapterListUrl = this.buildChapterListRequestUrl(dom);
        if (chapterListUrl == null) {
            return super.getChapterUrls(dom, chapterUrlsUI);
        }
        let json = (await HttpClient.fetchJson(chapterListUrl)).json;

        let root = this.getChapterUrlRoot(dom);
        return json.data.map(d => NovelfireParser.dataToChapter(d, root));
    }

    buildChapterListRequestUrl(dom) {
        let prefix = "/listChapterDataAjax";
        let script = [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes(prefix))
            .map(s => s.textContent)[0];
        if (script) {
            let startIndex = script.indexOf(prefix);
            let endIndex = script.indexOf("\",", startIndex);
            let fragment = script.substring(startIndex, endIndex);

            let host = new URL(dom.baseURI).hostname;
            return "https://" + host + fragment +
                "&draw=1&columns%5B0%5D%5Bdata%5D=title&columns%5B0%5D%5Bname%5D=&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=false&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=created_at&columns%5B1%5D%5Bname%5D=&columns%5B1%5D%5Bsearchable%5D=true&columns%5B1%5D%5Borderable%5D=true&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=n_sort&columns%5B2%5D%5Bname%5D=&columns%5B2%5D%5Bsearchable%5D=false&columns%5B2%5D%5Borderable%5D=true&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=2&order%5B0%5D%5Bdir%5D=asc&start=0&length=-1&search%5Bvalue%5D=&search%5Bregex%5D=false";
        }
        return null;
    }

    getChapterUrlRoot(dom) {
        let root = dom.baseURI;
        return root.endsWith("/chapters")
            ? root.replace("/chapters", "" )
            : root;
    }

    static dataToChapter(data, root) {
        return ({
            sourceUrl: root + "/chapter-" + data.n_sort,
            title: data.title,
        });
    }
}

================================================
FILE: plugin/js/parsers/LiteroticaParser.js
================================================

/*
  Parser for <https://www.literotica.com>
*/
"use strict";

parserFactory.register("literotica.com", () => new LiteroticaParser());

class LiteroticaParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        const section = dom.baseURI.split("//")[1].split("/")[1];

        return this.getChapterUrlsFromMultipleTocPages(
            dom,
            this.chaptersFromMemberPage,
            section === "top"
                ? this.getUrlOfTopTocPages
                : this.getUrlOfCategoryTocPages,
            chapterUrlsUI
        );
    }

    getUrlOfTopTocPages(dom) {
        const link = dom.querySelector("span.pwrpr a:last-child ");
        let urls = [];
        if (link != null) {
            const limit = parseInt(link.text);
            for (let i = 1; i <= limit; i++) {
                urls.push(LiteroticaParser.buildTopUrl(link, i));
            }
        }
        return urls;
    }
    getUrlOfCategoryTocPages(dom) {
        const link = dom.querySelector("div.b-alpha-links li:last-child a");

        let urls = [];
        if (link != null) {
            const limit = parseInt(link.href.split("/").pop());

            for (let i = 1; i <= limit; i++) {
                urls.push(LiteroticaParser.buildCategoryUrl(link, i));
            }
        }

        return urls;
    }

    static buildTopUrl(link, i) {
        link.search = `?page=${i}`;
        return link.href;
    }
    static buildCategoryUrl(link, i) {
        const pathname = link.pathname.split("/").slice(0, -1);
        link.pathname = pathname.join("/") + `/${i}-page`;
        return link.href;
    }

    chaptersFromMemberPage(dom) {
        const section = dom.baseURI.split("//")[1].split("/")[1];

        if (section === "series") {
            let links = [...dom.querySelectorAll("ul.series__works li a.br_rj")];
            return links.map((a) => util.hyperLinkToChapter(a));
        } else if (section === "s") {
            let content = dom.querySelector("div.aa_ht");
            return content === null ? [] : util.hyperlinksToChapterList(content);
        } else if (section === "stories") {
            let links = [...dom.querySelectorAll("td.fc a, div.b-story-list-box h3 a, div.b-story-list h3 a")];
            if (0 < links.length) {
                return links.map((a) => util.hyperLinkToChapter(a));
            }
            let content = dom.querySelector("div.b-story-list");
            return content === null ? [] : util.hyperlinksToChapterList(content);
        } 
        else {
            let links = [...dom.querySelectorAll("td.mcol a:first-child")];
            if (0 < links.length) {
                return links.map((a) => util.hyperLinkToChapter(a));
            }
            let content = dom.querySelector("div.b-story-list");
            return content === null ? [] : util.hyperlinksToChapterList(content);
        }
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.headline");
    }

    extractAuthor(dom) {

        let authorLabel = dom.querySelector("div.y_eS a")?.text;
        return authorLabel || "Various Authors";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#tabpanel-info");
    }

    findContent(dom) {
        return LiteroticaParser.contentForPage(dom);
    }

    static contentForPage(dom) {
        return dom.querySelector("div.aa_ht")
            || dom.querySelector("body div");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.headline");
    }

    fetchChapter(url) {
        let dom = null;
        return HttpClient.wrapFetch(url).then(function(xhr) {
            dom = xhr.responseXML;
            let pageUrls = LiteroticaParser.findUrlsOfAdditionalPagesMakingChapter(url, dom);
            return Promise.all(pageUrls.map(LiteroticaParser.fetchAdditionalPageContent));
        }).then(function(fragments) {
            return LiteroticaParser.assembleChapter(dom, fragments);
        });
    }

    static findUrlsOfAdditionalPagesMakingChapter(url, dom) {
        let pageIds = [...dom.querySelectorAll("div.l_bH a.l_bJ")]
            .map(o => parseInt(o.href.split("=")[1]))
            .filter(t => t !== 1);
        let urls = [];
        const totalPages = (0 < pageIds.length) ? pageIds.pop() : 0;
        for (let i = 2; i <= totalPages; ++i) {
            urls.push(`${url}?page=${i}`);
        }
        return urls;
    }

    static fetchAdditionalPageContent(url) {
        return HttpClient.wrapFetch(url).then(function(xhr) {
            return LiteroticaParser.contentForPage(xhr.responseXML);
        });
    }

    static assembleChapter(dom, fragments) {
        let content = LiteroticaParser.contentForPage(dom);
        for (let f of fragments.filter(f => f !== null)) {
            while (0 < f.children.length) {
                content.appendChild(f.children[0]);
            }
        }
        return dom;
    }
}

================================================
FILE: plugin/js/parsers/LnmtlParser.js
================================================

/*
  parses lnmtl.com
*/
"use strict";

//dead url/ parser
parserFactory.register("lnmtl.com", () => new LnmtlParser());

class LnmtlParser extends Parser {
    constructor() {
        super();
    }

    populateUIImpl() {
        document.getElementById("removeOriginalRow").hidden = false; 
        document.getElementById("removeTranslatedRow").hidden = false; 
    }
  
    getChapterUrls(dom) {
        let volumesList = LnmtlParser.findVolumesList(dom);
        if (volumesList.length !== 0) {
            return LnmtlParser.fetchChapterLists(volumesList, HttpClient.fetchJson).then(function(lists) {
                return LnmtlParser.mergeChapterLists(lists); 
            });
        }

        let table = dom.querySelector("#volumes-container table");
        return Promise.resolve(util.hyperlinksToChapterList(table));
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-body");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h3.dashhead-title");
    }

    customRawDomToContentStep(chapter, content) {
        for (let s of content.querySelectorAll("sentence")) {
            if (this.userPreferences.removeOriginal.value && s.className === "original") {
                s.remove();
            } else if (this.userPreferences.removeTranslated.value && s.className === "translated") {
                s.remove();
            } else {
                let p = s.ownerDocument.createElement("p");
                p.innerText = s.innerText;
                s.replaceWith(p);
            }
        } 
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.jumbotron.novel");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.description")];
    }

    static findVolumesList(dom) {
        let startString = "lnmtl.volumes = ";
        let scriptElement = util.getElement(dom, "script", e => 0 <= e.textContent.indexOf(startString));
        if (scriptElement !== null) {
            return util.locateAndExtractJson(scriptElement.textContent, startString);
        }
        return []; 
    }

    static fetchChapterLists(volumesList, fetchJson) {
        return Promise.all(
            volumesList.map(volume => LnmtlParser.fetchChapterListsForVolume(volume, fetchJson))
        );
    }

    static fetchChapterListsForVolume(volumeInfo, fetchJson) {
        let restUrl = LnmtlParser.makeChapterListUrl(volumeInfo.id, 1);
        return fetchJson(restUrl).then(function(handler) {
            let firstPage = handler.json;
            let pagesForVolume = [Promise.resolve(handler)];
            for ( let i = 2; i <= firstPage.last_page; ++i) {
                let url = LnmtlParser.makeChapterListUrl(volumeInfo.id, i);
                pagesForVolume.push(fetchJson(url));
            }
            return Promise.all(pagesForVolume);
        });
    }

    static makeChapterListUrl(volumeId, page) {
        return `http://lnmtl.com/chapter?page=${page}&volumeId=${volumeId}`;
    }

    static mergeChapterLists(lists) {
        let chapters = [];
        for (let list of lists) {
            for (let page of list) {
                for (let chapter of page.json.data) {
                    chapters.push({
                        sourceUrl: chapter.site_url,
                        title: "#" + chapter.number + ": " + chapter.title,
                        newArc: null                    
                    });
                }
            }
        }
        return chapters;
    }
}

================================================
FILE: plugin/js/parsers/LoreNovelsParser.js
================================================

"use strict";

parserFactory.register("lorenovels.com", () => new LoreNovelsParser());

class LoreNovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        const toc = dom.querySelector("ul.wp-block-latest-posts__list");
        if (!toc) {
            return [];
        }

        const items = [...toc.querySelectorAll(
            "a.wp-block-latest-posts__post-title"
        )];

        return this.buildChapterList(items);
    }

    buildChapterList(items) {
        return items
            .reverse() // newest → oldest → reading order
            .map(a => ({
                sourceUrl: a.href,
                title: a.textContent.trim()
            }));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content.wp-block-post-content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(
            element.querySelectorAll(
                "div.wp-block-buttons"
            )
        );
    }
}

================================================
FILE: plugin/js/parsers/MachineTranslationParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("machine-translation.org", () => new MachineTranslationParser());

class MachineTranslationParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let toc = dom.querySelector("div.table-body, div.chapter-list");
        return util.hyperlinksToChapterList(toc).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.read-context");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.title b, h2.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.title span, p.author");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector(".read-title");
    }

    findCoverImageUrl(dom) {
        let bookimg = dom.querySelector("div.book-img");
        if (bookimg.querySelector("img")) {
            return util.getFirstImgSrc(dom, "div.book-img");
        }
        return util.extractUrlFromBackgroundImage(bookimg);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.book-info-bottom .context")];
    }
}

================================================
FILE: plugin/js/parsers/MadaraParser.js
================================================

"use strict";

parserFactory.register("listnovel.com", () => new MadaraParser());
//dead url
parserFactory.register("readwebnovel.xyz", () => new MadaraParser());
parserFactory.register("wuxiaworld.site", () => new MadaraParser());
//dead url
parserFactory.register("pery.info", () => new MadaraParser());
parserFactory.register("morenovel.net", () => new MadaraParser());
parserFactory.register("nightcomic.com", () => new MadaraParser());
//dead url
parserFactory.register("webnovel.live", () => new MadaraParser());
//dead url
parserFactory.register("noveltrench.com", () => new MadaraParser());
parserFactory.register("mangasushi.net", () => new MadaraParser());
//dead url
parserFactory.register("mangabob.com", () => new MadaraParser());
parserFactory.register("greenztl2.com", () => new MadaraVariantParser());

parserFactory.register("indratranslations.com", () => new KdtnovelsParser());
parserFactory.register("kdtnovels.com", () => new KdtnovelsParser());

parserFactory.registerRule(
    (url, dom) => MadaraParser.isMadaraTheme(dom) * 0.6,
    () => new MadaraParser()
);

class MadaraParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    static isMadaraTheme(dom) {
        return 0 < dom.querySelectorAll("li.wp-manga-chapter a").length;
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.wp-manga-chapter a:not([title])")]
            .map(a => util.hyperLinkToChapter(a)).reverse();
        //if single chapter result, try MadaraVariantParser logic.
    }

    findContent(dom) {
        let content =
            dom.querySelector(".reading-content .text-left") ||
            dom.querySelector("div.reading-content");

        for (let i of content.querySelectorAll("img")) {
            let data_src = i.getAttribute("data-src");
            if (!util.isNullOrEmpty(data_src) && util.isNullOrEmpty(i.src)) {
                i.src = data_src.trim();
            }
        }
        return content;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }
 
    extractSubject(dom) {
        let tags = [...dom.querySelectorAll("div .genres-content [rel='tag']")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        let descriptionElement = dom.querySelector(".summary__content");
        return descriptionElement === null ? "" : descriptionElement.textContent.trim();
    }
    

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.addtoany_share_save_container");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("ol.breadcrumb li.active, .wp-manga-chapter.reading a").textContent;
    }
 
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        let nodes = [...dom.querySelectorAll("div.summary__content")];
        if (nodes.length === 0) {
            nodes = [...dom.querySelectorAll("div.manga-summary p")];
        }
        if (nodes.length === 0) {
            nodes = [...dom.querySelectorAll("div.excerpt-content p")];
        }
        return nodes;
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script");
    }
}

class MadaraVariantParser extends MadaraParser {
    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.wp-manga-chapter a:not([title], [data-locked='1'])")]
            .map(a => this.hyperLinkToChapter(a)).reverse();
    }

    hyperLinkToChapter(link, newArc) {
        let retVal = util.hyperLinkToChapter(link, newArc);
        let uri = retVal.sourceUrl;
        if (!uri || link.attributes.href.value == "#") //search for alternate URLs if typical link fails
        {
            uri = null;
            if (link.dataset.link)
            {
                retVal.sourceUrl = link.dataset.link;
            }
            else
            {
                [...link.attributes].forEach(attr => {
                    try {
                        uri = new URL(attr.value);
                    } catch (_)
                    {
                        //Failed to detect URL in Attribute.
                    }
                });
                if (uri && uri.href)
                {
                    retVal.sourceUrl = uri.href;
                }
            }
        }

        return retVal;
    }
    
    findChapterTitle(dom) {
        return dom.querySelector(".main-col h1:not(.menu-title)").textContent;
    }
}

class KdtnovelsParser extends MadaraParser {
    findChapterTitle(dom) {
        return dom.querySelector("h3.chapter-name");
    }
}

================================================
FILE: plugin/js/parsers/MadnovelParser.js
================================================

"use strict";

parserFactory.register("madnovel.com", () => new MadnovelParser());
parserFactory.register("novelbuddy.com", () => new MadnovelParser());
parserFactory.register("novelbuddy.io", () => new MadnovelParser());

class MadnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".chapter-list");
        if (menu == null) { return []; }

        let linkSet = new Set();
        let includeLink = function(link) {
            if (util.isNullOrEmpty(link.innerText) || util.isNullOrEmpty(link.href)) {
                return false;
            }
            let href = util.normalizeUrlForCompare(link.href);
            if (linkSet.has(href)) {
                return false;
            }
            linkSet.add(href);
            return true;
        };

        return util.getElements(menu, "a", a => includeLink(a))
            .map(link => ({
                sourceUrl: link.href,
                title: link.querySelector("strong").innerText,
                newArc: null
            }))
            .reverse();
    }

    findContent(dom) {
        return dom.querySelector(".content-inner");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = [...dom.querySelectorAll("a[href*='authors'] span")].map(x => x.textContent.trim());
        return (authorLabel.length === 0) ? super.extractAuthor(dom) : authorLabel.join(", ");
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll("a[href*='genres']")];
        return tags.map(e => e.textContent.trim()).join("");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".ads-banner, .content-inner > br");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("#chapter__content h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".img-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".section-body.summary")];
    }
}

================================================
FILE: plugin/js/parsers/MagicWizardsParser.js
================================================

/*
  MagicWizardsParser.js v0.72
  
  Parser for Magic the Gathering fiction, found on:

- mtgstory.com (redirect)
- <https://magic.wizards.com/en/story> (2023-2024)
- <https://magic.wizards.com/en/articles/columns/magic-story> (2014-2018)
- Archive.org versions of the above
- TODO: mtglore.com (redirects & mirrors)
- TODO: <https://magic.wizards.com/en/story> (Q4 2018-2022)
- TODO: Planeswalkers & Planes Databank
- TODO: Featured story slider Q1 2018
- UNTESTED: <http://www.wizards.com/Magic/Magazine/Article.aspx> (2014 and earlier)
- WONTFIX: hanweirchronicle.com (Tumblr blog, mostly image posts)
*/
"use strict";

// Register the parser for magic.wizards.com (archive.org is implicit)
parserFactory.register("magic.wizards.com", () => new MagicWizardsParser());

class MagicWizardsParser extends Parser {
    constructor() {
        super();
    }

    // Extract the list of chapter URLs
    async getChapterUrls(dom) {
        let chapterLinks = [];
        chapterLinks = [...dom.querySelectorAll("article a, .article-content a, window.location.hostname, #content article a, #content .article-content a, .articles-listing .article-item a, .articles-bloc .article .details a")];
        // Filter out author links using their URL pattern
        chapterLinks = chapterLinks.filter(link => !this.isAuthorLink(link));
        return chapterLinks.map(this.linkToChapter);
    }

    // Helper function to detect if a link is an author link
    isAuthorLink(link) {
        const href = link.href;
        const authorPattern = /\/archive\?author=/;
        
        // Check if the link matches the author URL pattern or CSS selector
        return authorPattern.test(href);
    }

    // Format chapter links into a standardized structure
    linkToChapter(link) {
        const titleSelectors = [
            "h3",                     // First option: <h3> tag
            ".article-item .title",   // Second option: <p class="title">
            ".details .title"         // Third option: <p class="title" inside .details>
        ];
    
        let titleElement = null;
    
        // Iterate through the selectors and find the first matching element
        for (const selector of titleSelectors) {
            titleElement = link.closest("article")?.querySelector(selector) || 
                        link.closest(".article-item")?.querySelector(selector) || 
                        link.closest(".details")?.querySelector(selector);
            
            if (titleElement) {
                break; // Exit the loop if a title element is found
            }
        }
    
        // Fallback to the link text itself if no titleElement found (this handles simpler cases)
        let title = titleElement ? titleElement.textContent.trim() : link.textContent.trim();
    
        return {
            sourceUrl: link.href,
            title: title
        };
    }

    // Extract the content of the chapter
    findContent(dom) {
        return dom.querySelector("#content article, .article_detail #main-content article, #article-body article, #primary-area section, section article, section, .article_detail #main-content");
    }
   
    // Grab cover image
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".swiper-slide img, article img");
    }

}

================================================
FILE: plugin/js/parsers/MandarinducktalesParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("mandarinducktales.com", () => new MandarinducktalesParser());

class MandarinducktalesParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".wp-container-10 p a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector(".wp-container-10");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".wp-container-10")];
    }
}

================================================
FILE: plugin/js/parsers/MangadexParser.js
================================================

"use strict";

parserFactory.register("mangadex.org", () => new MangadexParser());
parserFactory.register("api.mangadex.org", () => new MangadexParser());

class MangadexParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let mangaId = new URL(dom.baseURI).pathname.split("/")[2];
        let feedUrl = new URL(`https://api.mangadex.org/manga/${mangaId}/feed`);
        feedUrl.searchParams.set("translatedLanguage[]", "en");
        let json = (await HttpClient.fetchJson(feedUrl.href)).json;
        return json.data.map(this.buildChapterInfo);
    }

    buildChapterInfo(json) {
        let title = "";
        let attributes = json.attributes;
        if (attributes.volume) {
            title = "Volume: " + attributes.volume + " ";
        }
        if (attributes.chapter) {
            title += "Chapter: " + attributes.chapter + " ";
        }
        if (attributes.title) {
            title += attributes.title;
        }
        return ({
            title: title.trim(),
            sourceUrl: `https://api.mangadex.org/at-home/server/${json.id}`
        });
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".title p");
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "[style='grid-area: art;']");
    }
    
    async fetchChapter(url) {
        let options = { };
        let json = (await HttpClient.fetchJson(url, options)).json;
        return MangadexParser.jsonToHtmlWithImgTags(url, json);
    }

    static jsonToHtmlWithImgTags(pageUrl, json) {
        let newDoc = Parser.makeEmptyDocForContent(pageUrl);
        let baseUrl = json.baseUrl + "/data/" + json.chapter.hash + "/";
        for (let data of json.chapter.data) {
            let img = newDoc.dom.createElement("img");
            img.src = baseUrl + data;
            newDoc.content.appendChild(img);
        }
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.md-md-container")]
            .filter(row => (row.querySelector("img, button") === null));
    }
}

================================================
FILE: plugin/js/parsers/MangaHereParser.js
================================================

/*
  Parses Manga
*/
"use strict";

parserFactory.register("www.mangahere.cc", () => new MangaHereParser());

class MangaHereParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div#chapterlist li a")]
            .map(a => util.hyperLinkToChapter(a))
            .reverse();
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    convertSelectToImgTagsToFollow(dom, content, select) {
        let options = Array.from(select.querySelectorAll("option"));
        for (let option of options.filter(o => !o.value.includes("featured"))) {
            let img = dom.createElement("img");
            img.src = option.value;
            content.appendChild(img);
        }
        
        // first image in list is current page, so replace with image URL 
        // to skip fetching this page again
        let firstImg = this.imageCollector.selectImageUrlFromImagePage(dom);
        content.querySelector("img").src = firstImg;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.detail-info-cover");
    }

    async fetchChapter(url) {
        // need to open chapter in tab so cookies are loaded
        let tabToClose = await util.createChapterTab(url);
        await util.sleep(5000);
        await MangaHereParser.closeChapterTab(tabToClose);
        let xhr = await HttpClient.wrapFetch(url);
        let newDoc = Parser.makeEmptyDocForContent(url);
        newDoc.dom.base = url;
        let jsonUrls = MangaHereParser.makeImgJsonUrls(url, xhr.responseXML);
        let imgUrls = MangaHereParser.extractImgUrlsFromDom(xhr.responseXML);
        if (jsonUrls.length <= imgUrls.length) {
            MangaHereParser.addImgsToNewDoc(newDoc, imgUrls, new Set());
            return newDoc.dom;
        }
        return MangaHereParser.buildPageWithImageTags(jsonUrls, new Set(), newDoc, "");
    }

    static extractImgUrlsFromDom(dom) {
        let script = [...dom.querySelectorAll("script")]
            .filter(s => s.innerHTML.includes("al(function(p,a,c,k,e,d){"))
            .map(s => s.innerHTML);

        return (script.length === 1)
            ? MangaHereParser.decryptChapterFun(script[0], "")
            : [];
    }

    static closeChapterTab(tabId) {
        return new Promise(function(resolve) {
            chrome.tabs.remove(tabId, () => resolve());
        });
    }

    static async buildPageWithImageTags(jsonUrls, imgUrls, newDoc, err) {

        if (!util.isNullOrEmpty(err)) {
            ErrorLog.log(err);
            return newDoc.dom;
        }
        if (jsonUrls.length <= imgUrls.size) {
            return newDoc.dom;
        }
        let tocUrl = jsonUrls[imgUrls.size];
        let js = await HttpClient.fetchText(tocUrl);
        err = MangaHereParser.responseToImg(newDoc, js, tocUrl, imgUrls);
        return MangaHereParser.buildPageWithImageTags(jsonUrls, imgUrls, newDoc, err);
    }

    static makeImgJsonUrls(url, dom) {
        let script = [...dom.querySelectorAll("script")]
            .filter(MangaHereParser.isWantedScriptElement)
            .map(s => s.innerHTML);

        let chapterId = util.extractSubstring(script[0], MangaHereParser.chatperIdPrefix, ";");
        let imageCount = parseInt(util.extractSubstring(script[0], /var\s*imagecount\s*=\s*/, ";"));

        let index = url.lastIndexOf("/");
        let root = url.substring(0, index + 1);
        let urls = [];
        for (let i = 1; i <= imageCount; ++i) {
            urls.push(`${root}chapterfun.ashx?cid=${chapterId}&page=${i}`);
        }
        return urls;
    }

    static isWantedScriptElement(script) {
        let match = script.innerHTML.match(MangaHereParser.chatperIdPrefix);
        return (match !== null);
    }

    static responseToImg(newDoc, js, tocUrl, imgUrls) {
        if (util.isNullOrEmpty(js)) {
            return `No response for URL ${tocUrl}\r\n`;
        } else {
            let urls = MangaHereParser.decryptChapterFun(js);
            MangaHereParser.addImgsToNewDoc(newDoc, urls, imgUrls);
            return "";
        }
    }

    static addImgsToNewDoc(newDoc, urls, imgUrls) {
        for (let u of urls) {
            if (!imgUrls.has(u)) {
                imgUrls.add(u);
                let img = newDoc.dom.createElement("img");
                img.src = u;
                newDoc.content.appendChild(img);
            }
        }
    }

    static decryptChapterFun(js, prefix) {
        let d = MangaHereParser.extractDataFromjs(js);
        let clearText = MangaHereParser.decrypt(d[0], d[1], d[2], d[3].split("|"));
        return MangaHereParser.extractFilenameFromClearText(clearText, prefix);
    }

    static extractDataFromjs(js) {
        let text = util.extractSubstring(js, "return p;}('" , ".split(");
        text = text.replace(/"/g, "\\\"").replace(/'/g, "\"");
        return JSON.parse("[\"" + text + "]");
    }

    static extractFilenameFromClearText(clearText, prefix) {
        if (prefix === undefined) {
            prefix = util.extractSubstring(clearText, "\"", "\"");
        }
        if (!clearText.includes("[") || !clearText.includes("]")) {
            return [];
        }
        let urls = util.extractSubstring(clearText, "[", "]").split(",");
        return urls.map(u => "http:" + prefix + u.replace(/"/g, ""));
    }

    // extracted from MangaHere (and deobfuscated)
    static decrypt(p, max, len, fragments) {
        let makeKey = function(index) {
            return (index < max ? "" : makeKey(parseInt(index / max))) + ((index = index % max) > 35 ? String.fromCharCode(index + 29) : index.toString(36));
        };
        let replacements = {};
        while (len--)
        {
            let key = makeKey(len);
            replacements[key] = fragments[len] || key;
        }
        let replacerFunction = (key) => replacements[key];
        p = p.replace(new RegExp("\\b\\w+\\b", "g"), replacerFunction);
        return p;        
    }
}

MangaHereParser.chatperIdPrefix = /var\s*chapterid\s*=\s*/;

================================================
FILE: plugin/js/parsers/MangakakalotParser.js
================================================

"use strict";

parserFactory.register("mangakakalot.com", () => new MangakakalotParser());

class MangakakalotParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chaptersElement = dom.querySelector("div#chapter");
        return Promise.resolve(util.hyperlinksToChapterList(chaptersElement).reverse());
    }

    findContent(dom) {
        return dom.querySelector("div#vungdoc");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.manga-info-top h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("ul.manga-info-text a[href*='search_author']");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.manga-info-pic");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("ul.manga-info-text, div#noidungm")];
    }
}

================================================
FILE: plugin/js/parsers/MangallamaParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("mangallama.com", () => new MangalamaParser());

class MangalamaParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chaptersElement = dom.querySelector("table.table-striped");
        return Promise.resolve(util.hyperlinksToChapterList(chaptersElement).reverse());
    }

    findContent(dom) {
        return dom.querySelector("div#chapcontainer");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div#titlecontainer").textContent;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img.img-thumbnail").src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#description")];
    }
}

================================================
FILE: plugin/js/parsers/ManganeloParser.js
================================================

"use strict";

parserFactory.register("manganelo.com", () => new ManganeloParser());

class ManganeloParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.panel-story-chapter-list a")]
            .map(a => util.hyperLinkToChapter(a))
            .reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.container-chapter-reader");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.story-info-right h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.story-info-left");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#panel-story-info-description")];
    }
}

================================================
FILE: plugin/js/parsers/ManganovParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("manganov.com", () => new ManganovParser());

class ManganovParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = [...dom.querySelectorAll("ul.chapter-list-wrapper")].pop();
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.mn-novel-chapter-content-body, div.chapter-images");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.info h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.info h6.info-details");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2.mt-1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section.mb-3.mt-2  p")];
    }
}

================================================
FILE: plugin/js/parsers/MangaReadParser.js
================================================

"use strict";

parserFactory.register("mangaread.co", () => new MangaReadParser());

class MangaReadParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.wp-manga-chapter a")]
            .map(a => util.hyperLinkToChapter(a)).reverse();
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let responseXML = (await HttpClient.wrapFetch(url)).responseXML;
        let newDoc = Parser.makeEmptyDocForContent(url);
        newDoc.dom.base = url;
        let imgUrls = this.makeImgUrls(responseXML);
        return this.buildPageWithImageTags(imgUrls, newDoc);
    }

    makeImgUrls(dom) {
        // really, should follow the links in the <option> elements and extract the image url
        // for each page, but this makes fewer calls to mangaread.co
        let img = dom.querySelector(".wp-manga-chapter-img");
        let options = [...dom.querySelector("select#single-pager").querySelectorAll("option")];
        let base = img.getAttribute("data-lazy-src");
        let index = base.lastIndexOf("/");
        base = base.substring(0, index + 1);
        let imgUrls = [];
        for (let i = 1; i <= options.length; ++i) {
            let name = ("00" + i);
            name = name.substring(name.length - 3);
            imgUrls.push(base + name + ".jpg");
        }
        return imgUrls;
    }

    async buildPageWithImageTags(imgUrls, newDoc) {
        for (let u of imgUrls) {
            let img = newDoc.dom.createElement("img");
            img.src = u;
            newDoc.content.appendChild(img);
        }
        return newDoc.dom;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content")];
    }
}

================================================
FILE: plugin/js/parsers/ManhwadenParser.js
================================================

"use strict";

parserFactory.register("manhwaden.com", () => new ManhwadenParser());

class ManhwadenParser extends MadaraParser {
    constructor() {
        super();
    }

    preprocessRawDom(webPageDom) {
        util.removeChildElementsMatchingSelector(webPageDom, "img:not([src])");
    }
}

================================================
FILE: plugin/js/parsers/ManhwatopParser.js
================================================

"use strict";

parserFactory.register("manhwatop.com", () => new ManhwatopParser());

class ManhwatopParser extends MadaraParser {
    constructor() {
        super();
    }

    preprocessRawDom(webPageDom) {
        util.resolveLazyLoadedImages(webPageDom, ".reading-content img");
        util.removeChildElementsMatchingSelector(webPageDom, "img[alt='ManhwaTop']");
    }
}

================================================
FILE: plugin/js/parsers/Marx2maoParser.js
================================================

"use strict";

parserFactory.register("marx2mao.com", () => new Marx2maoParser());

class Marx2maoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = this.findContent(dom);
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("body");
    }
}

================================================
FILE: plugin/js/parsers/MarxistsCNParser.js
================================================

"use strict";

parserFactory.register("marxists.org", () => new MarxistsCNParser());

class MarxistsCNParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("table[border='0']");
        let chapterUrls = [];
        let links = menu.querySelectorAll("a");
        for (let link of links) {
            if (link.href && link.href.endsWith(".htm")) {
                chapterUrls.push({ 
                    sourceUrl: link.href, 
                    title: link.textContent 
                });
            }
        }
        return chapterUrls;
    }

    findContent(dom) {
        return dom.querySelector("body");
    }
    
    extractTitleImpl(dom) {
        return dom.querySelector("title0");
    }

    extractLanguage() {
        return "cn";
    }
    
    extractAuthor(dom) {
        let element = dom.querySelector("author");
        return (element === null) ? "" : element.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("title");
    }

    async fetchChapter(url) {
        // site does not tell us gbk is used to encode text
        let options = { 
            makeTextDecoder: () => new TextDecoder("gbk") 
        };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }
}

================================================
FILE: plugin/js/parsers/MayanovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("mayanovel.com", () => new MayanovelParser());

class MayanovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".m-book-list li a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        return dom.querySelector(".m-infos a")?.textContent ?? null;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let nextUrl = this.nextPageOfChapterUrl(dom);
        let oldContent = this.findContent(dom);
        while (nextUrl != null) {
            let nextDom = (await HttpClient.wrapFetch(nextUrl)).responseXML;
            let newContent = this.findContent(nextDom);
            util.moveChildElements(newContent, oldContent);
            nextUrl = this.nextPageOfChapterUrl(nextDom);
        }
        return dom;
    }

    nextPageOfChapterUrl(dom) {
        let nextUrl = dom.querySelector("a[rel='next']")?.href;
        return (nextUrl != null) && nextUrl.includes("_")
            ? nextUrl
            : null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".m-book_info p")];
    }
}

================================================
FILE: plugin/js/parsers/McStoriesParser.js
================================================

/*
  parses mcstories.com
  Notes:

- For this to work, need to go to page with set of chapters.
*/
"use strict";

parserFactory.register("mcstories.com", () => new McStoriesParser());

class McStoriesParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chaptersElement = dom.querySelector("table#index, div.chapter");
        return Promise.resolve(util.hyperlinksToChapterList(chaptersElement));
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("article a[href*='/Authors/']");
        return (author === null) ? super.extractAuthor(dom) : author.textContent;
    }

    getInformationEpubItemChildNodes(dom) {
        return [ util.dctermsToTable(dom) ];
    }
}

================================================
FILE: plugin/js/parsers/MeionovelParser.js
================================================

"use strict";

parserFactory.register("meionovel.id", () => new MeionovelParser());

class MeionovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.listing-chapters_wrap ul.list-chap");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.reading-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h3");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div#text-chapter-toolbar");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        let breadcrumb = dom.querySelector("ol.breadcrumb li.active");
        return breadcrumb === null ? null : breadcrumb.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.post-content, .summary__content")];
    }
}

================================================
FILE: plugin/js/parsers/MetanovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.metanovel.org", () => new MetanovelParser());

class MetanovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocUrl = dom.baseURI + "/chapters/1";
        let tocPage = (await HttpClient.wrapFetch(tocUrl)).responseXML;

        return (await this.walkTocPages(tocPage, 
            this.chaptersFromDom, 
            this.nextTocPageUrl, 
            chapterUrlsUI
        ));
    }

    chaptersFromDom(dom) {
        let menu = dom.querySelector(".section-list");
        return util.hyperlinksToChapterList(menu);
    }

    nextTocPageUrl(dom) {
        let nextUrl = dom.querySelector(".listpage span.right a")?.href;
        return util.isNullOrEmpty(nextUrl) ? null : nextUrl;
    }
    
    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".detail-box h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".imgbox");
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom) {
        let nextUrl = [...dom.querySelectorAll(".section-opt a")].pop()?.href;
        return (nextUrl != null && nextUrl.includes("?page"))
            ? nextUrl
            : null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".desc")];
    }
}

================================================
FILE: plugin/js/parsers/MidnightramblesParser.js
================================================

"use strict";

parserFactory.register("midnightrambles.in", () => new MidnightramblesParser());

class MidnightramblesParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "span[data-ez-ph-id]");
        [...element.querySelectorAll("span")]
            .filter(s => s.id.startsWith("ezoic-"))
            .forEach(s => s.remove());
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/MimihuiParser.js
================================================

"use strict";

parserFactory.register("mimihui.com", () => new MimihuiParser());

class MimihuiParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector(".chapter-more a").href;

        let tocPage = (await HttpClient.wrapFetch(tocUrl)).responseXML;

        let menu = tocPage.querySelector(".chapter-list");

        return util.hyperlinksToChapterList(menu);

        /* 
        Will need to handle VIP chapters and clean chapter titles. (Remove 免费 and VIP from the end of it. Only ToC is affected by this.)

        We can still get a sneakpeek of the content of VIP chapters even when locked, ~10 lines, so I didn't make them automatically non-includeable. 
        With them being visible clearly in the ToC with a 'VIP' at the end, if user want to remove them. 
        */
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "lock");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".info > h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".info > dl:nth-child(2) > dd:nth-child(2)");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractDescription(dom) {
        return dom.querySelector(".desc").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".info")];
    }
}

================================================
FILE: plugin/js/parsers/MMyWwuxiaWorldParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.mywuxiaworld.com", () => new MMyWwuxiaWorldParser());

class MMyWwuxiaWorldParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let newDom = (await HttpClient.wrapFetch(dom.baseURI + "dir.html")).responseXML;
        return [...newDom.querySelectorAll("div.chapter-list a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.pt-read-cont");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.pt-bookdetail a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.pt-read div").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.pt-bookdetail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.pt-bookdetail > div.flex-item, span.pt-book-intro")];
    }
}

================================================
FILE: plugin/js/parsers/MoonDaisyParser.js
================================================

"use strict";

parserFactory.register("moondaisyscans.biz", () => new MoonDaisyParser());

class MoonDaisyParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.eplister a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        let title = MoonDaisyParser.extractChapterNum(link).trim();
        return ({
            sourceUrl:  link.href,
            title: title
        });
    }

    static extractChapterNum(link) {
        const chapternum = link.querySelector(".chapternum");
        return chapternum == null
            ? "[placeholder]"
            : chapternum.textContent;
    }

    findContent(dom) {
        return dom.querySelector("#readerarea");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        let info = dom.querySelector(".entry-content");
        return info == null
            ? []
            : [info];
    }
}

================================================
FILE: plugin/js/parsers/MoonQuillParser.js
================================================

"use strict";

parserFactory.register("moonquill.com", () => new MoonqQillParser());

class MoonqQillParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div#toc div.card-body div.col-1")]
            .map(d => MoonqQillParser.divToChapter(d));
    }

    static divToChapter(div) {
        let link = div.querySelector("a");
        let title = div.nextElementSibling.querySelector("a").textContent.trim();
        return {
            sourceUrl:  link.href,
            title: link.textContent.trim().replace("#", "") + ": " + title,
            newArc: null
        };
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.card-header-title");
    }

    customRawDomToContentStep(chapter, content) {
        this.uncommentStoryText(content);
    }

    uncommentStoryText(content) {
        let comments = [...content.childNodes].filter(n => n.nodeType === Node.COMMENT_NODE);
        for (let comment of comments) {
            let newDom = util.sanitize("<article>" + comment.data + "</article>");
            let newHtml = newDom.querySelector("article");
            content.appendChild(newHtml);
            break;
        }
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.main-content");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#syn div.card-body")];
    }
}

================================================
FILE: plugin/js/parsers/MottruyenParser.js
================================================

"use strict";

parserFactory.register("mottruyen.com.vn", () => new MottruyenParser());
parserFactory.register("mottruyen.vn", () => new MottruyenParser());

class MottruyenParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let leaves = dom.baseURI.split("/").filter(a => a != "");
        let id = leaves[leaves.length - 1];
        let bookinfo = (await HttpClient.fetchJson("https://api.mottruyen.vn/api/v1/story/"+id)).json;
        let chapter_count = bookinfo.countChapter;
        let slug = bookinfo.slug;
        let chapters = (await HttpClient.fetchJson("https://api.mottruyen.vn/api/v1/story/"+id+"/chapter?size="+chapter_count+"&page=0&sort=asc")).json;
        return chapters.data.map(a => ({
            sourceUrl: "https://mottruyen.com.vn/"+slug+"/"+id+"/chuong/"+a.chapter, 
            title: a.chapterTitle?"Chương "+a.chapter + " :"+ a.chapterTitle:"Chương "+a.chapter,
            isIncludeable: (a.price == 0)
        }));
    }
    
    async loadEpubMetaInfo(dom) {
        let leaves = dom.baseURI.split("/").filter(a => a != "");
        let id = leaves[leaves.length - 1];
        let bookinfo = (await HttpClient.fetchJson("https://api.mottruyen.vn/api/v1/story/"+id)).json;
        this.title = bookinfo.name;
        this.author = bookinfo.author.name;
        this.description = bookinfo.introduce?.trim();
        this.password = bookinfo.password;
        this.img = "https://api.mottruyen.vn/api/v1/storage"+bookinfo.image;
        return;
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractDescription() {
        return this.description;
    }

    findCoverImageUrl() {
        return this.img;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }


    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let options = {
            parser: this
        };
        let json = (await HttpClient.fetchJson(restUrl, options)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let leaves = url.split("/").filter(a => a != "");
        let id = leaves[leaves.length - 3];
        let chapternumber = leaves[leaves.length - 1];
        return "https://api.mottruyen.vn/api/v1/story/"+id+"/chapter/"+chapternumber+"?password="+this.password;
    }
    
    isCustomError(response) {
        if (response?.json?.lock) {
            return true;
        }
        if (response?.json?.statusCode != 200) {
            return true;
        }
        return false;
    }

    setCustomErrorResponse(url, wrapOptions, checkedresponse) {
        if (checkedresponse?.json?.lock) {
            //Is only viewable in the app
            let newresp = {};
            newresp.url = url;
            newresp.wrapOptions = wrapOptions;
            newresp.response = {};
            newresp.response.url = this.PostToUrl(checkedresponse.response.url, checkedresponse);
            newresp.response.status = 999;
            newresp.response.retryDelay = [1];
            newresp.errorMessage = "This Chapter '"+newresp.response.url+"' could not be downloaded\nMessage: "+checkedresponse?.json.content;
            return newresp;
        }
        if (checkedresponse?.json?.statusCode != 200) {
            //to catch an error response
            //not tested
            let newresp = {};
            newresp.url = url;
            newresp.wrapOptions = wrapOptions;
            newresp.response = {};
            newresp.response.url = checkedresponse.response.url;
            newresp.response.status = checkedresponse?.json?.statusCode;
            return newresp;
        }
    }

    PostToUrl(url, checkedresponse) {
        let leaves = url.split("/").filter(a => a != "");
        let id = leaves[leaves.length - 3];
        let chapternumber = leaves[leaves.length - 1];
        return "https://mottruyen.com.vn/"+checkedresponse?.json?.nameIndex+"/"+id+"/chuong/"+chapternumber;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json.chapterTitle?"Chương "+json.chapter + " :"+ json.chapterTitle:"Chương "+json.chapter;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/MtlarchiveParser.js
================================================

"use strict";

parserFactory.register("fictionzone.net", () => new MtlarchiveParser());

// mtlarchive.com and reader-hub.com were previous names of site

class MtlarchiveParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 3000;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = [];

        chapterUrlsUI.showTocProgress(chapters);
        let info = await this.findStoryInfo(dom.baseURI);
        if (0 < info.storyId) {
            for (let page = 1; page <= info.numTocPages; ++page) {
                await this.rateLimitDelay();
                try {
                    let partialList = await this.fetchTocData(info.storyId, page, dom.baseURI);
                    chapterUrlsUI.showTocProgress(partialList);
                    chapters = chapters.concat(partialList);
                } catch (error) {
                    break;
                }
            }
        }
        return chapters;
    }

    toChapter(link) {
        return ({
            title: link.querySelector("span.chapter-title").textContent,
            sourceUrl: link.href
        });
    }

    async findStoryInfo(url) {
        let baseurl = new URL(url);
        let payload = `{"path": "${baseurl.pathname}",` +
            "\"headers\": {\"content-type\":\"application/json\"}, \"method\": \"get\" }";
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },
            credentials: "include",
            body: payload
        };
        let json = (await HttpClient.fetchJson(baseurl.origin + "/api/__api_party/api-v1", options)).json;
        return ({
            storyId: json._data.id,
            numTocPages: Math.ceil(json._data.chapter_count / 100)
        });
        /* old logic
        
        let json = JSON.parse(dom.querySelector("script#__NUXT_DATA__").textContent);
        // exact position of story ID moves, but it's before string with cover image's URL slug
        for(let index = 15; index <= 30; ++index) {
            let examine = json[index];
            if ((typeof examine === "string") && examine.startsWith("novel_covers/")) {
                return json[index - 1];
            }
        }
        return 0;  
        */
    }

    findNumTocPages(dom) {
        let pages = [...dom.querySelectorAll(".pagination span")]
            .map(s => parseInt(s.textContent) || 0);
        return (0 < pages.length)
            ? Math.max(...pages)
            : 0;
    }

    async fetchTocData(storyId, page, url) {
        let baseurl = new URL(url);
        let payload = `{"path": "/chapter/all/${storyId}", "query": {"page":${page}},` +
            "\"headers\": {\"content-type\":\"application/json\"}, \"method\": \"get\" }";
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },
            credentials: "include",
            body: payload
        };
        let json = (await HttpClient.fetchJson(baseurl.origin + "/api/__api_party/api-v1", options)).json;
        return json._data.map(j => this.jsonToChapter(j, url));
    }

    jsonToChapter(json, url) {
        return ({
            sourceUrl: url + "/" + json.slug,
            title: json.title
        });   
    }    

    findContent(dom) {
        return dom.querySelector(".chapter-wrap");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".novel-author .content");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".ad-slot");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#synopsis .content")];
    }
}

================================================
FILE: plugin/js/parsers/MtledNovelsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("mtled-novels.com", () => new MtledNovelsParser());

class MtledNovelsParser extends Parser {
    constructor() {
        super();
    }

    populateUIImpl() {
        document.getElementById("removeOriginalRow").hidden = false;
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.card__body a:not(.list-group-item)")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return dom.querySelector("div.text_content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    customRawDomToContentStep(chapter, content) {
        if (this.userPreferences.removeOriginal.value) {
            util.removeChildElementsMatchingSelector(content, "div[id='raw']");
        } 
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.profile__img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.profile__info")];
    }
}

================================================
FILE: plugin/js/parsers/MtlnationParser.js
================================================

"use strict";

parserFactory.register("mtlnation.com", () => new MtlnationParser());

class MtlnationParser extends MadaraParser {
    constructor() {
        super();
    }

    disabled() {
        return UIText.Warning.parserDisabledNotification;
    }

    findContent(dom) {
        if (dom.querySelector("div.reading-content") === null) {
            let content = dom.querySelector("div[data-position='footer']")?.previousElementSibling;
            if (content != null) {
                content.className = "reading-content";
            }
        }
        return super.findContent(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".code-block, #text-chapter-toolbar, [style='display:none;']");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/MtlnovelsParser.js
================================================

"use strict";
parserFactory.register("mtlnovels.com", () => new MtlnovelsParser());
parserFactory.register("mtlnovel.com", () => new MtlnovelsParser());
parserFactory.registerUrlRule(
    url => (util.extractHostName(url).endsWith(".mtlnovels.com")),
    () => new MtlnovelsParser()
);
parserFactory.registerUrlRule(
    url => (util.extractHostName(url).endsWith(".mtlnovel.com")),
    () => new MtlnovelsParser()
);

class MtlnovelsParser extends Parser {
    constructor() {
        super();
    }

    populateUIImpl() {
        document.getElementById("removeOriginalRow").hidden = false;
    }

    async getChapterUrls(dom) {
        const tocUrl = dom.querySelector("#panelchapterlist > a").href;

        const chapterDom = (await HttpClient.fetchHtml(tocUrl)).responseXML;

        return [...chapterDom.querySelectorAll(".ch-list > p > a")]
            .map(a => ({
                title: a.textContent.trim(),
                sourceUrl: a.href
            }))
            .reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.single-page");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("#author");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        let original = "";
        if (this.userPreferences.removeOriginal.value) {
            original = ", p.cn";
        }
        util.removeChildElementsMatchingSelector(element, ".crumbs, .chapter-nav, .lang-btn, .sharer," +
            " amp-embed, .link-title, ol.link-box, a.view-more, button, span[hidden]" + original);
        for (let e of [...element.querySelectorAll("div")]) {
            e.removeAttribute("[class]");
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#panelnovelinfo div.desc")];
    }
}

================================================
FILE: plugin/js/parsers/MtlreaderParser.js
================================================

"use strict";

parserFactory.register("mtlreader.com", () => new MtlreaderParser());

class MtlreaderParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("table.table-responsive");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.agent-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.text-center").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.container");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#editdescription")];
    }
}

================================================
FILE: plugin/js/parsers/MtnovelParser.js
================================================

"use strict";

parserFactory.register("mtnovel.net", () => new MtnovelParser());

class MtnovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.getChapterUrlsFromMultipleTocPages(dom,
            MtnovelParser.extractPartialChapterList,
            MtnovelParser.getUrlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    static getUrlsOfTocPages(dom) {
        let lastUrl = dom.querySelector("#pagelink a.last").href;
        let index = lastUrl.lastIndexOf("/");
        let maxUrl = parseInt(lastUrl.substring(index + 1));
        let baseUrl = lastUrl.substring(0, index + 1);
        let urls = [];
        for (let i = 2; i <= maxUrl; ++i) {
            urls.push(baseUrl + i);
        }
        return urls;
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("#list-chapterAll dd a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.readcontent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.booktitle");
    }

    removeUnwantedElementsFromContentElement(element) {
        let links = [...element.querySelectorAll("a")]
            .filter(link => link.textContent.includes("Back to top"));
        for (let link of links) {
            link.replaceWith(link.ownerDocument.createElement("br"));
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("#acontent h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.bookcover");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let content = this.findContent(dom);
        let nextUrl = this.findNextPageOfChapterUrl(dom);
        while (nextUrl != null) {
            let newDom = (await HttpClient.wrapFetch(nextUrl)).responseXML;
            let newContent = this.findContent(newDom);
            nextUrl = this.findNextPageOfChapterUrl(newDom);
            util.moveChildElements(newContent, content);
        }
        return dom;
    }

    findNextPageOfChapterUrl(dom) {
        let nextLink = dom.querySelector("#linkNext");
        return ((nextLink !== null) && nextLink.textContent.includes("Next page"))
            ? nextLink.href
            : null;
    }     

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.bookintro")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "img");
    }
}

================================================
FILE: plugin/js/parsers/MuggleNetParser.js
================================================

/*
  Parses files on fanfiction.mugglenet.com
*/
"use strict";

//dead url/ parser
parserFactory.register("fanfiction.mugglenet.com", () => new MuggleNetParser());

class MuggleNetParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let baseUrl = this.getBaseUrl(dom);
        let options = [...dom.querySelectorAll("select[name='chapter'] option")];
        if (options.length === 0) {
            // no list of chapters found, assume it's a single chapter story
            return Promise.resolve(this.singleChapterStory(baseUrl, dom));
        } else {
            return Promise.resolve(options.map(option => this.optionToChapterInfo(baseUrl, option)));
        }
    }

    optionToChapterInfo(baseUrl, optionElement) {
        // constructing the URL is a bit complicated as the value is not final part of URL.
        let chapterId = optionElement.getAttribute("value");
        let searchString = "chapter=";
        let index = baseUrl.indexOf(searchString) + searchString.length;
        let url = baseUrl.slice(0, index) + chapterId;
        return {
            sourceUrl:  url,
            title: optionElement.innerText
        };
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div#story");
    }

    extractTextFromPageTitle(dom, index) {
        let text = "<unknown>";
        let links = [...dom.querySelectorAll("div#pagetitle a")];
        if (index < links.length) {
            text = links[index].textContent.trim();
        }
        return text;
    }

    extractTitleImpl(dom) {
        return this.extractTextFromPageTitle(dom, 0);
    }

    extractAuthor(dom) {
        return this.extractTextFromPageTitle(dom, 1);
    }
}

================================================
FILE: plugin/js/parsers/MvlempyrParser.js
================================================

"use strict";

parserFactory.registerDeadSite("mvlempyr.com", () => new MvlempyrParser());
parserFactory.register("mvlempyr.io", () => new MvlempyrParser());

class MvlempyrParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 1000;
    }

    async getChapterUrls(dom) {
        let imgLink = dom.querySelector("div.novel-image-wrapper img").src;
        let slug = imgLink.split("/").pop().split(".")[0];
        let chapterCount = parseInt(dom.querySelector("div#chapter-count").textContent)?parseInt(dom.querySelector("div#chapter-count").textContent):-1;
        let chapterTitles = [...dom.querySelectorAll("a.chapter-item h3")].map((el) => el.textContent.replace(/^\d+\.\s*/, ""));

        if (chapterCount == -1) {
            let regex = new RegExp("numberOfChapters.*?,");
            let regex2 = new RegExp("[0-9]+");
            let script = [...dom.scripts].map(a => a.outerHTML);
            chapterCount = parseInt(script.filter(a => a.match(regex))?.[0].match(regex)?.[0].match(regex2)?.[0]);
        }
        let chapterList = [];

        for (let i = 1; i <= chapterCount; i++) {
            let link = `https://www.mvlempyr.io/chapter/${slug}-${i}`;
            if (chapterTitles[i-1] == undefined) {
                chapterList.push({
                    sourceUrl: link,
                    title: "[placeholder]",
                });
            }
            else {
                chapterList.push({
                    sourceUrl: link,
                    title: chapterTitles[i-1],
                });
            }
        }
        return chapterList;
    }


    findContent(dom) {
        return (
            dom.querySelector("div#chapter") || dom.querySelector("#chapter-content")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.novel-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.mobileauthorname");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("#span-28-1305853").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-image-wrapper");
    }

    getInformationEpubItemChildNodes(dom) {
        let epubDescription = ([...dom.querySelectorAll("div.synopsis")]);
        return epubDescription.map(e => e.innerHTML.replace(/<br><br>/g, "\n\n").replace(/<br>/g, "\n"));
    }
  
    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.genere-tagslist a")]);
        let regex = new RegExp("^#");
        return tags.map(e => e.textContent.trim().replace(regex, "")).join(", ");
    }
}

================================================
FILE: plugin/js/parsers/MydramanovelParser.js
================================================

"use strict";

parserFactory.register("mydramanovel.com", () => new MydramanovelParser());

class MydramanovelParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("#tdi_48 .td-module-thumb a,#tdi_55 h3.entry-title a")]
            .map(a => this.hyperLinkToChapter(a));
    }

    hyperLinkToChapter(link) {
        return {
            sourceUrl: link.href,
            title: link.getAttribute("title")
        };
    }

    findContent(dom) {
        return dom.querySelector("div.td-post-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.tdb-title-text");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        let span = dom.querySelector("#tdi_48 .td-module-thumb a span[data-img-url]");
        return span.getAttribute("data-img-url") ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.tdb_category_description .tdb-block-inner")];
    }
}

================================================
FILE: plugin/js/parsers/MyxlsParser.js
================================================

"use strict";

parserFactory.register("myxls.net", () => new MyxlsParser());

class MyxlsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let rows = dom.querySelector("div#list dl").children;
        let links = [];
        let count = 0;
        for (let row of rows) {
            let tag = row.tagName.toLowerCase();
            if (tag === "dt") {
                ++count;
            }
            if ((tag === "dd") && (count === 2)) {
                links.push(row.querySelector("a"));
            }
        }
        return links.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".bookname h1")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#fmimg");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#intro")];
    }
}

================================================
FILE: plugin/js/parsers/MznovelsParser.js
================================================

"use strict";

parserFactory.register("mznovels.com", () => new MznovelsParser());

class MznovelsParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let pagination = dom.querySelector(".pagination");
        if (pagination)
        {
            let url = new URL(pagination.querySelector("a").href);
            let maxPage = this.maxTocPage(pagination);
            for (let i = 2; i <= maxPage; i++) {
                url.searchParams.set("page", i);
                urls.push(url.href);
            }
        }
        return urls;
    }

    maxTocPage(pagination) {
        let offsets = [...pagination.querySelectorAll("a")]
            .map(item => new URL(item?.href)?.searchParams?.get("page"))
            .filter(item => item !== null)
            .map(item => parseInt(item));
        return 0 < offsets.length
            ? Math.max(...offsets)
            : 0;
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector(".chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".chapter-content");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        if (!this.userPreferences.removeAuthorNotes.value) {
            let note = webPageDom.querySelector("div.author_note");
            if (note) {
                util.removeChildElementsMatchingSelector(note, ".author_note_avatar > img");
                for (let pre of [...note.querySelectorAll(".note_content")]) {
                    util.convertPreTagToPTags(webPageDom, pre, "\n");
                }
                content.appendChild(note);
            }
        }
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".novel-author a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".novel-image-container");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".novel-summary")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "button");
        return node;
    }
}

================================================
FILE: plugin/js/parsers/NanodesuParser.js
================================================

/*
  parses nanodesu
*/
"use strict";

// nanodesu URLs have hostnames like '*thetranslation.wordpress.com'
parserFactory.registerUrlRule(
    url => util.extractHostName(url).endsWith("thetranslation.wordpress.com"),
    () => new NanodesuParser()
);

class NanodesuParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("ul#nav");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div.page-body");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2.page-title");
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        return util.moveIfParent(link, "p");
    }
}

================================================
FILE: plugin/js/parsers/NanomashinonlineParser.js
================================================

"use strict";
parserFactory.register("nanomashin.online", () => new NanomashinonlineParser());

class NanomashinonlineParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.walkTocPages(dom,
            NanomashinonlineParser.chaptersFromDom,
            NanomashinonlineParser.nextTocPageUrl,
            chapterUrlsUI
        )).reverse();
    }

    static chaptersFromDom(dom) {
        return [...dom.querySelectorAll("h3 a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static nextTocPageUrl(dom) {
        return dom.querySelector("nav button[rel='next']")?.parentNode?.href ?? null;
    }

    findContent(dom) {
        return dom.querySelector("article div.pt-10");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("body img[decoding]")?.src ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.pt-2")];
    }
}

================================================
FILE: plugin/js/parsers/NeobookParser.js
================================================

"use strict";

parserFactory.register("neobook.org", () => new NeobookParser());

class NeobookParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div#book-about-chapters");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-cover-wrapper");
    }

    async fetchChapter(url) {
        let rawHTML = (await HttpClient.fetchHtml(url)).responseXML;
        let json = this.extractJson(rawHTML);
        return this.buildChapter(json, url);
    }

    extractJson(rawHTML) {
        let prefix = "var data = ";
        let script = [...rawHTML.querySelectorAll("script")]
            .filter(s => s.textContent.includes(prefix))
            .map(s => s.textContent)[0];
        return util.locateAndExtractJson(script, prefix);
    }

    buildChapter(json, url) {
        let chapter = json.chapters
            .filter(c => c?.data?.html != null)[0];
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = chapter.data.title;
        newDoc.content.appendChild(title);
        let content = util.sanitize(chapter.data.html);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#book-about-description")];
    }
}

================================================
FILE: plugin/js/parsers/NepustationParser.js
================================================

[Binary file]

================================================
FILE: plugin/js/parsers/NineHeavensParser.js
================================================

"use strict";

parserFactory.register("nineheavens.org", () => new NineHeavensParser());

class NineHeavensParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ol.chapter-group__list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("article.chapter__article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.story__identity-title");
    }


    extractDescription(dom) {
        return dom.querySelector("section.story__summary").textContent.trim();
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.chapter__actions, a.chapter__story-link, em.chapter__author, footer.chapter__footer");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "figure.story__thumbnail");
    }

    async fetchChapter(url) {
        return (await HttpClient.wrapFetch(url)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section.story__summary")];
    }
}

================================================
FILE: plugin/js/parsers/NobadnovelParser.js
================================================

/*
  Parses files on <www.nobadnovel.com>
*/
"use strict";

parserFactory.register("nobadnovel.com", () => new NobadnovelParser());

class NobadnovelParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 500;
    }

    async getChapterUrls(dom) {
        let tocHtml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let table = tocHtml.querySelector("#table");
        return util.hyperlinksToChapterList(table);
    }

    findContent(dom) {
        return dom.querySelector("div.text-base");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("title");
    }

    extractDescription(dom) {
        return dom.querySelector("div.content").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img.object-cover")?.src ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.content")];
    }
}

================================================
FILE: plugin/js/parsers/NoblemtlParser.js
================================================

"use strict";

parserFactory.register("arcanetranslations.com", () => new NoblemtlParser());
//dead url
parserFactory.register("bookalb.com", () => new NoblemtlParser());
parserFactory.register("ckandawrites.online", () => new KnoxtspaceParser());
parserFactory.register("daotranslate.com", () => new NoblemtlParser());
parserFactory.register("daotranslate.us", () => new NoblemtlParser());
//dead url
parserFactory.register("faloomtl.com", () => new NoblemtlParser());
//dead url
parserFactory.register("genesistls.com", () => new NoblemtlParser());
parserFactory.register("hoxionia.com", () => new NoblemtlParser());
parserFactory.register("jobnib.com", () => new NoblemtlParser());
parserFactory.register("moonlightnovel.com", () => new NoblemtlParser());
parserFactory.register("noblemtl.com", () => new NoblemtlParser());
parserFactory.register("novelcranel.org", () => new NoblemtlParser());
//dead url
parserFactory.register("novelsparadise.net", () => new NoblemtlParser());
//dead url
parserFactory.register("readfreebooksonline.org", () => new NoblemtlParser());
//dead url
parserFactory.register("tamagotl.com", () => new NoblemtlParser());
parserFactory.register("taonovel.com", () => new NoblemtlParser());
parserFactory.register("knoxt.space", () => new KnoxtspaceParser());
parserFactory.register("lazygirltranslations.com", () => new LazygirltranslationsParser());
//dead url
parserFactory.register("novelsknight.com", () => new NoblemtlParser());
parserFactory.register("novelsknight.punchmanga.online", () => new NovelsknightlParser());
parserFactory.register("cyborg-tl.com", () => new CyborgTlParser());

parserFactory.register("pandamtl.com", () => new NoblemtlParser());
parserFactory.register("universalnovel.com", () => new NoblemtlParser());
parserFactory.register("whitemoonlightnovels.com", () => new WhitemoonlightnovelsParser());

parserFactory.register("my-novel.online", () => new MyNovelOnlineParser());

parserFactory.registerRule(
    (url, dom) => NoblemtlParser.isNoblemtlTheme(dom) * 0.7,
    () => new NoblemtlParser()
);

class NoblemtlParser extends Parser {
    constructor() {
        super();
    }

    static isNoblemtlTheme(dom) {
        return (dom.querySelector("div.eplister a") != null) &&
            (dom.querySelector(".thumbook, .sertothumb") != null);
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.eplister a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        let titleName = link.querySelector(".epl-title")?.textContent?.trim() ?? "";
        let title = NoblemtlParser.extractChapterNum(link).trim() + " "
            + titleName;
        return ({
            sourceUrl:  link.href,
            title: title
        });
    }

    static extractChapterNum(link) {
        let eplnum = link.querySelector(".epl-num");
        let chapnum = eplnum.querySelector(".chapter_num");
        return chapnum == null
            ? eplnum.textContent
            : chapnum.textContent;
    }

    findContent(dom) {
        return dom.querySelector(".entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        let toRemove = [...element.querySelectorAll("p")]
            .filter(p => p.style.opacity === "0");
        util.removeElements(toRemove);
        util.removeElements(this.findEmptySpanElements(element));
        util.removeChildElementsMatchingSelector(element, "span.modern-footnotes-footnote__note");
        util.removeChildElementsMatchingSelector(element, "span.footnote_tooltip");
        util.removeChildElementsMatchingSelector(element, "div#hpk");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findEmptySpanElements(element) {
        return [...element.querySelectorAll("span")]
            .filter(s => !s.firstChild);
    }

    findChapterTitle(dom, webPage) {
        return webPage.title;
    }

    static buildChapterTitle(dom) {
        let title = "";
        let addText = (selector) => {
            let element = dom.querySelector(selector);
            if (element != null) {
                title += " " +  element.textContent;
            }
        };
        addText("h1.entry-title");
        addText(".cat-series");
        return title;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".thumbook, .sertothumb");
    }

    preprocessRawDom(webPageDom) {
        util.removeChildElementsMatchingSelector(webPageDom, "div.saboxplugin-wrap, div.code-block");
    }

    getInformationEpubItemChildNodes(dom) {
        let info = dom.querySelector("div.synp .entry-content, div.sersys.entry-content");
        return info == null
            ? []
            : [info];
    }
}

class KnoxtspaceParser extends NoblemtlParser {
    constructor() {
        super();
    }

    findChapterTitle(dom) {
        return NoblemtlParser.buildChapterTitle(dom);
    }

    stripAdverts(node) {
        // On Knoxt chapters, first code-block contains chapter text and advert
        for (let block of node.querySelectorAll("div.code-block")) {
            util.removeChildElementsMatchingSelector(
                block,
                "center, div.ad-container"
            );
            util.flattenNode(block);
        }
    }

    preprocessRawDom(webPageDom) {
        this.stripAdverts(webPageDom);
        super.preprocessRawDom(webPageDom);
    }

    cleanInformationNode(node) {
        this.stripAdverts(node);
    }
}

class WhitemoonlightnovelsParser extends NoblemtlParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.eplister a")]
            .map(this.linkToChapter);
    }

    findChapterTitle(dom) {
        return NoblemtlParser.buildChapterTitle(dom);
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, ".code-block");
    }
}

class LazygirltranslationsParser extends KnoxtspaceParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        if (dom.querySelector("div.eplister a"))
        {
            return super.getChapterUrls(dom);
        }
        let menu = dom.querySelector(".page");
        return util.hyperlinksToChapterList(menu);        
    }
}

class MyNovelOnlineParser extends NoblemtlParser {
    constructor() {
        super();
        this.minimumThrottle = 3000;
    }

    findChapterTitle(dom) {
        return dom.querySelector(".epheader .entry-title");
    }

    findContent(dom) {
        let content = dom.querySelector(".epwrapper .epcontent");
        //there are random links embeded everywhere i think it is to boost other sites on google as the other site is "relevant"
        for (let e of content.querySelectorAll("p.chapter a.num-link")) {
            let pnode = dom.createElement("span");
            pnode.textContent = e.innerText;
            e.replaceWith(pnode);
        }
        return content;
    }

    removeUnwantedElementsFromContentElement(content) {
        util.removeElements(content.querySelectorAll("div.post-views, div.chapter-protected-message"));
        super.removeUnwantedElementsFromContentElement(content);
    }
}

class NovelsknightlParser extends NoblemtlParser {
    constructor() {
        super();
        this.minimumThrottle = 3000;
    }

    findContent(dom) {
        return dom.querySelector("[itemprop='text']");
    }
}

class CyborgTlParser extends NoblemtlParser {
    constructor() {
        super();
    }

    customRawDomToContentStep(chapter) {
        let crypt = chapter.rawDom.querySelector("#js-post-content");
        if (crypt) {
            crypt.textContent = crypt.getAttribute("data-obf");
        }
    }
}

================================================
FILE: plugin/js/parsers/Novel543Parser.js
================================================

"use strict";

parserFactory.register("novel543.com", () => new Novel543Parser());

class Novel543Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.baseURI;
        tocUrl += tocUrl.endsWith("/")
            ? "dir"
            : "/dir";
        let nextDom = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        let menu = nextDom.querySelector("div.chaplist ul:nth-of-type(2)");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span.author");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover");
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom, baseUrl) {
        // Extract chapter base from original URL (e.g., "8096_1" from "8096_1.html" or "8096_1_2.html")
        let getChapterBase = (url) => {
            let match = url.match(/\/(\d+_\d+)(?:_\d+)?\.html/);
            return match ? match[1] : null;
        };
        
        let baseChapter = getChapterBase(baseUrl);
        if (!baseChapter) return null;
        
        // Find the last link in foot-nav (next chapter link)
        let nextLink = [...dom.querySelectorAll(".foot-nav a")].pop();
        if (!nextLink) return null;
        
        let nextUrl = nextLink.href;
        // Check if the next URL is a continuation of the same chapter
        // (e.g., 8096_1_2.html is a continuation of 8096_1.html)
        if (nextUrl.includes(`/${baseChapter}_`)) {
            return nextUrl;
        }
        return null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.intro")];
    }
}

================================================
FILE: plugin/js/parsers/NovelAllParser.js
================================================

/*
  Parser for <www.novelall.com>
*/
"use strict";

parserFactory.register("novelall.com", () => new NovelAllParser());

class NovelAllParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menuItems = [...dom.querySelectorAll("ul.detail-chlist a")];
        return Promise.resolve(this.buildChapterList(menuItems));
    }

    buildChapterList(menuItems) {
        return menuItems.reverse().map(
            a => ({sourceUrl: a.href, title: a.getAttribute("title")})
        );
    }
    
    findContent(dom) {
        return dom.querySelector("div.reading-box");
    }

    extractAuthor(dom) {
        let link = dom.querySelector("a[href*='author']");
        return (link == null) ? super.extractAuthor(dom) : link.textContent;
    }

    // title of the story
    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    // individual chapter titles are not inside the content element
    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.manga-detailtop");
    }

    getInformationEpubItemChildNodes(dom) {
        return  [...dom.querySelectorAll("div.manga-detailtop, div.manga-detailmiddle")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script");
    }
}

================================================
FILE: plugin/js/parsers/NovelcoolParser.js
================================================

"use strict";

parserFactory.register("novelcool.com", () => new NovelcoolParser());

class NovelcoolParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".chapter-item-list a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.querySelector("span.chapter-item-headtitle").textContent
        };        
    }

    findContent(dom) {
        return dom.querySelector(".chapter-reading-section-list, .overflow-hidden");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.bookinfo-title");
    }

    extractAuthor(dom) {
        return dom.querySelector(".bookinfo-author a")?.textContent ?? null;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".chapter-end-mark, .chapter-section-report");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".bookinfo-pic");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".bk-summary-txt")];
    }
}

================================================
FILE: plugin/js/parsers/NovelCrushParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelcrush.com", () => new NovelCrushParser());

class NovelCrushParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let toc = dom.querySelector("div.page-content-listing");
        return util.hyperlinksToChapterList(toc).reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.text-left div.reading-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("ol.breadcrumb li.active").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    preprocessRawDom(chapterDom) {
        util.removeChildElementsMatchingSelector(chapterDom, "ins[data-ad-format]");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "div.heateor_sss_sharing_container");
        return node;
    }
}

================================================
FILE: plugin/js/parsers/NovelFeverParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelfever.com", () => new NovelFeverParser());

class NovelFeverParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#list-chapters");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        let div = dom.querySelector("div#chapter-infomation div.text-overflow-1-lines");
        return div !== null ? div.textContent : null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "section#book-infomation");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#about")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "#book-review");
    }    
}

================================================
FILE: plugin/js/parsers/NovelfullParser.js
================================================

"use strict";

parserFactory.register("allnovel.org", () => new NovelfullParser());
parserFactory.register("allnovelbin.net", () => new NovelfullParser());
parserFactory.register("allnovelfull.app", () => new NovelfullParser());
parserFactory.register("allnovelfull.com", () => new NovelfullParser());
//dead url
parserFactory.register("allnovelfull.org", () => new NovelfullParser());
parserFactory.register("allnovelfull.net", () => new NovelfullParser());
parserFactory.register("allnovelnext.com", () => new NovelfullParser());
parserFactory.register("all-novelfull.net", () => new NovelfullParser());
parserFactory.register("boxnovelfull.com", () => new NovelfullParser());
//dead url
parserFactory.register("freenovelsread.com", () => new NovelfullParser());
parserFactory.register("freewn.com", () => new NovelfullParser());
parserFactory.register("novel-bin.com", () => new NovelHyphenBinParser());
parserFactory.register("novel-bin.net", () => new NovelHyphenBinParser());
parserFactory.register("novel-bin.org", () => new NovelHyphenBinParser());
parserFactory.register("novel-next.com", () => new NovelfullParser());
parserFactory.register("novel35.com", () => new Novel35Parser());
parserFactory.register("novelactive.org", () => new NovelfullParser());
parserFactory.register("novelbin.com", () => new NovelbinParser());
parserFactory.register("novelbin.me", () => new NovelfullParser());
parserFactory.register("novelbin.net", () => new NovelfullParser());
parserFactory.register("novelbin.org", () => new NovelfullParser());
parserFactory.register("noveldrama.org", () => new NovelfullParser());
//dead url
parserFactory.register("novelebook.net", () => new NovelfullParser());
parserFactory.register("novelfull.com", () => new NovelfullParser());
parserFactory.register("novelfull.net", () => new NovelfullParser());
parserFactory.register("novelfullbook.com", () => new NovelfullParser());
parserFactory.register("novelfulll.com", () => new NovelfullParser());
//dead url
parserFactory.register("novelhulk.net", () => new NovelfullParser());
parserFactory.register("novelmax.net", () => new NovelfullParser());
parserFactory.register("novelnext.com", () => new NovelfullParser());
parserFactory.register("novelnext.dramanovels.io", () => new NovelfullParser());
parserFactory.register("novelnext.net", () => new NovelfullParser());
parserFactory.register("novelnextz.com", () => new NovelfullParser());
//dead url
parserFactory.register("noveltop1.org", () => new NovelfullParser());
parserFactory.register("noveltrust.net", () => new NovelfullParser());
parserFactory.register("novelusb.com", () => new NovelfullParser());
parserFactory.register("novelusb.net", () => new NovelfullParser());
parserFactory.register("novelxo.net", () => new NovelfullParser());
parserFactory.register("novlove.com", () => new NovelfullParser());
parserFactory.register("readnovelfull.me", () => new NovelfullParser());
//dead url
parserFactory.register("thenovelbin.org", () => new NovelfullParser());
parserFactory.register("topnovelfull.com", () => new NovelfullParser());
parserFactory.register("zinnovel.net", () => new NovelfullParser());

parserFactory.registerManualSelect("NovelNext", () => new NovelfullParser());

class NovelfullParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 1000;
    }

    // This site uses lots of hostname aliases in the chapter URLs
    // and changes them frequently.  Resulting in WtE not picking the
    // correct parser for the chapters
    // See: https://github.com/dteviot/WebToEpub/issues/1345
    async addParsersToPages(pagesToFetch) {
        for (let page of pagesToFetch) {
            page.parser = this;
        }
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    getUrlsOfTocPages(dom) {
        let link = dom.querySelector("li.last a");
        let urls = [];
        if (link != null) {
            let limit = link.getAttribute("data-page");
            if (limit == null)
            {
                let url = new URL(link.href);
                limit = url.searchParams.get("page_num") || null;
            }
            limit = parseInt(limit || "-1") + 1;
            for (let i = 1; i <= limit; ++i) {
                urls.push(NovelfullParser.buildUrlForTocPage(link, i));
            }
        }
        return urls;
    }

    static buildUrlForTocPage(link, i) {
        let hostname = link.hostname;
        if (hostname === "freenovelsread.com")
        {
            link.pathname = link.pathname.split("/")[1] + "/" + i;
        } else if (hostname === "novelfulll.com") {
            link.search = `?page_num=${i}`;
        } else {
            link.search = `?page=${i}&per-page=50`;
        }
        return link.href;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.list-chapter a")]
            .map(link => util.hyperLinkToChapter(link));
    }

    // returns the element holding the story content in a chapter
    findContent(dom) {
        return dom.querySelector("#chr-content")
            || dom.querySelector("#chapter-content");
    }

    // title of the story  (not to be confused with title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    extractAuthor(dom) {
        let items = [...dom.querySelectorAll("ul.info-meta li")]
            .filter(u => u.querySelector("h3")?.textContent === "Author:")
            .map(u => u.querySelector("a")?.textContent);
        return 0 < items.length 
            ? items[0]
            : super.extractAuthor(dom);
    }

    preprocessRawDom(dom) {
        this.tagWatermark(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc-text, div.info")];
    }

    tagWatermark(dom) {
        const watermark = this.findWatermark(dom);
        if (watermark) {
            let paragraphs = [...dom.querySelectorAll("p")]
                .filter(p => p.textContent.includes(watermark));
            for (let p of paragraphs) {
                p.textContent = p.textContent.replace(watermark, "");
                p.appendChild(this.makeSpanWithWatermark(dom, watermark));
            }
        }
    }

    findWatermark(dom) {
        const searchToken = "original11Content.replace(\"";
        const script = [...dom.querySelectorAll("script")]
            .filter(s => s.innerHTML.includes(searchToken))
            .map(s => s.innerHTML)[0];
        if (!script) {
            return null;
        }
        const line = script.substring(script.indexOf(searchToken) + searchToken.length);
        return line.substring(0, line.indexOf("\""));
    }

    makeSpanWithWatermark(dom, watermark) {
        let span = dom.createElement("span");
        span.textContent = watermark;
        span.id = "span";
        span.hidden = true;
        return span;
    }
}

class Novel35Parser extends NovelfullParser {
    constructor() {
        super();
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let paginateUrls = [...dom.querySelectorAll("ul.pagination li a:not([rel])")];
        if (0 < paginateUrls.length) {
            let url = new URL(paginateUrls.pop().href);
            let maxPage = url.searchParams.get("page");
            for (let i = 2; i <= maxPage; ++i) {
                url.searchParams.set("page", i);
                urls.push(url.href);
            }
        }
        return urls;
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.chapter-title").textContent;
    }    
}

class NovelHyphenBinParser extends NovelfullParser {
    constructor() {
        super();
    }

    removeUnwantedElementsFromContentElement(element) {
        let marks = [...element.querySelectorAll(".novel_online, .unlock-buttons")];
        for (let mark of marks) {
            mark.nextSibling.nextSibling.remove();
            mark.remove();
        }
        super.removeUnwantedElementsFromContentElement(element);
    }
}

class NovelbinParser extends NovelfullParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let url = new URL(dom.baseURI);
        let slug = url.pathname.split("/").filter(a => a != "");
        slug = slug[slug.length-1];
        let tocHtml = (await HttpClient.wrapFetch("https://novelbin.com/ajax/chapter-archive?novelId="+slug)).responseXML;
        let chapters = this.extractPartialChapterList(tocHtml);
        return chapters;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".unlock-buttons");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/NovelgoParser.js
================================================

"use strict";

parserFactory.register("novelgo.id", () => new NovelgoParser());

class NovelgoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let path = new URL(dom.baseURI).pathname.split("/").filter(p => p !== "");
        let category = path[path.length - 1];
        let url = "https://novelgo.id/wp-json/noveils/v1/chapters?paged=1&perpage=10000&category=" + category;
        let json = (await HttpClient.fetchJson(url)).json;
        return json.map(this.jsonToChapter);
    }

    jsonToChapter(json) {
        let title = json.post_title;
        let index = title.indexOf("Chapter");
        if (0 < index) {
            title = title.substring(index);
        }
        return {
            sourceUrl: json.permalink,
            title: title.replace("&#8211", "-"),
            newArc: null
        };
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-post-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "ins, div.code-block-label, .code-block");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("#chapter-post-title");
    }

    findCoverImageUrl(dom) {
        let div = dom.querySelector("div.novel-thumbnail");
        return util.extractUrlFromBackgroundImage(div);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#noveils-about-tab .line-height-30 p")];
    }
}

================================================
FILE: plugin/js/parsers/NovelgreatParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelgreat.net", () => new NovelgreatParser());

class NovelgreatParser extends NovelfullParser {
    constructor() {
        super();
    }

    getUrlsOfTocPages(dom) {
        let link = [...dom.querySelectorAll("ul.pagination li:not(.page-nav) a")].pop();
        let urls = [];
        if (link != null) {
            let limit = link.href.split("=")[1];
            limit = parseInt(limit);
            for (let i = 1; i <= limit; ++i) {
                urls.push(NovelfullParser.buildUrlForTocPage(link, i));
            }
        }
        return urls;
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-c");
    }
}

================================================
FILE: plugin/js/parsers/NovelhallParser.js
================================================

"use strict";

parserFactory.register("novelhall.com", () => new NovelhallParser());

class NovelhallParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.book-catalog")]
            .map(c => [...c.querySelectorAll("a")])
            .reduce((a, c) => a.length < c.length ? c : a, [])
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return dom.querySelector("article div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-info h1");
    }

    extractAuthor(dom) {
        let meta = dom.querySelector("meta[property='books:author']");
        if (meta !== null) {
            meta = meta.getAttribute("content");
        }
        return (meta === null) ? super.extractAuthor(dom) : meta;
    }

    findChapterTitle(dom) {
        return dom.querySelector("article div.single-header h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.book-info div.intro")];
    }
}

================================================
FILE: plugin/js/parsers/NovelhiParser.js
================================================

"use strict";

parserFactory.register("novelhi.com", () => new NovelhiParser());

class NovelhiParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("div.bookChapter a.fr");
        let tocDom = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        return [...tocDom.querySelectorAll("div.dirList a")]
            .map(a => NovelhiParser.LinkToChapter(a, dom.baseURI));
    }

    static LinkToChapter(link, baseURI) {
        let onclick = link.getAttribute("onClick").split("'");
        return {
            sourceUrl: baseURI + "/" + onclick[1],
            title: link.querySelector("span").textContent            
        };
    }

    findContent(dom) {
        return dom.querySelector("#readcontent #showReading");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.tit h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("#readcontent .book_title h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.bookCover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.intro_txt")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "a");        
        return node;
    }    
}

================================================
FILE: plugin/js/parsers/NovelholdParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelhold.com", () => new NovelholdParser());

class NovelholdParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div#morelist");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".detail p")
            ?.textContent?.split("：")[1];
        return authorLabel ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".bookimg");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".content")];
    }
}

================================================
FILE: plugin/js/parsers/NovelightParser.js
================================================

"use strict";

parserFactory.register("novelight.net", () => new NovelightParser());

class NovelightParser extends Parser {
    constructor() {
        super();
        this.ChacheChapterTitle = new Map();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let SiteIds = this.getSiteIds(dom);
        let pageCount = 1;
        let Chapterjsons;
        let chapters = [];
        let partialList;
        let header = {"X-Requested-With": "XMLHttpRequest"};  
        let options = {
            headers: header
        };
        let oldChapterjson = "";
        for (let i = 1; i <= pageCount; i++) {
            await this.rateLimitDelay();
            let requrl = "https://novelight.net/book/ajax/chapter-pagination?csrfmiddlewaretoken="+SiteIds.csrf+"&book_id="+SiteIds.book_id+"&page="+i;
            Chapterjsons = (await HttpClient.fetchJson(requrl, options)).json;
            if (oldChapterjson.html == Chapterjsons.html) {
                break;
            }
            oldChapterjson = Chapterjsons;
            pageCount++;
            partialList = this.chaptersFromJson(Chapterjsons, requrl);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters.reverse();
    }

    getSiteIds(dom) {
        let startString = "const CONTENT_TYPE";
        let scriptElement = [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes(startString))[0].textContent;
        let ret = {};
        let regex = new RegExp("const OBJECT_BY_COMMENT = [0-9]+");
        ret.book_id = scriptElement.match(regex)?.[0].slice(26);
        // eslint-disable-next-line
        regex = new RegExp("window\.CSRF_TOKEN = \".*?\"");
        ret.csrf = scriptElement.match(regex)?.[0].slice(21, -1);
        return ret;
    }
    

    chaptersFromJson(json, url) {
        //without this the href links have as baseurl the extension
        let newDoc = Parser.makeEmptyDocForContent(url);
        let content = util.sanitize(json.html);
        util.moveChildElements(content.body, newDoc.content);
        let chapters = [...newDoc.dom.querySelectorAll("a")].map(a => ({
            sourceUrl: a.href, 
            title: a.querySelector(".title").textContent.replaceAll("\n", "").trim(), 
            isIncludeable: a.querySelector(".cost")?.textContent==null?true:false
        })); 
        return chapters;
    }
    

    extractTitleImpl(dom) {
        return dom.querySelector(".header-manga h1");
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll(".tags a")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector(".text-info").textContent.trim();
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".poster img")?.src ?? null;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    async fetchChapter(url) {
        if (this.ChacheChapterTitle.size == 0) {
            let pagesToFetch = [...this.state.webPages.values()].filter(c => c.isIncludeable);
            pagesToFetch.map(a => (this.ChacheChapterTitle.set(a.sourceUrl, a.title)));
        }
        let restUrl = this.toRestUrl(url);
        let header = {"X-Requested-With": "XMLHttpRequest"};  
        let options = {
            headers: header
        };
        let json = (await HttpClient.fetchJson(restUrl, options)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let leaves = url.split("/");
        let chapternumber = leaves[leaves.length - 1];
        return "https://novelight.net/book/ajax/read-chapter/"+chapternumber;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = this.ChacheChapterTitle.get(url);
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.content);
        for (let n of [...content.body.querySelectorAll("."+json.class+" div")]) {
            let br = newDoc.dom.createElement("br");
            newDoc.content.appendChild(n);
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/NovelinguaParser.js
================================================

"use strict";

parserFactory.register("novelingua.com", () => new NovelinguaParser());

class NovelinguaParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".pagelayer-text-holder a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        // More specific selectors are not consistently reliable even though these have more junk than I'd like
        return dom.querySelector(".entry-content") ||
            dom.querySelector("article");
    }

    customRawDomToContentStep(chapter, content) {
        this.cleanup(content);
    }

    cleanInformationNode(node) {
        this.cleanup(node);
    }

    cleanup(content) {
        content.querySelectorAll("*").forEach(element => {
            element.removeAttribute("dir");
            util.replaceSemanticInlineStylesWithTags(element, true);
            if (element.id?.startsWith("docs-internal-guid-")) {
                element.removeAttribute("id");
            }
        });
    }

    // title of the story (not title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector(".pagelayer-heading-holder h2");
    }

    findChapterTitle(dom) {
        let canonical = dom.querySelector("link[rel='canonical']").href.split("/");
        let title = canonical.pop();
        if (title === "") {
            title = canonical.pop();
        }
        title = title.split("-").map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
        return title;
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("img.pagelayer-img");
        return (img === null) ? img : img.src;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll(
            "style, .pagelayer-btn-holder, .pagelayer-share, .pagelayer-image_slider, .pagelayer-embed"));
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".entry-content .pagelayer-text-holder")];
    }
}

================================================
FILE: plugin/js/parsers/NovelmaniaParser.js
================================================

"use strict";

parserFactory.register("novelmania.com.br", () => new NovelmaniaParser());

class NovelmaniaParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("ol.list-inline a")];
        for (let link of links) {
            link.querySelector("small")?.remove();
        }
        return links.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("span.authors");
        author?.querySelector("b")?.remove();
        return author?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "pt";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("div.text")];
    }
}

================================================
FILE: plugin/js/parsers/NovelmaoParser.js
================================================

"use strict";

parserFactory.register("novelmao.com", () => new NovelmaoParser());

class NovelmaoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        util.removeChildElementsMatchingSelector(menu, "span.time");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.single-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        element.querySelector("div.entry-content").removeAttribute("[class]");
        util.removeChildElementsMatchingSelector(element, "div.chapter-nav, " +
            "p.china, div.snpconainer, amp-selector, div#popupreport"
        );
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.info")];
    }
}

================================================
FILE: plugin/js/parsers/NovelmediumParser.js
================================================

"use strict";

parserFactory.register("novelmedium.com", () => new NovelmediumParser());

class NovelmediumParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let url = dom.baseURI;
        if (url.includes("#")) {
            url = url.substring(0, url.indexOf("#"));
        }
        let storyId = this.getStoryId(dom, url);
        return this.fetchToc(storyId, url);
    }

    getStoryId(dom, url)  {
        let script = [...dom.querySelectorAll("script")]
            .filter(s => s.innerText.includes("__NUXT__"))[0];
        let blobs = script.innerText.split("{id:");
        let leaf = url.substring(url.lastIndexOf("/") + 1);
        let blob = blobs.filter(b => b.includes(leaf))[0];
        return blob.split(",")[0];
    }

    async fetchToc(storyId, baseUrl) {
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },            
            credentials: "include",
            body: this.createPayload(storyId)
        };
        let json = (await HttpClient.fetchJson("https://novelmedium.com/api/__api_party/novelmedium-api", options)).json;
        return json._data.map(j => this.jsonToChapter(j, baseUrl));
    }

    createPayload(storyId) {
        let payload = {
            path: "frontend/allchapters/" + storyId,
            headers: { }
        };
        return JSON.stringify(payload);
    }

    jsonToChapter(json, baseUrl) {
        return ({
            sourceUrl:  baseUrl + "/" + json.slug,
            title: json.title
        });
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-container .content");
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.chapter-container .heading h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".novel-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".summary")];
    }
}

================================================
FILE: plugin/js/parsers/NovelNaverParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novel.naver.com", () => new NovelNaverParser());

class NovelNaverImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    //  Ignore address of hyperlink that wraps an image tag
    extractWrappingUrl(element) {
        let tagName = element.tagName.toLowerCase();
        let img = (tagName === "img")
            ? element
            : element.querySelector("img");
        return img.src;
    }
}

class NovelNaverParser extends Parser {
    constructor() {
        super(new NovelNaverImageCollector());
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages = await this.extractTocPageUrls(dom);
        return (await this.getChaptersFromAllTocPages(chapters, 
            this.extractPartialChapterList, urlsOfTocPages, chapterUrlsUI));
    }

    async extractTocPageUrls(dom) {
        let found = new Set();
        let urls = this.extractPartialTocPages(dom, found);
        let nextTocPageUrl = null;
        while ((nextTocPageUrl = dom.querySelector("div.default_paging a.ico_next")?.href) != null) {
            dom = (await HttpClient.wrapFetch(nextTocPageUrl)).responseXML;
            urls = urls.concat(this.extractPartialTocPages(dom, found));
        }
        return urls;
    }

    extractPartialTocPages(dom, found) {
        let urls = [...dom.querySelectorAll("div.default_paging a")]
            .map(l => l.href)
            .filter(u => !found.has(u));
        for (let u of urls) {
            found.add(u);
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector("div.cont_sub > ul.list_type2");
        return [...menu.querySelectorAll("a")]
            .map(a => ({
                sourceUrl:  a.href,
                title: a.querySelector("p.subj").textContent.trim()
            }));
    }

    findContent(dom) {
        return dom.querySelector("div.viewer_container");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.book_title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.section_area_info");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#summaryText")];
    }
}

================================================
FILE: plugin/js/parsers/NovelOnlineFreeParser.js
================================================

/*
  Parser for <http://novelonlinefree.com/>
*/
"use strict";

parserFactory.register("novelonlinefree.com", () => new NovelOnlineFreeParser());
//dead url
parserFactory.register("novelonlinefree.info", () => new NovelOnlineFreeParser());
parserFactory.register("novelonlinefull.com", () => new NovelOnlineFreeParser());
parserFactory.register("wuxiaworld.online", () => new NovelOnlineFreeParser());
//dead url
parserFactory.register("chinesewuxia.world", () => new NovelOnlineFreeParser());
parserFactory.register("bestlightnovel.com", () => new NovelOnlineFreeParser());
//dead url
parserFactory.register("wuxia-world.online", () => new NovelOnlineFreeParser());
parserFactory.register("wuxiaworld.live", () => new NovelOnlineFreeParser());

class NovelOnlineFreeParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menuItems = [...dom.querySelectorAll("div.chapter-list a")];
        return Promise.resolve(this.buildChapterList(menuItems));
    }

    buildChapterList(menuItems) {
        return menuItems.reverse().map(
            a => ({sourceUrl: a.href, title: a.getAttribute("title")})
        );
    }
    
    findContent(dom) {
        let content = dom.querySelector("div.vung_doc")
          || dom.querySelector("div.content-area");
        return content;
    }

    // title of the story
    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let link = dom.querySelector("a[href*='search_author']");
        return (link == null) ? super.extractAuthor(dom) : link.textContent;
    }

    // individual chapter titles are not inside the content element
    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.entry-header");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#noidungm, ul.truyen_info_right")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "span.rate_star, .fb_iframe_widget, div.google, button, script");
    }
}

================================================
FILE: plugin/js/parsers/NovelonomiconParser.js
================================================

"use strict";

parserFactory.register("novelonomicon.com", () => new NovelonomiconParser());

class NovelonomiconParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let lastLink = dom.querySelector(".page-nav a.last")
            || [...dom.querySelectorAll(".page-nav a.page")].slice(-1)[0];
        if (lastLink !== null)
        {
            let max = parseInt(lastLink.textContent);
            let href = lastLink.href;
            let index = href.lastIndexOf("/", href.length - 2);
            href = href.substring(0, index + 1);
            for (let i = 2; i <= max; ++i) {
                urls.push(href + i + "/");
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll(".td-block-span6 h3 a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector(".tdi_48 .wpb_wrapper .tdb_single_content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".td-module-image a");
    }
    
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".td-category-description")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, ".su-spoiler");
        return node;
    }    
}

================================================
FILE: plugin/js/parsers/NovelpassionParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelpassion.com", () => new NovelpassionParser());

class NovelpassionParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li a")]
            .map(this.linkToChapter)
            .filter(s => s !== null)
            .reverse();
    }

    linkToChapter(link) {
        let title = link.querySelector(".sp1");
        return title === null
            ? null
            : ({
                sourceUrl:  link.href,
                title: title.innerText.trim()
            });
    }

    findContent(dom) {
        return dom.querySelector("div#c_ct");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.psn h2");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2.dac").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "i.g_thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.g_txt_over")];
    }
}

================================================
FILE: plugin/js/parsers/NovelplexParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelplex.org", () => new NovelplexParser());

class NovelplexParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".nAP__TOCArea a")]
            .map(a => this.hyperLinkToChapter(a));
    }

    hyperLinkToChapter(link) {
        return ({
            sourceUrl: link.href,
            title: link.querySelector("p").textContent
        });
    }

    findContent(dom) {
        return dom.querySelector(".halChap--kontenInner");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".headerNovel__wrap h2");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".pt_aBody, .pt_aButton");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".halChap h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".headerNovel");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".summary_mobile")];
    }
}

================================================
FILE: plugin/js/parsers/NovelsectParser.js
================================================

"use strict";

parserFactory.register("novelsect.com", () => new NovelsectParser());

class NovelsectParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let menu = dom.querySelector("ul.scrollbar-medium");
        let chapters = util.hyperlinksToChapterList(menu);
        chapterUrlsUI.showTocProgress(chapters);

        let novelSlug = this.getNovelSlug(dom.baseURI);
        let urlsOfTocPages  = await this.getUrlsOfTocPages(novelSlug);
        for (let url of urlsOfTocPages) {
            await this.rateLimitDelay();
            let json = (await HttpClient.fetchJson(url)).json;
            let partialList = this.extractPartialChapterList(novelSlug, json.chapters);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    async getUrlsOfTocPages(novelSlug) {
        let info = await this.getNovelIdAndChapterCount(novelSlug);
        let tocUrls = [];
        let maxPage = Math.ceil(info.chapter_count / 100);
        for (let i = 2; i <= maxPage; ++i) {
            tocUrls.push(`https://novelsect.com/api/fetchchapterlistbyindex?novelId=${info.id}&page=${i}`);
        }
        return tocUrls;
    }

    getNovelSlug(url) {
        let path = url.split("/");
        return path[path.length - 1];
    }

    async getNovelIdAndChapterCount(novelSlug) {
        let body = JSON.stringify({slug: novelSlug});
        let options = this.makeOptions(body);
        let novelRestUrl = "https://novelsect.com/api/fetchsinglenovel";
        return (await HttpClient.fetchJson(novelRestUrl, options)).json;
    }

    extractPartialChapterList(novelSlug, json) {
        return json.map(c => ({
            sourceUrl: `https://novelsect.com/novel/${novelSlug}/${c.slug}`,
            title: c.title 
        }));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.text-2xl");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img")?.src ?? null;
    }

    async fetchChapter(url) {
        let chapterRestUrl = "https://novelsect.com/api/singlechapter";
        let options = this.makeOptions(this.makeJsonBody(url));
        let json = (await HttpClient.fetchJson(chapterRestUrl, options)).json;
        return this.jsonToHtml(json.chapter, url);
    }

    makeOptions(body) {
        return ({
            method: "POST",
            credentials: "include",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },
            body: body
        });
    }

    makeJsonBody(url) {
        let path = url.split("/");
        return JSON.stringify({
            chapterSlug: path[path.length - 1], 
            novelSlug: path[path.length - 2]
        });
    }

    jsonToHtml(json) {
        let newDoc = Parser.makeEmptyDocForContent();
        this.appendElement(newDoc, "h1", json.title);
        let paragraphs = json.content
            .replace(/<p>/g, "").replace(/<\/p>/g, "")
            .split("\n\n")
            .filter(p => !util.isNullOrEmpty(p));
        for (let text of paragraphs) {
            this.appendElement(newDoc, "p", text);
        }
        return newDoc.dom;
    }

    appendElement(newDoc, tag, text) {
        let element = newDoc.dom.createElement(tag);
        element.textContent = text;
        newDoc.content.appendChild(element);
    }

    getInformationEpubItemChildNodes(dom) {
        let synopsis = dom.querySelector(".overflow-y-scroll");
        return synopsis === null
            ? []
            : [synopsis];
    }
}

================================================
FILE: plugin/js/parsers/NovelsemperorParser.js
================================================

"use strict";

parserFactory.register("novelsemperor.com", () => new NovelsemperorParser());
parserFactory.register("novelsemperor.net", () => new NovelsemperorParser());

class NovelsemperorParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.walkTocPages(dom, 
            NovelsemperorParser.chaptersFromDom, 
            NovelsemperorParser.nextTocPageUrl, 
            chapterUrlsUI
        )).reverse();
    }

    static chaptersFromDom(dom) {
        return [...dom.querySelectorAll("#chapters-list a")]
            .map(NovelsemperorParser.hyperlinkToChapter);
    }

    static hyperlinkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.querySelector("span").innerText.trim(),
        };
    }

    static nextTocPageUrl(dom) {
        let pagination = dom.querySelector("ul.pagination");
        if (pagination === null) {
            return null;
        }
        return [...pagination.querySelectorAll("li.pagination-link")]?.pop()
            ?.getAttribute("onclick")
            ?.split("'")?.[1]
            ?.replace("//", "https://");
    }

    findContent(dom) {
        return dom.querySelector("div.chap-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("#description").parentElement];
    }
}

================================================
FILE: plugin/js/parsers/NovelsfullParser.js
================================================

"use strict";

parserFactory.register("novelsfull.com", () => new NovelsfullParser());

class NovelsfullParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let baseUrl = new URL(dom.baseURI);
        let restUrl = this.chaptersRestUrl(baseUrl);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        return this.jsonToChapters(json, baseUrl);
    }

    jsonToChapters(json, baseUrl) {
        let cleartext = this.decrypt(json.data);
        let elements = JSON.parse(this._utf8_decode(cleartext));
        return elements.map((item) => this.itemToChapter(item, baseUrl));
    }

    decrypt(cyphertext) {
        let _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        let d = "", c = 0;
        let n = [];
        for (cyphertext = cyphertext.replace(/[^A-Za-z0-9=+/]/g, ""); c < cyphertext.length; ) {
            n[0] = _keyStr.indexOf(cyphertext.charAt(c++));
            n[1] = _keyStr.indexOf(cyphertext.charAt(c++));
            n[2] = _keyStr.indexOf(cyphertext.charAt(c++));
            n[3] = _keyStr.indexOf(cyphertext.charAt(c++));
            d += String.fromCharCode(n[0] << 2 | n[1] >> 4);
            64 != n[2] && (d += String.fromCharCode((15 & n[1]) << 4 | n[2] >> 2));
            64 != n[3] && (d += String.fromCharCode((3 & n[2]) << 6 | n[3]));
        }
        return d;
    }

    _utf8_decode(text) {
        for (var t = "", a = 0, r = 0; a < text.length; ) {
            r = text.charCodeAt(a);
            if (r < 128) {
                t += String.fromCharCode(r);
                ++a;
            }
            else if (r > 191 && r < 224) {
                t += String.fromCharCode((31 & r) << 6 | 63 & text.charCodeAt(a + 1));
                a += 2;
            }
            else {
                t += String.fromCharCode((15 & r) << 12 | (63 & text.charCodeAt(a + 1)) << 6 | 63 & text.charCodeAt(a + 2));
                a += 3;
            }
        }
        return t;
    }

    chaptersRestUrl(url) {
        let tail = url.pathname.split("/").pop();
        return "https://api.novelsfull.com/api/book/chapter-list/" + tail;
    }

    itemToChapter(item, baseUrl) {
        return ({
            title: item.name,
            sourceUrl: baseUrl.href + "/" + item.slug
        });
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a[itemprop='author']");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "header:nth-of-type(2)");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div[itemprop='description']")];
    }
}

================================================
FILE: plugin/js/parsers/NovelshubParser.js
================================================

"use strict";
parserFactory.register("novelshub.org", () => new NovelshubParser());
class NovelshubParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapterList = dom.querySelector("article section div[role='tabpanel']");
        if (!chapterList) {
            return [];
        }

        // Get the max chapter count from the CSS selector
        let maxChapter = chapterList.querySelectorAll("button.w-full")?.length;
        let baseUrl = dom.baseURI;
        let chapters = [];

        // Generate URLs incrementing the final number from 1 to maxChapters
        for (let i = 1; i <= maxChapter; i++) {
            chapters.push({
                sourceUrl: baseUrl + "/Chapter-" + i,
                title: `Chapter ${i}`
            });
        }

        return chapters;
    }
    findContent(dom) {
        return dom.querySelector("div.p-6");
    }
    extractTitleImpl(dom) {
        return dom.querySelector("h1.text-2xl");
    }
    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.flex:nth-child(3) > div:nth-child(2) > p:nth-child(1)");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }
    extractDescription(dom) {
        var description = dom.querySelector("meta[name='description']")?.getAttribute("content");
        return description.trim();
    }
    findChapterTitle(dom) {
        return dom.querySelector("meta[property='og:title']")?.getAttribute("content");
    }
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article section");
    }
}

================================================
FILE: plugin/js/parsers/NovelsOnlineParser.js
================================================

"use strict";

parserFactory.register("novelsonline.net", () => new NovelsOnlineParser());
parserFactory.register("novelsonline.org", () => new NovelsOnlineParser());

class NovelsOnlineParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".chapter-chs a")]
            .map(link => this.linkToChapter(link));
    }

    linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.textContent,
        });
    }

    findContent(dom) {
        return (
            dom.querySelector("div#contentall")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector(".novel-right .novel-detail-body")];
    }

    extractAuthor(dom) {
        const detailOptionEls = dom.querySelectorAll("div.novel-left > div.novel-details > div.novel-detail-item");
        if (detailOptionEls) {
            for (const el of detailOptionEls) {
                if (el.textContent.includes("Author(s)")) {
                    const author = el.textContent.replace("Author(s)", "").trim();
                    if (author != "" && author != "N/A") {
                        return author;
                    }
                }
            }
        }

        return "<unknown>";
    }
}

================================================
FILE: plugin/js/parsers/NovelsplParser.js
================================================

"use strict";

parserFactory.register("novels.pl", () => new NovelsplParser());

class NovelsplParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let toc = dom.querySelector("tbody#chapters");
        let chapters = util.hyperlinksToChapterList(toc);
        let tocInfo = NovelsplParser.getTocFetchInfo(dom);
        if (tocInfo != null) {
            chapterUrlsUI.showTocProgress(chapters);
            chapters = await NovelsplParser.fetchMultipleToc(chapters, tocInfo, chapterUrlsUI);
        }
        return chapters.reverse();
    }

    static getTocFetchInfo(dom) {
        let script = [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes("function load(page)"))
            .map(s => s.textContent)[0];
        if (script != null) {
            let index = script.indexOf("data:");
            let end = script.indexOf(", page:", index);
            script = script.substring(index, end) 
                .replace("id:", "\"id\":")
                .replace("novel:", "\"novel\":")
                .replace("max:", "\"max\":")
                .replace(/'/g, "\"");
            return util.locateAndExtractJson(script + "}", "data:");
        }
        return null;
    }

    static async fetchMultipleToc(chapters, tocInfo, chapterUrlsUI) {
        let maxPage = Math.ceil(tocInfo.max / 50);
        for (let i = 2; i <= maxPage; ++i) {
            let partialList = await NovelsplParser.fetchTocData(i, tocInfo);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }    

    static async fetchTocData(page, tocInfo) {
        let formData = new FormData();
        formData.append("id", tocInfo.id);
        formData.append("novel", tocInfo.novel);
        formData.append("max", tocInfo.max);
        formData.append("page", page);

        let fetchUrl = "https://www.novels.pl/ajax/ajaxGetChapters.php";
        let options = {
            method: "POST",
            credentials: "include",
            body: formData
        };
        let xhr = await HttpClient.wrapFetch(fetchUrl, {fetchOptions: options});
        return util.hyperlinksToChapterList(xhr.responseXML);
    }

    findContent(dom) {
        return dom.querySelector("div.article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h4[itemprop='name>']");
    }

    removeUnwantedElementsFromContentElement(element) {
        for (let p of [...element.querySelectorAll("p")]) {
            let c = p.textContent;
            if ((c === "This chapter is updated by Novels.pl") || 
                (c === "Liked it? Take a second to support Novels on Patreon!")) {
                p.remove();
            }
        }
        util.removeChildElementsMatchingSelector(element, "ul.pager");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.imageCover");
    }

    preprocessRawDom(chapterDom) {
        util.removeChildElementsMatchingSelector(chapterDom, "a[href='https://www.patreon.com/novelspl']");
    }

    getInformationEpubItemChildNodes(dom) {
        let description = NovelsplParser.getDescriptionMarker(dom);
        return description === null ? [] : [description];
    }

    static getDescriptionMarker(dom) {
        let marker = dom.querySelector("p[itemprop='description']");
        return marker === null ? null : marker.parentElement;
    }
}

================================================
FILE: plugin/js/parsers/NovelSpreadParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelspread.com", () => new NovelSpreadParser());
//dead url
parserFactory.register("m.novelspread.com", () => new MNovelSpreadParser());

class NovelSpreadParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.volumeBox a")]
            .map(a => util.hyperLinkToChapter(a));
        for (let i = 0; i < chapters.length; ++i) {
            let chapter = chapters[i];
            chapter.title = `${i + 1}. ${chapter.title}`;
        }
        return chapters;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.title.split("-")[0];
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.main-left div.person h4");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novelimg");
    }

    async fetchChapter(url) {
        let restUrl = NovelSpreadParser.extractRestUrl(url);
        let data = (await HttpClient.fetchJson(restUrl)).json.data;
        return NovelSpreadParser.buildChapter(data);
    }

    static extractRestUrl(url) {
        // assumes url is like http://hostname/chapter/{title}/c-{chapterNum}-chapterTitle
        let path = new URL(url).pathname.split("/");
        let last = path.length - 1;
        let title = path[last - 1];
        let chapterNum = path[last].split("-")[1];
        return `https://api.novelspread.com/api/novel/${title}/chapter/${chapterNum}/content`;
    }

    static buildChapter(json) {
        let base = "https://www.novelspread.com" + json.path;
        let newDoc = Parser.makeEmptyDocForContent(base);
        let title = newDoc.dom.createElement("h1");
        title.textContent = `${json.chapter_number}. ${json.chapter_title}`;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.chapter_content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.info, div.syn")];
    }
}

class MNovelSpreadParser extends NovelSpreadParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("a")]
            .filter(a => a.href.includes("/chapter/"))
            .map(a => util.hyperLinkToChapter(a));
        return chapters;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.synopsis div")];
    }
}

================================================
FILE: plugin/js/parsers/NovelsquareParser.js
================================================

"use strict";

parserFactory.register("novelsquare.blog", () => new NovelsquareParser());

class NovelsquareParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        if (!dom.baseURI.match(new RegExp("/chapters$"))) {
            dom = (await HttpClient.wrapFetch(dom.baseURI + "/chapters")).responseXML;
        }
        let baseUrl = dom.baseURI;
        let nextTocIndex = 1;
        let maxToCnumber = [...dom.querySelectorAll("div.pagenav .page-link")];
        maxToCnumber = maxToCnumber.concat(1);
        let getMax = (a, b) => Math.max(parseInt(a)?parseInt(a):0, parseInt(b)?parseInt(b):0);
        maxToCnumber = maxToCnumber.map(a => a.textContent).reduce(getMax);
        let nextTocPageUrl = function(_dom, chapters, lastFetch) {
            return ((nextTocIndex <= maxToCnumber) && (0 < lastFetch.length))
                ? `${baseUrl}?page=${++nextTocIndex}`
                : null;
        };

        return (await this.walkTocPages(dom,
            NovelsquareParser.getChapterUrlsFromTocPage,
            nextTocPageUrl,
            chapterUrlsUI
        ));
    }

    static getChapterUrlsFromTocPage(dom) {
        let menu = dom.querySelector("div#chpagedlist .chapter-list");
        return (menu === null)
            ? []
            :  util.hyperlinksToChapterList(menu);
    }
    
    async loadEpubMetaInfo(dom) {
        if (dom.baseURI.match(new RegExp("/chapters$"))) {
            dom = (await HttpClient.wrapFetch(dom.baseURI.slice(0, dom.baseURI.length - 9))).responseXML;
        }
        this.dom = dom;
        return;
    }

    extractTitleImpl() {
        return this.dom.querySelector("h1 .novel-title");
    }

    extractAuthor() {
        let authorLabel = this.dom.querySelector("div.author a > span");
        return authorLabel?.textContent ?? super.extractAuthor(this.dom);
    }

    extractSubject() {
        let tags = ([...this.dom.querySelectorAll("div.categories a")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription() {
        return this.dom.querySelector("div.m-desc .inner").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-title");
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".box-notification");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl() {
        let coverImage = this.dom.querySelector(".cover");
        return coverImage === null
            ? null
            : coverImage.querySelector("img").src;
    }
}

================================================
FILE: plugin/js/parsers/NovelsRockParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("novelsrock.com", () => new NovelsRockParser());

class NovelsRockParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("li.wp-manga-chapter a")]
            .filter(a => (a.querySelector("img") === null))
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters.reverse());
    }

    findContent(dom) {
        let content = dom.querySelector("div.read-container");
        return (content === null)
            ? dom.querySelector("div.reading-content") 
            : content;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1#chapter-heading");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content")];
    }
}

================================================
FILE: plugin/js/parsers/NoveltoonParser.js
================================================

"use strict";

parserFactory.register("noveltoon.mobi", () => new NoveltoonParser());

class NoveltoonParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("a.episodes-info-a-item")]
            .map(a => NoveltoonParser.ToChapterInfo(a));
    }

    static ToChapterInfo(link) {
        let title = link.querySelector(".episode-item-num").textContent.trim()
            + " " + link.querySelector(".episode-item-title").textContent.trim();
        return {
            sourceUrl: link.href,
            title: title,
        };
    }

    findContent(dom) {
        return dom.querySelector("div.watch-chapter-detail");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.detail-title");
    }

    extractAuthor(dom) {
        return dom.querySelector("p.detail-author")?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("p.watch-chapter-title")?.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.detail-top-right");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.detail-desc")];
    }
}

================================================
FILE: plugin/js/parsers/NoveltranslatedbycParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("noveltranslatedbyc.blogspot.com", () => new NoveltranslatedbycParser());

class NoveltranslatedbycParser extends BlogspotParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("article button")]
            .map(NoveltranslatedbycParser.buttonToChapter);
    }

    static buttonToChapter(button) {
        let onClick = button.getAttribute("onclick");
        let start = onClick.indexOf("https");
        let end = onClick.lastIndexOf("'");
        return {
            title: button.textContent.trim(),
            sourceUrl:  onClick.substring(start, end),
        };
    }

    findContent(dom) {
        return dom.querySelector("article center");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "button");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }
}

================================================
FILE: plugin/js/parsers/NovelUniverseParser.js
================================================

/*
  parses <www.noveluniverse.com>
*/
"use strict";

//dead url/ parser
parserFactory.register("noveluniverse.com", () => new NovelUniverseParser());

class NovelUniverseParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        return NovelUniverseParser.fetchRestOfToc(dom, []);
    }

    static fetchRestOfToc(dom, chapterList) {
        let nextPage = NovelUniverseParser.urlOfNextToC(dom);
        let newChapters = NovelUniverseParser.extractPartialChapterList(dom);
        chapterList = chapterList.concat(newChapters);
        if (nextPage.length == 0) {
            return Promise.resolve(chapterList);
        }
        return HttpClient.wrapFetch(nextPage[0].href).then(function(xhr) {
            return NovelUniverseParser.fetchRestOfToc(xhr.responseXML, chapterList);
        });
    }
    
    static urlOfNextToC(dom) {
        return [...dom.querySelectorAll("div.allPagesStyle a")]
            .filter(link => link.textContent === "Next");
    }
    
    static extractPartialChapterList(dom) {
        let list = dom.querySelector("ul#chapters");
        return util.hyperlinksToChapterList(list);
    }

    findContent(dom) {
        return dom.querySelector("div.top_loc");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.info h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        let review = element.querySelector("div.star-review");
        if (review != null) {
            review.parentElement.remove();
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.img");
    }
}

================================================
FILE: plugin/js/parsers/NovelUpdatesOnlineParser.js
================================================

"use strict";

//dead url
parserFactory.register("novelupdates.online", () => new NovelUpdatesOnlineParser());
parserFactory.register("boxnovel.net", () => new NovelUpdatesOnlineParser());

class NovelUpdatesOnlineParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let fetchedUrls = new Set();
        fetchedUrls.add(dom.baseURI + "/1#chapter-section");
        let chapters = NovelUpdatesOnlineParser.extractPartialChapterList(dom);
        chapterUrlsUI.showTocProgress(chapters);
        let url = NovelUpdatesOnlineParser.nextTocUrl(dom, fetchedUrls);
        while (url != null) {
            let newDom = (await HttpClient.wrapFetch(url)).responseXML;
            let partialList = NovelUpdatesOnlineParser.extractPartialChapterList(newDom);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
            url = NovelUpdatesOnlineParser.nextTocUrl(newDom, fetchedUrls);
        }
        return chapters.reverse();
    }

    static nextTocUrl(dom, fetchedUrls) {
        let urls = [...dom.querySelectorAll("a#navigation-ajax")]
            .map(a => a.href)
            .filter(u => !fetchedUrls.has(u));
        if (0 < urls.length) {
            fetchedUrls.add(urls[0]);
            return urls[0];
        }
        return null;
    }

    static extractPartialChapterList(dom) {
        let menu = dom.querySelector("#chapter-section ul");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.reading-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content")];
    }
}

================================================
FILE: plugin/js/parsers/NovelUpdatesParser.js
================================================

/*
  Template to use to create a new parser
*/
"use strict";

parserFactory.register("novelupdates.com", () => new NovelUpdatesParser());

class NovelUpdatesParser extends Parser {
    constructor() {
        super();
    }

    // returns promise with the URLs of the chapters to fetch
    // promise is used because may need to fetch the list of URLs from internet
    getChapterUrls(dom) {
        return NovelUpdatesParser.fetchChapterUrls(dom).then(function(links) {
            let chapters = links.map(l => util.hyperLinkToChapter(l));
            return Promise.resolve(chapters.reverse());
        });
    }

    static fetchChapterUrls(dom) {
        let extraPagesWithToc = NovelUpdatesParser.findPagesWithToC(dom);
        return Promise.all(
            extraPagesWithToc.map(url => NovelUpdatesParser.fetchChapterListFromPage(url))
        ).then(function(chapterLists) {
            return chapterLists.reduce(function(prev, current) {
                return prev.concat(current);
            }, NovelUpdatesParser.chapterLinksFromDom(dom));
        });
    }

    static fetchChapterListFromPage(url) {
        return HttpClient.wrapFetch(url).then(function(xhr) {
            return Promise.resolve(NovelUpdatesParser.chapterLinksFromDom(xhr.responseXML));
        });
    }

    static chapterLinksFromDom(dom) {
        return [...dom.querySelectorAll("table#myTable tbody tr")]
            .map(NovelUpdatesParser.chapterLinksFromRow)
            .filter(l => l !== null);
    }

    static chapterLinksFromRow(row) {
        let links = [...row.querySelectorAll("a")];
        return (0 < links.length) ? links[links.length - 1] : null;
    }
    
    static findPagesWithToC(dom) {
        let urls = [];
        let div = dom.querySelector("div.digg_pagination");
        if (div !== null) {
            let maxPage = NovelUpdatesParser.getPageValueOfLastTocPage(div);
            for (let i = 2; i <= maxPage; ++i) {
                urls.push(dom.baseURI + "?pg=" + i);
            }
        }
        return urls;
    }

    static getPageValueOfLastTocPage(div) {
        return [...div.querySelectorAll("a")].reduce(function(prev, curr) {
            let t = NovelUpdatesParser.getPageSearchParameter(curr);
            return (t > prev) ? t : prev;
        }, -1);
    }

    static getPageSearchParameter(link) {
        let query = link.search;
        if (query.startsWith("?pg=")) {
            return parseInt(query.substring(4));
        }
    } 

    // returns the element holding the story content in a chapter
    findContent(dom) {
        return dom.body;
    }

    // title of the story
    extractTitleImpl(dom) {
        return dom.querySelector("div.seriestitlenu");
    }

    // author of the story
    extractAuthor(dom) {
        let author = dom.querySelector("div#showauthors a");
        return (author !== null) ? author.textContent : super.extractAuthor(dom);
    }
}

================================================
FILE: plugin/js/parsers/NovelversetranslationsParser.js
================================================

"use strict";

parserFactory.register("novelversetranslations.com", () => new NovelversetranslationsParser());

class NovelversetranslationsParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector(".lcp_catlist");
        return util.hyperlinksToChapterList(menu);
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let paginateUrls = [...dom.querySelectorAll("ul.lcp_paginator a:not(.lcp_nextlink)")]
            .map(a => a.href);
        if (0 < paginateUrls.length) {
            let url = new URL(paginateUrls.pop());
            let maxPage = this.maxPageId(url);
            for (let i = 2; i <= maxPage; ++i) {
                url.searchParams.set("lcp_page0", i);
                urls.push(url.href);
            }
        }
        return urls;
    }

    maxPageId(url) {
        let pageNum = new URL(url).searchParams.get("lcp_page0");
        return parseInt(pageNum);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.page-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".nnl_container");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".post-media");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".post-content p")];
    }
}

================================================
FILE: plugin/js/parsers/NovicetranslationsParser.js
================================================

"use strict";
parserFactory.register("novicetranslations.com", () => new NovicetranslationsParser());
class NovicetranslationsParser extends WordpressBaseParser {
    constructor() {
        super();
    }
    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.entry");
        return util.hyperlinksToChapterList(menu);
    }

    findCoverImageUrl(dom) { 
        return util.getFirstImgSrc(dom, "div.wp-block-image");
    }
}

================================================
FILE: plugin/js/parsers/NrvnqsrParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("forums.nrvnqsr.com", () => new NrvnqsrParser());

class NrvnqsrParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.postlist");
        return Promise.resolve(util.hyperlinksToChapterList(menu));        
    }

    findContent(dom) {
        let postId = util.getParamFromUrl(dom.baseURI, "p");
        let selector = (postId === null) ? "div.postbody div.content" : "div#post_message_" + postId;
        return dom.querySelector(selector);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("span.threadtitle");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.userinfo a.username");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }
}

================================================
FILE: plugin/js/parsers/NtruyenParser.js
================================================

"use strict";

parserFactory.register("ntruyen.vn", () => new NtruyenParser());

class NtruyenParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = this.extractPartialChapterList(dom);
        chapterUrlsUI.showTocProgress(chapters);

        let numPages = this.getNumOfTocPages(dom);
        let storyId = this.getStoryId(dom);
        for (let i = 2; i <= numPages; ++i) {
            let formData = this.createFormData(storyId, i);
            let tocPage = await (this.fetchToc(formData));
            let partialList = this.extractPartialChapterList(tocPage);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    getNumOfTocPages(dom) {
        let val = dom.querySelector(".goto button")?.getAttribute("data-total");
        return val != null
            ? parseInt(val)
            : 1;
    }

    getStoryId(dom) {
        return dom.baseURI.split("-").pop().split(".")[0];
    }

    async fetchToc(formData) {
        let options = {
            method: "POST",
            credentials: "include",
            body: formData
        };
        let json = (await HttpClient.fetchJson("https://ntruyen.vn//ajax/load_chapter", options)).json;
        return util.sanitize(json.chapters);
    }

    createFormData(storyId, page) {
        let formData = new FormData();
        formData.append("story_id", storyId);
        formData.append("page", page);
        return formData;
    }

    findContent(dom) {
        return dom.querySelector("#chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".story-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".story-title a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-infos h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".description")];
    }
}

================================================
FILE: plugin/js/parsers/NyahFanfictionParser.js
================================================

"use strict";

parserFactory.register("fanfiction.com.br", () => new NyahFanfictionParser());

class NyahFanfictionParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.container_chapter_list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.historia");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.tooltip_userinfo");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#left_part");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.justify")];
    }
}

================================================
FILE: plugin/js/parsers/NyantlParser.js
================================================

"use strict";

parserFactory.register("nyantl.wordpress.com", () => new NyantlParser());

class NyantlParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.wp-block-post-title");
    }
}

================================================
FILE: plugin/js/parsers/OctopiiParser.js
================================================

"use strict";

parserFactory.register("octopii.co", () => new OctopiiParser());

class OctopiiParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("main h3");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".page-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.description")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, ".btn-show-more");
        return node;
    }
}

================================================
FILE: plugin/js/parsers/OldranobelibParser.js
================================================

"use strict";

parserFactory.register("old.ranobelib.me", () => new OldranobelibParser());
parserFactory.register("ranobelib.me", () => new OldranobelibParser());

class OldranobelibParser extends Parser {
    constructor() {
        super();
        this.homedom = "";
    }

    async getChapterUrls(dom) {
        if (dom.baseURI.includes("https://ranobelib.me/ru/book/")) {
            dom = (await HttpClient.wrapFetch(dom.baseURI.replace("https://ranobelib.me/ru/book/", "https://old.ranobelib.me/old/manga/"))).responseXML;
        }
        let base = this.makeChapterBaseUrl(dom);
        let json = this.getJsonWithChapters(dom);
        return json.map(j => this.jsonToChapters(j, base));
    }
    
    async loadEpubMetaInfo(dom) {
        if (dom.baseURI.includes("https://ranobelib.me/ru/book/")) {
            dom = (await HttpClient.wrapFetch(dom.baseURI.replace("https://ranobelib.me/ru/book/", "https://old.ranobelib.me/old/manga/"))).responseXML;
        }
        this.homedom = dom;
        return;
    }

    getJsonWithChapters(dom) {
        let startString = "window.__CONTENT__ = ";
        let scriptElement = [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes(startString))[0];
        return util.locateAndExtractJson(scriptElement.textContent, startString);
    }

    makeChapterBaseUrl(dom) {
        let base = new URL(dom.baseURI);
        let tip = base.pathname.split("/").pop();
        return `https://old.ranobelib.me/old/${tip}/read/`;
    }

    jsonToChapters(json, base) {
        let name = json.name;
        if (!util.isNullOrEmpty(name)) {
            name = " - " + name;
        }
        return ({
            sourceUrl: `${base}v${json.volume}/c${json.number}`,
            title: `Том ${json.volume} Глава ${json.number}${name}`
        });
    }

    findContent(dom) {
        return dom.querySelector(".reader-container");
    }

    extractTitleImpl() {
        return this.homedom.querySelector(".media-name__main");
    }

    extractAuthor() {
        let authorLabel = this.homedom.querySelector(".media-sidebar .media-info-list__item span");
        return authorLabel?.textContent ?? super.extractAuthor(this.homedom);
    }

    extractLanguage() {
        return this.homedom.querySelector("html").getAttribute("lang");
    }

    findChapterTitle(dom) {
        return dom.querySelector("[data-media-down].reader-header-action__title");
    }

    findCoverImageUrl() {
        return util.getFirstImgSrc(this.homedom, ".media-cover");
    }
}

================================================
FILE: plugin/js/parsers/OnlinenovelbookParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("onlinenovelbook.com", () => new OnlinenovelbookParser());

class OnlinenovelbookParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        let paginationUrl = OnlinenovelbookParser.getLastPaginationUrl(dom);
        if (paginationUrl === null) {
            return super.getChapterUrls(dom);
        }
        return this.getChapterUrlsFromMultipleTocPages(dom,
            OnlinenovelbookParser.extractPartialChapterList,
            OnlinenovelbookParser.getUrlsOfTocPages,
            chapterUrlsUI
        ).then(c => c.reverse());
    }

    static getUrlsOfTocPages(dom) {
        let urls = [];
        let paginationUrl = OnlinenovelbookParser.getLastPaginationUrl(dom);
        let maxPage = parseInt(util.extractSubstring(paginationUrl, "/page/", "/"));
        let index = paginationUrl.indexOf("/page/") + 6;
        let prefix = paginationUrl.substring(0, index);
        for (let i = 2; i <= maxPage; ++i) {
            urls.push(prefix + i +"/");
        }
        return urls;
    }

    static getLastPaginationUrl(dom) {
        let urls = [...dom.querySelectorAll("div.ast-pagination a:not(.next)")];
        return (0 === urls.length) ? null : urls.pop().href;
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("h2.entry-title a")]
            .map(a => util.hyperLinkToChapter(a));
    }
}

================================================
FILE: plugin/js/parsers/OntimestoryParser.js
================================================

"use strict";

parserFactory.register("ontimestory.eu", () => new OntimestoryParser());

class OntimestoryParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("article p a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.post-content, div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.page-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.post-title, .entry-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "article");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("article p")]
            .filter(p => p.querySelector("a") === null);
    }
}

================================================
FILE: plugin/js/parsers/OssantlParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("ossantl.com", () => new OssantlParser());

class OssantlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.eplister a")]
            .map(a => this.linkToChapter(a));
    }

    linkToChapter(link) {
        let title = this.concatTextContent(link, ".epl-num, .epl-title");
        return {
            sourceUrl:  link.href,
            title: title,
        };
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    findChapterTitle(dom) {
        return this.concatTextContent(dom, "h1.entry-title, div.cat-series");
    }

    concatTextContent(element, selector) {
        return [...element.querySelectorAll(selector)]
            .map(e => e.textContent.trim())
            .join(" ");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.thumb");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.entry-content")];
    }
}

================================================
FILE: plugin/js/parsers/PandaNovelParser.js
================================================

"use strict";

parserFactory.register("panda-novel.com", () => new PandaNovelParser());
parserFactory.register("pandasnovel.com", () => new PandaNovelParser());
parserFactory.register("www.lightsnovel.com", () => new PandaNovelParser());

class PandaNovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = [];
        let urlsOfTocPages = PandaNovelParser.getUrlsOfTocPages(dom);
        let baseUrl = new URL(dom.baseURI).origin;
        for (let url of urlsOfTocPages) {
            await this.rateLimitDelay();
            let jsonContent = (await HttpClient.fetchJson(url)).json;
            let partialList = PandaNovelParser.extractPartialChapterList(jsonContent.data.list, baseUrl);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    static getUrlsOfTocPages(dom) {
        let pageIds = [...dom.querySelectorAll("ul.pagination li a")]
            .filter(a => a.text)
            .map(a => parseInt(a.text.trim()));
        pageIds.concat(1);
        let maxPage = Math.max(...pageIds);
        let baseUrl = new URL(dom.baseURI).origin;
        let bookId = parseInt(dom.baseURI.split("-").pop());
        let urls = [];
        for (let i = 1; i <= maxPage; ++i) {
            urls.push(baseUrl + "/api/book/chapters/" + bookId + "/" + i);
        }
        return urls;
    }

    static extractPartialChapterList(jsonContent, baseUrl) {
        return jsonContent.map(data => ({
            sourceUrl: baseUrl + data.chapterUrl,
            title: data.name.trim()
        }));
    }

    findContent(dom) {
        return dom.querySelector("#novelArticle2");
    }

    customRawDomToContentStep(webPage, content) {
        let html = this.getRealContent(webPage, content);
        html = html.replaceAll(/<br><br>|<\/p><p>/g, "</p>\n<p>").replaceAll(/(?<!\n)<p>/g, "\n<p>");
        util.parseHtmlAndInsertIntoContent(html, content);
        util.removeChildElementsMatchingSelector(content, "ins");
    }

    getRealContent(webPage, content) {
        let startString = "_pageParameter['contents'] =";
        let scriptElement = [...webPage.rawDom.querySelectorAll("script")]
            .map(s => s.textContent.trim())
            .filter(s => s.includes(startString));
        if (0 === scriptElement.length) {
            return "\n<p>" + content.innerHTML + "</p>";
        }
        let temp = scriptElement[0];
        let start = temp.indexOf("\"");
        let end = temp.lastIndexOf("\"");
        temp = this.addMissingPTag(temp.substring(start + 1, end));
        temp = "{\"a\": \"" +  temp + "\"}";
        let temp2 = JSON.parse(temp);
        return temp2.a;
    }

    addMissingPTag(html) {
        let addStartTag = (s) => s.trim().startsWith("<p>")
            ? s
            : "<p>" + s;
        let paragraphs = html.split("<\\/p>")
            .map(addStartTag);
        return paragraphs.join("<\\/p>");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-desc h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".novel-content h2");
    }

    extractAuthor(dom) {
        //Note: In "a[href*='/author']" forward slash is required
        let authorLabel = [...dom.querySelectorAll(".novel-desc a[href*='/author']")].map(x => x.textContent.trim());
        return (authorLabel.length === 0) ? super.extractAuthor(dom) : authorLabel.join(", ");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".novel-ins, sub");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".novel-cover [style*=background-image]").dataset.src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector(".details-section dd")];
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll(".details-tags li")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }
}

================================================
FILE: plugin/js/parsers/PatreonParser.js
================================================

"use strict";

parserFactory.register("patreon.com", () => new PatreonParser());

class PatreonParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        if (this.isCollectionList(dom)) {
            return this.getCollectionLinks(dom);
        }
        let cards = [...dom.querySelectorAll("div[data-tag='post-card']")];
        return cards
            .filter(c => this.hasAccessableContent(c))
            .map(s => this.cardToChapter(s)).reverse();
    }

    getCollectionLinks(dom) {
        let getTitle = (e) => {
            return [...e.querySelectorAll("span.cm-ugDCiy")]
                .map(s => s.textContent.trim())
                .join(" ");
        };

        let links = [...dom.querySelectorAll("a.cm-XHOpxu")];
        return links.map(link => ({
            sourceUrl: link.href,
            title: getTitle(link),
        }));
    }

    cardToChapter(card) {
        let title = card.querySelector("span[data-tag='post-title']").textContent;
        let link = this.getUrlOfContent(card);
        return ({
            title: title.trim(),
            sourceUrl:  link.href
        });
    }

    hasAccessableContent(card) {
        let link = this.getUrlOfContent(card);
        return !util.isNullOrEmpty(link?.getAttribute("href"));
    }
 
    getUrlOfContent(card) {
        return card.querySelector("a[data-tag='post-published-at']");
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    async fetchChapter(url) {
        let xhr = await HttpClient.wrapFetch(url);
        let script = xhr.responseXML.querySelector("script#__NEXT_DATA__").textContent;
        let json = JSON.parse(script);
        let envelope = json.props.pageProps.bootstrapEnvelope;
        let bootstrap = envelope.bootstrap || envelope.pageBootstrap;
        return this.jsonToHtml(bootstrap.post.data.attributes, url);
    }

    jsonToHtml(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let header = newDoc.dom.createElement("h1");
        header.textContent = json.title;
        newDoc.content.appendChild(header);
        if (json.image) {
            let img = new Image();
            img.src = json.image.url;
            newDoc.content.append(img);
        }
        let content =  "<div>" + json.content + "</div>";
        content = util.sanitize(content)
            .querySelector("div");
        newDoc.content.append(content);
        return newDoc.dom;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1").textContent + " Patreon"  ;
    }

    extractAuthor(dom) {
        if (this.isCollectionList(dom)) {
            return this.extractCollectionAuthor(dom);
        }
        let authorLabel = dom.querySelector("h1");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    extractCollectionAuthor(dom) {
        let title = dom.querySelector("h1");
        let parent = title.parentNode;
        while (parent.querySelector("a") == null) {
            parent = parent.parentNode;
        }
        return parent.querySelector("a")?.textContent ?? "Not Found";
    }

    findCoverImageUrl(dom) {
        if (this.isCollectionList(dom)) {
            return this.extractCollectionCover(dom);
        }
        return util.getFirstImgSrc(dom, "picture");
    }


    extractCollectionCover(dom) {
        let divsWithPicutres = dom.querySelectorAll("div[src]");
        if (divsWithPicutres.length == 0) {
            return null;
        }
        return divsWithPicutres[divsWithPicutres.length - 1].getAttribute("src");
    }

    isCollectionList(dom) {
        return new URL(dom.baseURI).pathname.startsWith("/collection/");
    }
}

================================================
FILE: plugin/js/parsers/PawreadParser.js
================================================

"use strict";

parserFactory.register("pawread.com", () => new PawreadParser());

class PawreadParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let rootUrl = dom.baseURI;
        let items = [...dom.querySelectorAll("div.filtr-item .item-box")];
        return items.map(i => this.itemToChapter(i, rootUrl));
    }

    itemToChapter(item, rootUrl) {
        let pathTip = item.getAttribute("onclick").split("'")[1];
        return ({
            sourceUrl:  rootUrl + pathTip + ".html",
            title: item.querySelector(".c_title").textContent,
        });
    }

    findContent(dom) {
        return dom.querySelector("#chapter_item");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h3");
    }

    findCoverImageUrl(dom) {
        let div = dom.querySelector(".comic-view [style*=background-image]");
        return util.extractUrlFromBackgroundImage(div);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.txtDesc")];
    }
}

================================================
FILE: plugin/js/parsers/PeachblossomcodexParser.js
================================================

"use strict";

parserFactory.register("peachblossomcodex.com", () => new PeachblossomcodexParser());

class PeachblossomcodexParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.pbc_novel_chapters_wrapper");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.et_pb_row_inner_1_tb_body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h4.et_pb_module_header");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#main-content");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let note = webPageDom.querySelector("div.et_pb_row_inner_2_tb_body");
        if (note !== null) {
            content.append(note);
        }
        let footnotes = [...content.querySelectorAll(".wpcmtt")];
        this.moveFootnotes(webPageDom, content, footnotes);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.et_pb_module.et_pb_post_content")];
    }
}

================================================
FILE: plugin/js/parsers/PeachpittingParser.js
================================================

"use strict";

parserFactory.register("peachpitting.com", () => new PeachpittingParser());

class PeachpittingParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.pt-cv-wrapper a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#wtr-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.elementor-heading-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".pp-multiple-authors-wrapper");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.post-title h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#primary");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.elementor-text-editor")].slice(1, 2);
    }
}

================================================
FILE: plugin/js/parsers/PeachpuffParser.js
================================================

"use strict";

parserFactory.register("peachpuff.in", () => new PeachpuffParser());

class PeachpuffParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.lcp_catlist");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".kenta-article-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".category-post-dropdown-container, .code-block");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".kenta-article-content p")];
    }
}

================================================
FILE: plugin/js/parsers/PeachygardensBlogspotParser.js
================================================

"use strict";

parserFactory.register("peachygardens.blogspot.com", () => new PeachygardensBlogspotParser());

class PeachygardensBlogspotParser extends Parser {
    constructor() {
        super();
        this.ChacheChapterContent = new Map();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        //doing this allows me to get the book id from an script element
        dom = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        // eslint-disable-next-line
        let regex = new RegExp("clwd\.run.\'.+\'.;");
        let script = [...dom.scripts].map(a => a.innerHTML);
        let Bookid = script.filter(a => a.match(regex))?.[0].match(regex)?.[0];
        Bookid = Bookid.slice(10, Bookid.length-3);

        let pageCount = 2;
        let Chapterjsons;
        let chapters = [];
        let partialList;
        for (let i = 1; i < pageCount; i=i+50) {
            await this.rateLimitDelay();
            Chapterjsons = (await HttpClient.fetchJson("https://peachygardens.blogspot.com/feeds/posts/default/-/" + Bookid + "?alt=json&start-index=" + i + "&max-results=50")).json;
            partialList = this.chaptersFromJson(Chapterjsons);
            this.chacheChapter(Chapterjsons);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
            if (i == 1) {
                pageCount = Chapterjsons.feed.openSearch$totalResults.$t;
            }
        }
        chapters = chapters.filter(a => a.sourceUrl != dom.baseURI);
        return chapters.reverse();
    }

    chaptersFromJson(json) {
        return json.feed.entry.map(a => ({
            sourceUrl: a.link[2].href, 
            title: a.link[2].title
        }));
    }

    chacheChapter(json) {
        json.feed.entry.map(a => (this.ChacheChapterContent.set(a.link[2].href, [a.link[2].title, a.content.$t])));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    findCoverImageUrl(dom) {
        let coverImage = dom.querySelector("header");
        return coverImage === null
            ? null
            : coverImage.querySelector("img").src;
    }

    async fetchChapter(url) {
        return this.buildChapter(this.ChacheChapterContent.get(url), url);
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json[0];
        newDoc.content.appendChild(title);
        let content = util.sanitize(json[1]);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/PindangscansParser.js
================================================

"use strict";

parserFactory.register("pindangscans.com", () => new PindangscansParser());

class PindangscansParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    getUrlsOfTocPages(dom) {
        let tocUrls = [];
        let pagination = dom.querySelector("ul.page-numbers");
        if (pagination != null ) {
            let tocUrl = [...pagination.querySelectorAll("a:not(.next)")].pop()?.href;
            if (tocUrl) {
                let splitUrl = tocUrl.split("/");
                if (splitUrl.length >= 6) {
                    let maxPage = parseInt(splitUrl[5]);
                    for (let i = 2; i <= maxPage; ++i) {
                        splitUrl[5] = i;
                        tocUrls.push(splitUrl.join("/"));
                    }
                }
            }
        }
        return tocUrls;
    }

    extractPartialChapterList(dom) {
        let menu = dom.querySelector("ul[data-layout='list']");
        return util.hyperlinksToChapterList(menu);        
    }

    findContent(dom) {
        return dom.querySelector(".brxe-post-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.brxe-heading");
    }
    findChapterTitle(dom) {
        return dom.querySelector("h2.brxe-post-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("main .brxe-text-basic")];
    }
}

================================================
FILE: plugin/js/parsers/PowanjuanParser.js
================================================

"use strict";

parserFactory.register("powanjuan.cc", () => new PowanjuanParser());

class PowanjuanParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.catalog");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#mycontent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractLanguage() {
        return "zh";
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let options = { makeTextDecoder: () => new TextDecoder("gb2312") };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".descTip, .descInfo")];
    }
}

================================================
FILE: plugin/js/parsers/PtwxzParser.js
================================================

"use strict";

parserFactory.register("piaotia.com", () => new PtwxzParser());

class PtwxzParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.querySelector("#content table tbody tr td table caption a").href;
        let tocDom = await this.fetchChapter(tocUrl);
        let table = tocDom.querySelector("div.centent");
        return util.hyperlinksToChapterList(table);
    }

    findContent(dom) {
        return dom.querySelector("body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("#content table table table h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "#guild, #shop, .toplink, table, #feit2, #Commenddiv, .bottomlink");
        super.removeUnwantedElementsFromContentElement(element);
    }

    async fetchChapter(url) {
        // site does not tell us gbk is used to encode text
        let options = { makeTextDecoder: () => new TextDecoder("gbk") };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("#content table table a:not([tiptitle]) img")?.src ?? null;
    }
}

================================================
FILE: plugin/js/parsers/PuretlParser.js
================================================

"use strict";

parserFactory.register("puretl.com", () => new PuretlParser());

class PuretlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.accordion-items-container")
            || dom.querySelector("ul.archive-group-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return [...dom.querySelectorAll("div.sqs-html-content")][1];
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".content .sqs-html-content p");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".content .sqs-html-content")];
    }
}

================================================
FILE: plugin/js/parsers/QidianParser.js
================================================

/*
   parses Qidian International site
*/
"use strict";

parserFactory.register("webnovel.com", () => new QidianParser());

class QidianParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 50; //Minimal delay to reduce frequency of 445 errors.
        this.ChacheChapterTitle = new Map();
    }

    async getChapterUrls(dom) {
        if (!dom.baseURI.match(new RegExp("/catalog$"))) {
            let newURL = dom.baseURI;
            let regex = new RegExp("(/book/(?:.*?_)?\\d+\\b).*");
            newURL = newURL.replace(regex, "$1/catalog");
            regex = new RegExp("(/comic/(?:.*?_)?\\d+\\b).*");
            newURL = newURL.replace(regex, "$1/catalog");
            dom = (await HttpClient.wrapFetch(newURL)).responseXML;
        }
        let links = Array.from(dom.querySelectorAll("ul.content-list a"));
        if (links.length === 0) {
            links = Array.from(dom.querySelectorAll("div.volume-item ol a"));
        }
        return links.map(QidianParser.linkToChapter);
    }

    static isLinkLocked(link) {
        let img = link.querySelector("svg > use");
        return (img != null)
            && (img.getAttribute("xlink:href") === "#i-lock");
    }

    static linkToChapter(link) {
        let title = link.textContent;
        let element = link.querySelector("strong");
        if (element !== null) {
            title = element.textContent.trim();
            if (!document.getElementById("removeChapterNumberCheckbox").checked) {
                element = link.querySelector("i");
                if (element !== null) {
                    title = element.textContent + ": " + title;
                }
            }
        }
        return {sourceUrl: link.href, title: title, 
            isIncludeable: !QidianParser.isLinkLocked(link)
        };
    }

    findContent(dom) {
        return dom.querySelector("div.chapter_content");
    }

    preprocessRawDom(webPage) {
        if (this.ChacheChapterTitle.size == 0) {
            let pagesToFetch = [...this.state.webPages.values()].filter(c => c.isIncludeable);
            pagesToFetch.map(a => (this.ChacheChapterTitle.set(a.sourceUrl, a.title)));
        }
        let content = this.findContent(webPage);
        if (content !== null) {
            content = this.cleanRawDom(content);
            return;
        }
        let json = this.findChapterContentJson(webPage);
        if (json === null) {
            return;
        }
        content = webPage.createElement("div");
        content.className = "chapter_content";
        webPage.body.appendChild(content);
        this.addHeader(webPage, content, json.chapterInfo.chapterName);
        for (let c of json.chapterInfo?.contents?json.chapterInfo.contents:[]) {
            this.addParagraph(webPage, content, c.content);
        }
        for (let c of json.chapterInfo?.chapterPage?json.chapterInfo.chapterPage:[]) {
            this.addComicPage(webPage, content, c.url);
        }
        if (!this.userPreferences.removeAuthorNotes.value) {
            let notes = json.chapterInfo.notes?.note ?? null;
            if (!util.isNullOrEmpty(notes)) {
                let container = this.addNoteContainer(webPage, content);
                this.addHeader(webPage, container, "Notes");
                this.addParagraph(webPage, container, notes);
            }
        }
        for (let e of [...webPage.querySelectorAll("div.j_bottom_comment_area, div.user-links-wrap, div.g_ad_ph")]) {
            e.remove();
        }
    }

    cleanRawDom(content)
    {
        //Remove repeating & unused metadata from document. Approximately halves body length.
        content.querySelectorAll("i.para-comment_num, i.para-comment").forEach(i => i.remove());
        content.querySelectorAll("div.db").forEach(i => i.removeAttribute("data-ejs"));
        let tmptitle = this.ChacheChapterTitle.get(content.baseURI);
        let newtitlenode = document.createElement("h1");
        if (tmptitle == undefined || tmptitle == "[placeholder]") {
            let titleEl = content.querySelector("div.chapter_content h1");
            let titleDupChapRegex = new RegExp("(\\w+[\\s\\-]+\\d+):\\s*\\1:?(.*)", "i").exec(titleEl.textContent);
            if (titleDupChapRegex && titleDupChapRegex.length > 2) {
                let newtitleText = document.createTextNode(titleDupChapRegex[1] + titleDupChapRegex[2]);
                newtitlenode.appendChild(newtitleText);
                titleEl.replaceWith(newtitlenode);
            }
        } else {
            let newtitleText = document.createTextNode(tmptitle);
            newtitlenode.appendChild(newtitleText);
            content.querySelector("div.chapter_content h1").replaceWith(newtitlenode);
        }
        return content;
    }

    findChapterContentJson(dom) {
        const searchString = "var chapInfo=";
        return [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(s => s.startsWith(searchString))
            .map(s => util.locateAndExtractJson(this.fixExcaping(s), searchString))[0];
    } 

    fixExcaping(s) {
        return this.stripBackslash(s)
            .replace(/\n|\r|<\/?p>/g, "");
    }

    addHeader(webPage, content, text) {
        this.addElement(webPage, content, "h3", text);
    }

    addParagraph(webPage, content, text) {
        this.addElement(webPage, content, "p", text);
    }

    addComicPage(webPage, content, text) {
        let t = webPage.createElement("img");
        t.src = text;
        content.appendChild(t);
        return t;
    }

    addNoteContainer(webPage, content) {
        let container = this.addElement(webPage, content, "div", "");
        this.tagAuthorNotes([container]);
        return container;
    }

    addElement(webPage, content, tag, text) {
        let t = webPage.createElement(tag);
        t.textContent = text;
        content.appendChild(t);
        return t;
    }

    stripBackslash(s) {
        const singleEscapeChars = "\"\\";
        const stripChars = "bfnrtv";
        let temp = "";
        let i = 0;
        while (i < (s.length)) {
            if (s[i] === "\\") {
                ++i;
                if (stripChars.includes(s[i])) {
                    temp += " ";
                }
                else { 
                    if (singleEscapeChars.includes(s[i])) {
                        temp += "\\";
                    }
                    temp += s[i];
                }
            }
            else {
                temp += s[i];
            }
            ++i;
        }
        return temp;
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
        document.getElementById("removeChapterNumberRow").hidden = false; 
    }

    // title of the story
    extractTitleImpl(dom) {
        let title = dom.querySelector("div.chapter_content h1");
        return title;
    }

    extractAuthor(dom) {
        return dom.querySelector("a.c_primary")?.textContent ?? super.extractAuthor(dom);
    }
 
    removeUnwantedElementsFromContentElement(content) {
        util.removeChildElementsMatchingSelector(content, "form.cha-score, div.cha-bts, pirate, div.cha-content div.user-links-wrap, div.tac");
        this.tagAuthorNotesBySelector(content, "div.m-thou");
        super.removeUnwantedElementsFromContentElement(content);
    }

    findCoverImageUrl(dom) {
        let imgs = [...dom.querySelectorAll("div.det-hd i.g_thumb img")];
        return 0 === imgs.length 
            ? util.getFirstImgSrc(dom, "div.det-hd")
            : imgs.pop().src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div._mn, div.det-abt")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "div._ft, span.g_star");
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.m-tags a")]);
        return tags.map(e => e.textContent.replace(" # ", "").trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.det-abt p.c_000").textContent.trim();
    }
}

================================================
FILE: plugin/js/parsers/QinxiaoshuoParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("qinxiaoshuo.com", () => new QinxiaoshuoParser());

class QinxiaoshuoParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.chapters a")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters);
    }

    findContent(dom) {
        return dom.querySelector("div#chapter_content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book_name").textContent;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.info a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    extractLanguage() {
        return "cn";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book_info");
    }

    fetchChapter(url) {
        return HttpClient.wrapFetch(url).then(function(xhr) {
            let finalDom = xhr.responseXML;
            let fetchedUrls = new Set();
            fetchedUrls.add(url);
            fetchedUrls.add(url + "?xiaoshuo=1");
            let nextUrl = QinxiaoshuoParser.urlOfNextPageOfChapter(finalDom, fetchedUrls);
            return QinxiaoshuoParser.fetchPagesOfChapter(finalDom, fetchedUrls, nextUrl);
        });
    }

    static fetchPagesOfChapter(finalDom, fetchedUrls, url) {
        if (url === null) {
            return Promise.resolve(finalDom);
        } else {
            return HttpClient.wrapFetch(url).then(function(xhr) {
                fetchedUrls.add(url);
                QinxiaoshuoParser.copyContentNodes(finalDom, xhr.responseXML);
                let nextUrl = QinxiaoshuoParser.urlOfNextPageOfChapter(xhr.responseXML, fetchedUrls);
                return QinxiaoshuoParser.fetchPagesOfChapter(finalDom, fetchedUrls, nextUrl);
            });
        }
    }

    static urlOfNextPageOfChapter(dom, fetchedUrls) {
        let links = [...dom.querySelectorAll("div.buttons a")]
            .filter(link => QinxiaoshuoParser.isPossibleNextPage(link, fetchedUrls));
        return (0 < links.length) ? links[0].href : null;
    }

    static isPossibleNextPage(link, fetchedUrls) {
        let url = new URL(link.href);
        let xiaoshuo = url.searchParams.get("xiaoshuo");
        return (xiaoshuo !== null) && !fetchedUrls.has(link.href);
    }

    static copyContentNodes(copyTo, copyFrom) {
        let parser = new QinxiaoshuoParser();
        let toElement = parser.findContent(copyTo);
        let newDiv = copyTo.createElement("div");
        toElement.appendChild(newDiv);
        for (let n of parser.findContent(copyFrom).childNodes) {
            let c = copyTo.importNode(n);
            newDiv.appendChild(c);
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".book_info .info, .book_info .book_name, .book_info .book_intro")];
    }
}

================================================
FILE: plugin/js/parsers/QqxsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.qqxs.vip", () => new QqxsParser());

class QqxsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocUrl = dom.querySelector("a.btn_toBookShelf")?.href;
        if (tocUrl) {
            dom = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        }

        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        ));
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("#chapterlist p a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    getUrlsOfTocPages(dom) {
        return [...dom.querySelectorAll("option")]
            .map(o => "https://m.qqxs.vip/" + o.value);
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("span.title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("#nr_title");
    }

    async fetchChapter(url) {
        let newDoc = (await HttpClient.wrapFetch(url)).responseXML;
        let content = this.findContent(newDoc);
        let nextPageUrl = this.findNextPageUrl(newDoc);
        while (nextPageUrl != null) {
            let dom = (await HttpClient.wrapFetch(nextPageUrl)).responseXML;
            content.appendChild(this.findContent(dom));
            nextPageUrl = this.findNextPageUrl(dom);
        }
        this.fixImages(content);
        return newDoc;
    }

    findNextPageUrl(dom) {
        let links = [...dom.querySelectorAll("p.Readpage a.p4")]
            .filter(a => a.href.includes("-"));
        return links[0]?.href;
    }

    fixImages(element) {
        let images = [...element.querySelectorAll("img")];
        for (let i of images) {
            if (i.src.includes("juhao.png")) {
                i.remove();
            }
            else if (i.src.includes("gantanhao.png")) {
                i.replaceWith("!");
            }
            else if (i.src.includes("douhao.png")) {
                i.replaceWith(",");
            }
            else if (i.src.includes("wenhao.png")) {
                i.replaceWith("?");
            }
        }
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".synopsisArea");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.review")];
    }
}

================================================
FILE: plugin/js/parsers/Quanben5Parser.js
================================================

"use strict";

parserFactory.register("quanben5.io", () => new Quanben5Parser());

class Quanben5Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span.author");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.pic_txt_list");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("p.description")];
    }
}

================================================
FILE: plugin/js/parsers/QuanbenParser.js
================================================

"use strict";

parserFactory.register("quanben.io", () => new QuanbenParser());

class QuanbenParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        if (!dom.baseURI.endsWith("/list.html")) {
            let tocUrl = dom.baseURI + "/list.html";
            dom = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        }
        return [...dom.querySelectorAll("div.box li a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        let span = dom.querySelector("span[itemprop='name']");
        return span === null ? null : span.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.headline");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div[itemscope]");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.description")];
    }
}

================================================
FILE: plugin/js/parsers/QueenrosenovelblogspotParser.js
================================================

"use strict";

parserFactory.register("queenrosenovel.blogspot.com", () => new QueenrosenovelblogspotParser());

class QueenrosenovelblogspotParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.epcheck li a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector(".chapternum").textContent
        });
    }

    findContent(dom) {
        return dom.querySelector("div.Novel");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("header h1");
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("h1");
        util.removeChildElementsMatchingSelector(title, "script");
        return title;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "figure");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let script = content.querySelector("script").textContent;
        let html = script.substring(script.indexOf("`") + 1, script.length - 1);
        let doc = util.sanitize("<div id='start'>" + html + "</div>");
        content.appendChild(doc.querySelector("div#start"));
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/QuotevParser.js
================================================

"use strict";

parserFactory.register("quotev.com", () => new QuotevParser());

class QuotevParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let baseUrl = dom.baseURI;
        if (!baseUrl.endsWith("/")) {
            const index = baseUrl.lastIndexOf("/");
            baseUrl = baseUrl.substring(0, index + 1);
        }
        let select = dom.querySelector("div#footer_pages select");
        if (select === null) {
            return this.makeUrlListForSingleChapterStory(dom);
        }
        return [...select.querySelectorAll("option")]
            .map(o => this.optionToChapter(o, baseUrl));
    }

    optionToChapter(option, baseUrl) {
        return {
            sourceUrl:  baseUrl + option.getAttribute("value"),
            title: option.textContent,
        };
    }

    makeUrlListForSingleChapterStory(dom) {
        let title = this.extractTitleImpl(dom).textContent.trim();
        return [({
            sourceUrl:  dom.baseURI,
            title: title,
        })];
    }

    findContent(dom) {
        return dom.querySelector("div#quizResArea");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div#quizHeaderTitle h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.quizAuthorList a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#quizResArea");
    }
}

================================================
FILE: plugin/js/parsers/RaeitranslationsParser.js
================================================

"use strict";

parserFactory.register("raeitranslations.com", () => new RaeitranslationsParser());

class RaeitranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.chapter-list a")]
            .map(this.linkToChapter);
    }

    linkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.querySelector(".chapter-title").innerText.trim(),
        };
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.title");
    }

    findCoverImageUrl(dom) {
        let div = dom.querySelector("div.img.wrapper [style*=background-image]");
        return "https://raeitranslations.com" + util.extractUrlFromBackgroundImage(div);
    }

    async fetchChapter(url) {
        let restUrl = this.makeRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        let content = this.buildHtml(json.currentChapter);
        let newDoc = Parser.makeEmptyDocForContent(url);
        newDoc.content.appendChild(content);
        return newDoc.dom; 
    }

    makeRestUrl(chapterUrl) {
        let path = new URL(chapterUrl).pathname.split("/");
        let restUrl = new URL("https://api.raeitranslations.com/api/chapters/single");
        restUrl.searchParams.set("id", path[1]);
        restUrl.searchParams.set("num", path[2]);
        return restUrl;
    }

    buildHtml(json) {
        let paragraphs = json.body.replace(/\n/g, "</p><p>");
        let html = `<div><h1>${json.chapTitle}</h1><p>${paragraphs}</p></div>`;
        let doc = util.sanitize(html, "text/html");
        return doc.querySelector("div");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.white-space")];
    }
}

================================================
FILE: plugin/js/parsers/RainOfSnowParser.js
================================================

"use strict";

parserFactory.register("rainofsnow.com", () => new RainOfSnowParser());

class RainOfSnowParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            RainOfSnowParser.extractPartialChapterList,
            RainOfSnowParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("div#chapter a:not(.page-numbers)")]
            .map(a => util.hyperLinkToChapter(a));
    }

    static getUrlsOfTocPages(dom) {
        return [...dom.querySelectorAll("ul.page-numbers a.page-numbers:not(.next)")]
            .map(a => a.href);
    }

    findContent(dom) {
        let content = dom.querySelector("div.zoomdesc-cont");
        util.fixDelayLoadedImages(content, "data-src");
        return content;
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".container h2");
    }

    findChapterTitle(dom) {
        return dom.querySelector("li.menu-toc-current")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector(".imagboca1 img");
        return img?.getAttribute("data-src");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#synop")];
    }
}

================================================
FILE: plugin/js/parsers/RandomtranslatorParser.js
================================================

"use strict";

parserFactory.register("randomtranslator.com", () => new RandomtranslatorParser());

class RandomtranslatorParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/novel\/.+");
        let bookhash = dom.baseURI.match(regex)?.[0].slice(7);
        let bookinfo = (await HttpClient.fetchJson("https://api.randomtranslator.com/api/v1/novels/" + bookhash)).json;
        let chapterssorted = [...bookinfo.chapters].sort((a,b) => a.sequence_number - b.sequence_number);
        let chapters = chapterssorted.map(a => ({
            sourceUrl:  "https://www.randomtranslator.com/chapter/"+a.id,
            title: a.translated_title,
            isIncludeable: !a.is_restricted    
        }));
        return chapters;
    }
    
    async loadEpubMetaInfo(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/novel\/.+");
        let bookhash = dom.baseURI.match(regex)?.[0].slice(7);
        let bookinfo = (await HttpClient.fetchJson("https://api.randomtranslator.com/api/v1/novels/" + bookhash)).json;
        this.title = bookinfo.translated_title;
        this.author = bookinfo.translated_author;
        this.tags = bookinfo.tags.map(a => a.translated_name);
        this.tags = this.tags.concat(bookinfo.translated_category);
        this.description = bookinfo.ai_description;
        this.img = bookinfo.image_url;
        return;
    }

    extractTitleImpl() {
        return this.title;
    }

    extractAuthor() {
        return this.author;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    async fetchChapter(url) {
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl)).json;
        return this.buildChapter(json, url);
    }

    toRestUrl(url) {
        let leaves = url.split("/");
        let id = leaves[leaves.length - 1];
        return "https://api.randomtranslator.com/api/v1/chapters/" + id;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json.translated_title;
        newDoc.content.appendChild(title);
        let text = json.translated_content.replace("\n\n", "\n");
        text = text.split("\n");
        let br = newDoc.dom.createElement("br");
        for (let element of text) {
            let pnode = newDoc.dom.createElement("p");
            pnode.textContent = element;
            newDoc.content.appendChild(pnode);
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/RanobesParser.js
================================================

"use strict";

parserFactory.register("ranobes.net", () => new RanobesNetParser());
parserFactory.register("ranobes.top", () => new RanobesNetParser());
parserFactory.register("ranobes.com", () => new RanobesParser());

class RanobesParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 2000;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = [];
        let tocUrl = dom.querySelector("div.r-fullstory-chapters-foot a[title='Go to table of contents']")?.href;
        if (tocUrl == null) {
            tocUrl = dom.querySelector("div.r-fullstory-chapters-foot a[title='Перейти в оглавление']")?.href;
        }
        if (tocUrl == null) {
            return [...dom.querySelectorAll("ul.chapters-scroll-list a")]
                .map(a => ({
                    sourceUrl:  a.href,
                    title: a.querySelector(".title").textContent
                })).reverse();
        }
        let options = {
            parser: this
        };
        let tocDom = (await HttpClient.wrapFetch(tocUrl, options)).responseXML;
        let urlsOfTocPages = RanobesParser.extractTocPageUrls(tocDom, tocUrl);
        return (await this.getChaptersFromAllTocPages(chapters, 
            this.extractPartialChapterList, urlsOfTocPages, chapterUrlsUI, options)).reverse();
    }

    static extractTocPageUrls(dom, baseUrl) {
        let max = RanobesParser.extractTocJson(dom)?.pages_count ?? 0;
        let tocUrls = [];
        for (let i = 1; i <= max; ++i) {
            tocUrls.push(`${baseUrl}page/${i}/`);
        }
        return tocUrls;
    }

    static extractTocJson(dom) {
        let baseURL = new URL(dom.baseURI).hostname;
        if (baseURL != "ranobes.com") {
            let startString = "window.__DATA__ = ";
            let scriptElement = [...dom.querySelectorAll("script")]
                .filter(s => s.textContent.includes(startString))[0];
            return (scriptElement != null)
                ? util.locateAndExtractJson(scriptElement.textContent, startString)
                : {chapters: [], pages_count: 0};
        } else {
            let linkElement = Math.max(...[...dom.querySelectorAll(".pages a")].map(a => parseInt(a.textContent)));
            return (Infinity == linkElement || -Infinity == linkElement)?
                {chapters: [], pages_count: 0} 
                : {chapters: [], pages_count: linkElement};
        }   
    }

    extractPartialChapterList(dom) {
        let baseURL = new URL(dom.baseURI).hostname;
        if (baseURL != "ranobes.com") {
            return RanobesParser.extractTocJson(dom).chapters.map(c => ({
                sourceUrl:  c.link,
                title: c.title
            }));
        } else {
            let Chapterlist = dom.querySelector("#dle-content");
            let RemoveNavigation = Chapterlist.querySelector(".navigation");
            Chapterlist.removeChild(RemoveNavigation);
            return util.hyperlinksToChapterList(Chapterlist);
        }
    }

    findContent(dom) {
        return dom.querySelector("div#arrticle");
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector("h1.title");
        util.removeChildElementsMatchingSelector(title, "span.subtitle, span[hidden]");
        return title;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span[itemprop='creator'] a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("h1.title");
        util.removeChildElementsMatchingSelector(title, "span, div");
        return title.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.r-fullstory-poster");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.moreless__full")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "a");
        return node;
    }    
}

class RanobesNetParser extends RanobesParser {
    constructor() {
        super();
        this.minimumThrottle = 8000;
    }

    async fetchChapter(url) {
        let options = {
            parser: this
        };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }
    
    isCustomError(response) {
        if (response.responseXML.title == "Just a moment...") {
            return true;
        }
        return false;
    }

    setCustomErrorResponse(url, wrapOptions) {
        let newresp = {};
        newresp.url = url;
        newresp.wrapOptions = wrapOptions;
        newresp.response = {};
        newresp.response.url = url;
        newresp.response.status = 403;
        return newresp;
    }
}

================================================
FILE: plugin/js/parsers/ReadComicOnlineParser.js
================================================

"use strict";

parserFactory.register("readcomiconline.li", () => new ReadComicOnlineParser());

/**

- This one kind of works,
- There are issues with site's anti-copy stuff.
- Usually need to open a first page of chapter before rest will work.
- Also, sometimes pages return a CAPTCHA
 */
class ReadComicOnlineParser extends Parser {
    constructor() {
        super();
    }

    static extractImageUrls(dom) {
        let prefix = "lstImages.push(\"";
        let script = [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(s => s.includes(prefix))[0];
        let urls = [];
        let index = script.indexOf(prefix);
        while (0 < index) {
            index += prefix.length;
            let suffix = script.indexOf("\"", index);
            urls.push(script.substring(index, suffix));
            index = script.indexOf(prefix, suffix);
        }
        return urls;
    }

    async getChapterUrls(dom) {
        if (this.isIssuePage(dom)) {
            ReadComicOnlineParser.rawDom = dom;
            return [{
                sourceUrl:  dom.baseURI,
                title: "Issue",
                newArc: null
            }];
        }
        if (this.isComicTocPage(dom)) {
            return this.getChapterListFromComicTocPage(dom);
        }
        return this.fetchMultipleTocPages(dom);
    }

    isIssuePage(dom) {
        return dom.querySelector("select#selectPage") !== null;
    }

    isComicTocPage(dom) {
        let path = new URL(dom.baseURI).pathname.split("/");
        return path[1].toLowerCase() === "comic";
    }

    getChapterListFromComicTocPage(dom) {
        let toc = dom.querySelector("table.listing");
        return util.hyperlinksToChapterList(toc).reverse();
    }

    async fetchMultipleTocPages(dom) {
        let chapters = [];
        let toclinks = [...dom.querySelectorAll("table.listing a")]
            .filter(l => new URL(l.href).search === "");
        for (let link of toclinks) {
            let html = await this.fetchChapter(link.href);
            let subList = this.getChapterListFromComicTocPage(html);
            subList[0].newArc = link.textContent.trim();
            chapters = chapters.concat(subList);
        }
        return chapters;
    }

    findContent(dom) {
        let content = Parser.findConstrutedContent(dom);
        if (content === null) {
            content = dom.createElement("div");
            content.className = Parser.WEB_TO_EPUB_CLASS_NAME;
            dom.body.appendChild(content);
            let imgUrls = ReadComicOnlineParser.extractImageUrls(dom);
            for (let u of imgUrls) {
                let img = dom.createElement("img");
                img.src = u;
                content.appendChild(img);
            }
        }
        return content;
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector("a.bigChar");
        return title === null ? null : title.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#rightside div.barContent");
    }

    async fetchChapter(url) {
        if (ReadComicOnlineParser.rawDom != null) {
            return ReadComicOnlineParser.rawDom;
        }
        let html = null;
        while (html === null)  {
            html = await ReadComicOnlineParser.tryFetchChapter(url);
        }
        return html;
    }

    static async tryFetchChapter(url) {
        let response = await fetch(url, HttpClient.makeOptions());
        if (response.ok) {
            if (url !== response.url) {
                await ReadComicOnlineParser.doCaptchaRequest(response.url);
                return null;
            }
            let text = await response.text();
            let html = util.sanitize(text);
            util.setBaseTag(response.url, html);
            return html;
        }
        if (response.status === 503) {
            await ReadComicOnlineParser.do503Text(url);
            return null;
        }
    }

    static async doCaptchaRequest(url) {
        await util.createChapterTab(url);
        let errorText = "Site is probably trying to get you to complete a CAPTCHA.\n" +
            " WebToEpub has tried to open a tab to url " + url + "\n" +
            " If tab has not opened, you'll need to open it.\n" +
            " Once open, complete the CAPTCHA, close tab and click the \"Retry\" button above.";
        return ReadComicOnlineParser.promptUserForRetry(errorText);
    }

    static async do503Text(url) {
        await util.createChapterTab(url);
        let errorText = "Site is probably trying to run javascript to avoid DDOS.\n" +
            " WebToEpub has tried to open a tab to url " + url + "\n" +
            " If tab has not opened, you'll need to open it.\n" +
            " Once open, wait for comic book chapter to load. then close tab and click the \"Retry\" button above";
        return ReadComicOnlineParser.promptUserForRetry(errorText);
    }

    static async promptUserForRetry(errorText) {
        let msg = new Error(errorText);
        let cancelLabel = FetchErrorHandler.cancelButtonText();
        return new Promise(function(resolve, reject) {
            msg.retryAction = () => resolve(true);
            msg.cancelAction = () => reject(false);
            msg.cancelLabel = cancelLabel;
            ErrorLog.showErrorMessage(msg);
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("div.barContent")];
    }
}

================================================
FILE: plugin/js/parsers/ReaderNovelParser.js
================================================

"use strict";

parserFactory.register("readernovel.net", () => new ReaderNovelParser());

class ReaderNovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".chapter-list-wrapper a")]
            .map(link => this.linkToChapter(link))
            .reverse();
    }

    linkToChapter(link) {
        let title = link.getAttribute("title");
        return ({
            sourceUrl:  link.href,
            title: title,
        });
    }

    findContent(dom) {
        return (
            dom.querySelector("div#chapter-container") || dom.querySelector("#chapter-content")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".page-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("li.list-group-item a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("span.chapter-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".manga-image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#collapseSummary")];
    }

}

================================================
FILE: plugin/js/parsers/ReadhiveParser.js
================================================

"use strict";

parserFactory.register("readhive.org", () => new ReadhiveParser());

class ReadhiveParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        const tab = this.getTab(dom, "releases"); 
        return [...tab.querySelectorAll("a")]
            .map(ReadhiveParser.linkToChapter)
            .reverse();
    }

    static linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector("span.ml-1").textContent.trim(),
        });
    }

    getTab(dom, filter) {
        return [...dom.querySelectorAll("main div[x-show]")]
            .filter(d => d.getAttribute("x-show")?.includes(filter))
            ?.pop();
    }

    findContent(dom) {
        return dom.querySelector("main div.justify-center:not([x-data])");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1 strong");
    }

    customRawDomToContentStep(chapter, content) {
        for (let e of content.querySelectorAll("div")) {
            let toRemove = [];
            for (let attr of e.attributes) {
                if (attr.name.startsWith("@")) {
                    toRemove.push(attr.name);
                }
            }
            for (let attr of toRemove) {
                e.removeAttribute(attr);
            }
        }
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div[x-data]");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main");
    }

    getInformationEpubItemChildNodes(dom) {
        const tab = this.getTab(dom, "about"); 
        return tab == null
            ? []
            : [...tab.querySelectorAll("p")];
    }
}

================================================
FILE: plugin/js/parsers/ReadindpiaParser.js
================================================

"use strict";

parserFactory.register("readingpia.me", () => new ReadingpiaParser());

class ReadingpiaParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll(".content a:has(div)")]
            .map(link => this.linkToChapter(link)).reverse();
    }

    linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector("div span").textContent,
        });
    }

    findContent(dom) {
        return dom.querySelector("div#chapter-body") 
            || dom.querySelector("div.chapter-body")
            || dom.querySelector("main > div:not(.advertisement):not(.promo-container):not(.comments):not([style])");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.novel-title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".info-ans");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector(".novel-synopsis")];
    }

}

================================================
FILE: plugin/js/parsers/ReadLightNovelCcParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("readlightnovel.cc", () => new ReadLightNovelCcParser());

class ReadLightNovelCcParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("a.chapter-item")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("section.section");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-name").textContent;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author span.name");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/ReadLightNovelParser.js
================================================

/*
  Parses <www.readlightnovel.com>
*/
"use strict";

parserFactory.register("readlightnovel.me", () => new ReadLightNovelParser());
parserFactory.register("readlightnovel.meme", () => new ReadLightNovelParser());
//dead url
parserFactory.register("readlightnovel.org", () => new ReadLightNovelParser());
//dead url
parserFactory.register("readlightnovel.today", () => new ReadLightNovelParser());

class ReadLightNovelParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chaptersDiv = dom.querySelector("div.chapters");
        let chapters = util.hyperlinksToChapterList(chaptersDiv, this.isChapterHref, this.getChapterArc);
        if (0 < chapters.length) {
            return Promise.resolve(chapters);
        }
        else {
            return Promise.reject(new Error(UIText.Error.noChaptersFound));
        }
    }

    isChapterHref(link) {
        return link.hash === "";
    }

    getChapterArc(link) {
        let parent = link.parentNode;
        let panelDiv = null;
        let arc = null;
        // find outermost <div> of panel
        while ((panelDiv === null) && (parent !== null)) {
            if ((parent.tagName.toLowerCase() === "div") && (parent.className === "panel panel-default")) {
                panelDiv = parent;
            } else {
                parent = parent.parentNode;
            }
        }

        // get the title
        if (panelDiv !== null) {
            let titleDiv = panelDiv.querySelector("div.panel-heading");
            if (titleDiv !== null) {
                arc = titleDiv.innerText.trim();
            }
        }
        return arc;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.block-title");
    }

    extractAuthor(dom) {
        let div = util.getElement(dom, "div", d => (d.className === "novel-detail-item") &&
            (this.novelDetailHeaderName(d) === "Author(s)"));
        if (div !== null) {
            let li = div.querySelector("li");
            if (li != null) {
                return li.innerText;
            }
        }
        return super.extractAuthor(dom);
    }

    novelDetailHeaderName(div) {
        let header = div.querySelector("div.novel-detail-item-header");
        if (header !== null) {
            return header.innerText.trim();
        }
        return "";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-cover");
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div[class^='chapter-content']");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        let firstBr = element.querySelector("br:first-of-type");
        let ch = firstBr.nextSibling;
        if (ch && ch.data.includes("Chapter")) {
            let secondBr = ch.nextSibling;
            if (secondBr && secondBr.tagName == "BR") {
                util.removeElements([firstBr, ch, secondBr]);
            }
        }

        for (let a of element.querySelectorAll(".adsbyvli")) {
            let toDelete = [];
            let center = a.parentNode;
            let temp =  this.addPreviousSiblingIfMatches(center, "BR", toDelete);
            this.addPreviousSiblingIfMatches(temp, "BR", toDelete);
            temp = this.addNextSiblingIfMatches(center, "BR", toDelete);
            temp = this.addNextSiblingIfMatches(temp, "BR", toDelete);
            this.addNextSiblingIfMatches(temp, "HR", toDelete);

            if (center.tagName == "CENTER") {
                center.remove();
            }
            util.removeElements(toDelete);
        }

        for (let small of element.querySelectorAll(".ads-title")) {
            let toDelete = [];
            this.addPreviousSiblingIfMatches(small, "BR", toDelete);
            let temp = this.addNextSiblingIfMatches(small, "BR", toDelete);
            temp = this.addNextSiblingIfMatches(temp, "CENTER", toDelete);
            this.addNextSiblingIfMatches(temp, "HR", toDelete);

            small.remove();
            util.removeElements(toDelete);
        }

        for (let s of element.querySelectorAll("center > script")) {
            let toDelete = [];
            let center = s.parentNode;
            this.addNextSiblingIfMatches(center, "HR", toDelete);

            center.remove();
            util.removeElements(toDelete);
        }

        super.removeUnwantedElementsFromContentElement(element);
        util.removeChildElementsMatchingSelector(element, "div.row, " +
            ".alert, img[src*='/magnify-clip.png'], div.hidden, p.hid");
        this.removeShareThisLinks(element);
    }

    addPreviousSiblingIfMatches(element, tagName, list) {
        return this.addSiblingIfMatches(element, tagName, list, e => e.previousElementSibling);
    }

    addNextSiblingIfMatches(element, tagName, list) {
        return this.addSiblingIfMatches(element, tagName, list, e => e.nextElementSibling);
    }

    addSiblingIfMatches(element, tagName, list, op) {
        if (element === null) {
            return null;
        }
        let sibling = op(element);

        if (!sibling && (element.parentNode !== null)) {
            sibling = op(element.parentNode);
        }

        if (sibling !== null) {
            if (sibling.tagName === tagName) {
                list.push(sibling);
            } else {
                sibling = null;
            }
        }
        return sibling;
    }

    removeShareThisLinks(element) {
        let shareLinks = element.querySelectorAll("span.st_facebook, " +
            "span.st_twitter, span.st_googleplus");
        for (let share of shareLinks) {
            let parent = share.parentNode;
            if (parent.tagName.toLowerCase() === "p") {
                parent.remove();
            }
            share.remove();
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-details")];
    }
}

================================================
FILE: plugin/js/parsers/ReadnoveldailyParser.js
================================================

"use strict";

//dead url
parserFactory.register("readnoveldaily.com", () => new ReadnoveldailyParser());
parserFactory.register("allnovelbook.com", () => new ReadnoveldailyParser());

class ReadnoveldailyParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    getUrlsOfTocPages(dom) {
        let urls = [];
        let paginateUrls = [...dom.querySelectorAll("ul.pagination li a:not([rel])")];
        if (0 < paginateUrls.length) {
            let url = new URL(paginateUrls.pop().href);
            let maxPage = url.searchParams.get("page");
            for (let i = 2; i <= maxPage; ++i) {
                url.searchParams.set("page", i);
                urls.push(url.href);
            }
        }
        return urls;
    }
    
    extractPartialChapterList(dom) {
        let menu = [...dom.querySelectorAll("#viewchapter .row a")];
        return menu.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    isHTMLUnknownElement(element) {
        return (element instanceof HTMLUnknownElement);
    }
    //removes the watermark that is wraped in custom xml tag -> no valid HTML tag
    removeUnknownElement(element) {
        for (let node of element.childNodes) {
            if (this.isHTMLUnknownElement(node)) {
                node.remove();
            } else {
                this.removeUnknownElement(node);
            }
        }
    }

    removeUnwantedElementsFromContentElement(content) {
        util.removeElements(content.querySelectorAll("div.box-ads"));
        this.removeUnknownElement(content);
        super.removeUnwantedElementsFromContentElement(content);
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.fiction-info span.tags .label")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".detail-post h2");
    }

    extractAuthor(dom) {
        return dom.querySelector(".author a")?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".m-desc .inner")];
    }
}

================================================
FILE: plugin/js/parsers/ReadnovelfullorgParser.js
================================================

"use strict";

parserFactory.register("readnovelfull.org", () => new ReadnovelfullorgParser());

class ReadnovelfullorgParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let url = new URL(dom.baseURI);
        let tocUrl = `https://${url.hostname}/api/novels${url.pathname}/chapters?source=detail`;
        let html = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        return [...html.querySelectorAll("ul.chapter-list a")]
            .map(this.linkToChapter)
            .reverse();
    }

    linkToChapter(link) {
        return {
            sourceUrl:  link.href,
            title: link.querySelector(".chapter-title").textContent
        };
    }

    findContent(dom) {
        return dom.querySelector(".content-inner");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return [...dom.querySelectorAll(".breadcrumbs-item")].pop();
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.img-cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.section-body p")];
    }
}

================================================
FILE: plugin/js/parsers/ReadNovelFullParser.js
================================================

"use strict";

parserFactory.register("readnovelfull.com", () => new ReadNovelFullParser());

class ReadNovelFullParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = ReadNovelFullParser.extractChapterList(dom);
        if (0 < chapters.length) {
            return Promise.resolve(chapters);
        }
        return ReadNovelFullParser.fetchChapterList(dom);
    }

    static fetchChapterList(dom) {
        let novelId = dom.querySelector("div#rating").getAttribute("data-novel-id");
        let url = `https://readnovelfull.com/ajax/chapter-archive?novelId=${novelId}`;
        return HttpClient.wrapFetch(url).then(function(xhr) {
            return ReadNovelFullParser.extractChapterList(xhr.responseXML);
        });
    }

    static extractChapterList(dom) {
        return [...dom.querySelectorAll("ul.list-chapter a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#chr-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("ul.info li:nth-of-type(2) a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("a.chr-title").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc-text")];
    }

}

================================================
FILE: plugin/js/parsers/ReadnovelmtlParser.js
================================================

"use strict";

parserFactory.register("readnovelmtl.com", () => new ReadnovelmtlParser());

class ReadnovelmtlParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".accordion");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".card-body");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".mb-4 p")];
    }
}

================================================
FILE: plugin/js/parsers/ReadwnParser.js
================================================

"use strict";

parserFactory.register("fannovel.com", () => new ReadwnParser());
parserFactory.register("fannovels.com", () => new ReadwnParser());
parserFactory.register("fansmtl.com", () => new ReadwnParser());
parserFactory.register("fanmtl.com", () => new ReadwnParser());
parserFactory.register("novelmt.com", () => new ReadwnParser());
parserFactory.register("novelmtl.com", () => new ReadwnParser());
parserFactory.register("readwn.com", () => new ReadwnParser());
parserFactory.register("wuxiabee.com", () => new ReadwnParser());
parserFactory.register("wuxiabee.net", () => new ReadwnParser());
parserFactory.register("wuxiabee.org", () => new ReadwnParser());
parserFactory.register("wuxiafox.com", () => new ReadwnParser());
parserFactory.register("wuxiago.com", () => new ReadwnParser());
parserFactory.register("wuxiahere.com", () => new ReadwnParser());
parserFactory.register("wuxiahub.com", () => new ReadwnParser());
parserFactory.register("wuxiamtl.com", () => new ReadwnParser());
parserFactory.register("wuxiaone.com", () => new ReadwnParser());
parserFactory.register("wuxiap.com", () => new ReadwnParser());
//dead url
parserFactory.register("wuxiapub.com", () => new ReadwnParser());
parserFactory.register("wuxiaspot.com", () => new ReadwnParser());
parserFactory.register("wuxiar.com", () => new ReadwnParser());
parserFactory.register("wuxiau.com", () => new ReadwnParser());
parserFactory.register("wuxiazone.com", () => new ReadwnParser());

parserFactory.registerRule(
    (url, dom) => ReadwnParser.isReadwn(dom) * 0.8,
    () => new ReadwnParser()
);

class ReadwnParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 3000;
    }

    static isReadwn(dom) {
        return (dom.querySelector(ReadwnParser.CoverSelector) !== null)
            && (dom.querySelector(ReadwnParser.AuthorSelector) !== null);
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            ReadwnParser.extractPartialChapterList,
            ReadwnParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static getUrlsOfTocPages(dom) {
        let tocLinks = [...dom.querySelectorAll("ul.pagination li a")]
            .map(l => new URL(l.href))
            .filter(l => l.search.includes("page"));
        let pageIds = tocLinks.map(l => parseInt(l.searchParams.get("page")));
        let maxPage = Math.max(...pageIds);
        let baseUrl = tocLinks[0];
        let urls = [];
        for (let i = 1; i <= maxPage; ++i) {
            let params = baseUrl.searchParams;
            params.set("page", i);
            baseUrl.search = params.toString();
            urls.push(baseUrl.href);
        }
        return urls;
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.chapter-list a")]
            .map(link => ({
                sourceUrl:  link.href,
                title: ReadwnParser.makeTitle(link)
            }));
    }

    static makeTitle(link) {
        let num = link.querySelector(".chapter-no").textContent.trim();
        let title = link.querySelector(".chapter-title").textContent.trim();
        return title.includes(num)
            ? title
            : num + ": " + title;
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.main-head h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(ReadwnParser.AuthorSelector);
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".adsbox");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ReadwnParser.CoverSelector);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".summary .content")];
    }
}

ReadwnParser.CoverSelector = "figure.cover";
ReadwnParser.AuthorSelector = "span[itemprop='author']";

================================================
FILE: plugin/js/parsers/RebirthOnline.js
================================================

"use strict";

parserFactory.register("www.rebirth.online", () => new RebirthOnlineParser());

class RebirthOnlineParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.table_of_content");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector(".entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title a");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-title");
    }

    customRawDomToContentStep(webPage, content) {
        const styles = Array.from(webPage.rawDom.querySelectorAll("head style")).filter(s => s.textContent.trim());
        const classes = [];
        styles.forEach(s => {
            const re = /(\.[a-zA-Z0-9]+)/g;
            const t = s.textContent;
            if (!~t.indexOf("-999")) return;
            let c;
            while ((c = re.exec(t)) != null) {
                classes.push(...c);
            }
        });
        classes.filter((v,i,a) => a.indexOf(v)===i).forEach(c => {
            content.querySelectorAll(c).forEach(n => n.remove());
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".entry-title, div.entry-content p")];
    }
}

================================================
FILE: plugin/js/parsers/RedditParser.js
================================================

"use strict";

parserFactory.register("reddit.com", () => new RedditParser());

class RedditParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.wiki a")]
            .filter(RedditParser.IsChapterLink)
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return RedditParser.getPost(dom)?.querySelector("[slot='text-body']");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".toc a");
    }

    static IsChapterLink(link) {
        let pathname = new URL(link.href).pathname;
        return pathname.startsWith("/r/HFY/comments/");
    }

    static getPost(dom) {
        return dom.querySelector("main shreddit-post");
    }

    findChapterTitle(dom) {
        return RedditParser.getPost(dom).querySelector("h1");
    }
}

================================================
FILE: plugin/js/parsers/ReLibraryParser.js
================================================

"use strict";

parserFactory.register("re-library.com", () => new ReLibraryParser());

class ReLibraryParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.su-accordion div.su-spoiler-content li a:not(:has(>span.rl-unlock-text))")]
            .map(a => util.hyperLinkToChapter(a));
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#synopsis+div div.su-box-content")];
    }
}

================================================
FILE: plugin/js/parsers/RequiemtlsParser.js
================================================

"use strict";

parserFactory.register("requiemtls.com", () => new RequiemtlsParser());

class RequiemtlsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let table = [...dom.querySelectorAll("div.eplisterfull a")];
        let chapters = table.map(a => ({
            sourceUrl: a.href, 
            title: a.querySelector(".epl-num").textContent +" "+ a.querySelector(".epl-title").textContent
        }));
        return chapters.reverse();
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.info-content .genxed a")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.entry-content").textContent.trim();
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("div.thumbook img.ts-post-image")?.src ?? null;
    }

    async fetchChapter(url) {
        let site = (await HttpClient.wrapFetch(url)).responseXML;
        return this.buildChapter(site, url);
    }

    buildChapter(dom, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = dom.querySelector(".entry-title").textContent;
        newDoc.content.appendChild(title);
        let divret = newDoc.dom.createElement("div");
        let content = dom.querySelector(".entry-content");
        for (let n of [...content.childNodes]) {
            divret.appendChild(n);
        }
        let regex = new RegExp(/requiem_tnr_.*?(,|")/, "s");
        let font = dom.querySelector(".entry-content").outerHTML.match(regex)?.[0];
        font = font.replaceAll("\n", "").replaceAll("'", "").replaceAll(" ", "").slice(0,-1);
        divret.style.fontFamily = font;
        newDoc.content.appendChild(divret);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/RoyalRoadParser.js
================================================

/*
  Parses files on <www.royalroadl.com>
*/
"use strict";

parserFactory.register("royalroadl.com", () => new RoyalRoadParser());
parserFactory.register("royalroad.com", () => new RoyalRoadParser());

class RoyalRoadParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        // Page in browser has links reduced to "Number of links to show"
        // Fetch new page to get all chapter links.
        let tocHtml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let table = tocHtml.querySelector("table#chapters");
        return util.hyperlinksToChapterList(table);
    }

    // find the node(s) holding the story content
    findContent(dom) {
        let content = util.getElement(dom, "div", 
            e => (e.className === "portlet-body") &&
            (e.querySelector("div.chapter-inner") !== null)
        );
        return content || dom.querySelector(".page-content-wrapper");
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    preprocessRawDom(webPageDom) { 
        this.removeWatermarks(webPageDom);
        this.removeImgTagsWithNoSrc(webPageDom);
        this.tagAuthorNotesBySelector(webPageDom, "div.author-note-portlet");

        let re_cnRandomClass = new RegExp("^cn[A-Z][a-zA-Z0-9]{41}$");
        webPageDom.querySelectorAll("p").forEach(element =>
        {
            let className = Array.from(element.classList).filter(item => re_cnRandomClass.test(item))[0];
            if (className)
            {
                element.classList.remove(className);
            }
        }
        );
    }

    //watermarks are regular <p> elements set to "display: none" by internal css
    removeWatermarks(webPageDom) {
        let internalStyles = [...webPageDom.querySelectorAll("style")]
            .map(style => style.sheet?.rules);
        let allCssRules = [];
        for (let ruleList of internalStyles) {
            for (let rule of ruleList) {
                allCssRules.push(rule);
            }
        }
        for (let rule of allCssRules.filter(s => s.style?.display == "none")) {
            webPageDom.querySelector(rule.selectorText)?.remove();
        }        
    }

    removeUnwantedElementsFromContentElement(content) {
        // only keep the <div class="chapter-inner" elements of content
        for (let i = content.childElementCount - 1; 0 <= i; --i) {
            let child = content.children[i];
            if (!this.isWantedElement(child)) {
                child.remove();
            }
        }
        this.makeHiddenElementsVisible(content);

        super.removeUnwantedElementsFromContentElement(content);
    }

    isWantedElement(element) {
        let tagName = element.tagName.toLowerCase();
        let className = element.className;
        return (tagName === "h1") || 
            ((tagName === "div") && 
                (className.startsWith("chapter-inner") ||
                className.includes("author-note-portlet") ||
                className.includes("page-content"))
            );
    }

    makeHiddenElementsVisible(content) {
        [...content.querySelectorAll("div")]
            .filter(e => (e.style.display === "none"))
            .forEach(e => e.removeAttribute("style"));
    }

    removeNextAndPreviousChapterHyperlinks(webPage, content) {
        util.removeElements(content.querySelectorAll("a[href*='www.royalroadl.com']"));
        RoyalRoadParser.removeOlderChapterNavJunk(content);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.fic-header div.col h1");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("div.fic-header h4 span a");
        return author?.textContent?.trim() ?? super.extractAuthor(dom);
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div.fiction-info span.tags .label")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.fiction-info div.description").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1") ||
            dom.querySelector("h2");
    }

    static removeOlderChapterNavJunk(content) {
        // some older chapters have next chapter & previous chapter links seperated by string "<-->"
        for (let node of util.iterateElements(content, 
            n => (n.textContent.trim() === "<-->"),
            NodeFilter.SHOW_TEXT)) {
            node.remove();
        }
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img.thumbnail")?.src ?? null;
    }

    removeImgTagsWithNoSrc(webPageDom) {
        [...webPageDom.querySelectorAll("img")]
            .filter(i => util.isNullOrEmpty(i.src))
            .forEach(i => i.remove());
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.fic-title, div.fiction-info div.portlet.row")];
    }
}

================================================
FILE: plugin/js/parsers/RtdMoeParser.js
================================================

"use strict";

parserFactory.register("rtd.moe", () => new RtdMoeParser());

class RtdMoeParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = this.findContent(dom);
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.wp-post-navigation, div.tags, table#amazon-polly-audio-table");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }
}

================================================
FILE: plugin/js/parsers/RtenzoParser.js
================================================

"use strict";

parserFactory.register("rtenzo.net", () => new RtenzoParser());

class RtenzoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll(".entry-content a")]
            .filter(a => a.querySelector("img") != null);
        return links.map(this.linkToChapter);
    }
    
    linkToChapter(link) {
        let path = new URL(link.href).pathname.split("/");
        let title = path[path.length - 2].replace(/-/g, " ");
        return {
            sourceUrl:  link.href,
            title: title
        };
    }

    findContent(dom) {
        return dom.querySelector(".entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }
}

================================================
FILE: plugin/js/parsers/RubymaybetranslationsParser.js
================================================

"use strict";

parserFactory.register("rubymaybetranslations.com", () => new RubymaybetranslationsParser());

class RubymaybetranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("details a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".nv-page-title h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        return util.moveIfParent(link, "p");    
    }

    findCoverImageUrl() {
        return null;
    }

    preprocessRawDom(webPageDom) {
        util.removeChildElementsMatchingSelector(webPageDom, "#comments");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".entry-content > p")];
    }
}

================================================
FILE: plugin/js/parsers/RulateParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("tl.rulate.ru", () => new RulateParser());

class RulateParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let rows = dom.querySelectorAll(".chapter_row");
        rows = [...rows].filter(row => !row.querySelector("[data-price]"));
        return rows.map(row => util.hyperLinkToChapter(row.querySelector(".t a")));
    }

    findContent(dom) {
        return dom.querySelector(".content-text");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = util.getElement(dom, "strong", e => e.textContent === "Автор:");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.nextElementSibling.textContent;
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractDescription(dom) {
        return dom.querySelector("meta[property=\"ranobe:description\"]").getAttribute("content");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#slick-slide00") || util.getFirstImgSrc(dom, ".slick");
    }

    addTitleToContent(webPage, content) {
        let h2 = webPage.rawDom.createElement("h2");
        h2.innerText = webPage.title.trim();
        content.prepend(h2);
    }
}

================================================
FILE: plugin/js/parsers/RuversParser.js
================================================

"use strict";

parserFactory.register("ruvers.ru", () => new RuversParser());

class RuversParser extends Parser {
    constructor() {
        super();
        this.ChacheChapterTitle = new Map();
    }

    async getChapterUrls(dom) {
        let tocHtml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let idcontainer = tocHtml.querySelector("books-chapters-list");
        // eslint-disable-next-line
        let regex = new RegExp("book-id=\"[0-9]+\"");
        let id = idcontainer.outerHTML.match(regex)?.[0].slice(9,-1);
        let bookinfo = (await HttpClient.fetchJson("https://ruvers.ru/api/books/"+id+"/chapters/all")).json;
        return bookinfo.data.map(a => ({
            sourceUrl: "https://ruvers.ru/"+a.book_slug+"/"+a.id, 
            title: a.full_name,
            isIncludeable: a.is_free==true
        }));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".book_inner img")?.src ?? null;
    }

    extractDescription(dom) {
        return dom.querySelector("div.book_description").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.book_inner, div.book_description, div.book_information")];
    }

    fixUnicodeString(wronglyEscaped) {
        return wronglyEscaped.replace(/\\u([\da-fA-F]{4})/g, (match, hex) => {
            return String.fromCharCode(parseInt(hex, 16));
        });
    }
    
    async fetchChapter(url) {
        if (this.ChacheChapterTitle.size == 0) {
            let pagesToFetch = [...this.state.webPages.values()].filter(c => c.isIncludeable);
            pagesToFetch.map(a => (this.ChacheChapterTitle.set(a.sourceUrl, a.title)));
        }
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let textcontainer = dom.querySelector("books-chapters-text-component");
        // eslint-disable-next-line
        let regex = new RegExp("text=\".*?\"");
        let text = textcontainer.outerHTML.match(regex)?.[0].slice(12,-7);
        text = text.replaceAll("\\/", "/");
        text = this.fixUnicodeString(text);
        return this.buildChapter(text, url);
    }

    buildChapter(chapcontent, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = this.ChacheChapterTitle.get(url);
        newDoc.content.appendChild(title);
        let content = util.sanitize(chapcontent);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/SangtacvietParser.js
================================================

"use strict";

parserFactory.register("sangtacviet.com", () => new SangtacvietParser());
parserFactory.register("sangtacviet.vip", () => new SangtacvietParser());

class SangtacvietParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 9000;
    }

    async getChapterUrls(dom) {
        let hostname = new URL(dom.baseURI).hostname;
        let rule = 
        [{
            "id": 1,
            "priority": 1,
            "action": {
                "type": "modifyHeaders",
                "requestHeaders": [{ "header": "referer", "operation": "set", "value": "https://"+hostname}]
            },
            "condition": { "urlFilter" : hostname}
        }];
        await HttpClient.setDeclarativeNetRequestRules(rule);
        let leaves = dom.baseURI.split("/").filter(a => a != "");
        let id = leaves[leaves.length - 1];
        let provider = leaves[leaves.length - 3];

        let fetchUrl = "https://"+hostname+"/index.php?ngmar=chapterlist&h="+provider+"&bookid="+id+"&sajax=getchapterlist";
        
        let chaptersjson = (await HttpClient.fetchJson(fetchUrl)).json;

        let temp = chaptersjson.data.split("-//-");
        let onechaptdata = temp.map(a => a.split("-/-"));
        let chapters = onechaptdata.map(a => ({
            sourceUrl: "https://"+hostname+"/truyen/"+provider+"/1/"+id+"/"+a[1], 
            title: a[2].trim(),
            isIncludeable: (a[3] == null)
        }));
        return chapters;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1#book_name2").textContent;
    }

    extractAuthor(dom) {
        return dom.querySelector(".cap h2").textContent;
    }

    extractDescription(dom) {
        return dom.querySelector("#book-sumary").textContent.trim();
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("center img")?.src ?? null;
    }

    async fetchChapter(url) {
        let header = {"Content-Type": "application/x-www-form-urlencoded"};
        let options = {
            headers: header,
            parser: this
        };
        let restUrl = this.toRestUrl(url);
        let json = (await HttpClient.fetchJson(restUrl, options)).json;
        return this.buildChapter(json, url);
    }
    
    isCustomError(response) {
        if (response.json.code != "0") {
            return true;
        }
        return false;
    }

    setCustomErrorResponse(url, wrapOptions, checkedresponse) {
        let newresp = {};
        newresp.url = url;
        newresp.wrapOptions = wrapOptions;
        newresp.response = {};
        newresp.response.url = this.RestToUrl(checkedresponse.response.url);
        newresp.response.status = 403;
        return newresp;
    }

    RestToUrl(url) {
        let params = new URL(url).searchParams;
        let chapter = params.get("c");
        let id = params.get("bookid");
        let provider = params.get("h");
        let hostname = new URL(url).hostname;
        return "https://"+hostname+"/truyen/"+provider+"/1/"+id+"/"+chapter+"/";
    }

    toRestUrl(url) {
        let leaves = url.split("/").filter(a => a != "");
        let chapter = leaves[leaves.length - 1];
        let id = leaves[leaves.length - 2];
        let provider = leaves[leaves.length - 4];
        let hostname = new URL(url).hostname;
        let ret = "https://"+hostname+"/index.php?bookid="+id+"&h="+provider+"&c="+chapter+"&ngmar=readc&sajax=readchapter&sty=1&exts=";
        return ret;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = json.chaptername;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.data);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/ScribblehubParser.js
================================================

"use strict";

parserFactory.register("scribblehub.com", () => new ScribblehubParser());

class ScribblehubParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 5000;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let baseUrl = dom.baseURI;
        let nextTocIndex = 1;
        let numChapters = parseInt(dom.querySelector("span.cnt_toc").textContent);
        let nextTocPageUrl = function(_dom, chapters, lastFetch) {
            // site has bug, sometimes, won't return chapters, so 
            // don't loop forever when this happens
            return ((chapters.length < numChapters) && (0 < lastFetch.length))
                ? `${baseUrl}?toc=${++nextTocIndex}`
                : null;
        };
        let saveThrottle = this.minimumThrottle;
        this.minimumThrottle = 0;
        let chapters = (await this.walkTocPages(dom,
            ScribblehubParser.getChapterUrlsFromTocPage,
            nextTocPageUrl,
            chapterUrlsUI
        )).reverse();
        this.minimumThrottle = saveThrottle;
        return chapters;
    }

    static getChapterUrlsFromTocPage(dom) {
        return [...dom.querySelectorAll("a.toc_a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.fic_row, div#chp_raw");
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.fic_title");
    }

    extractAuthor(dom) {
        let author = dom.querySelector("span.auth_name_fic");
        return (author === null) ? super.extractAuthor(dom) : author.textContent;
    }
    
    extractSubject(dom) {
        let selector = "[property='genre']";
        if (!document.getElementById("lesstagsCheckbox").checked) {
            selector += ", .stag";
        }
        let tags = [...dom.querySelectorAll(selector)];
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return this.extractDescriptionInternal(dom)?.innerText?.trim();
    }
    // unwrap the description from the readmore that you may get on mobile
    extractDescriptionInternal(dom) {
        let desc = dom.querySelector(".wi_fic_desc");
        if (desc != null) {
            desc.querySelectorAll(".dots, .morelink").forEach(e => e.remove());
            desc.querySelectorAll(".testhide").forEach(e => e.replaceWith(...e.childNodes));
        }

        return desc;
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.chapter-title").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.fic_image");
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);

        this.tagAuthorNotesBySelector(content, ".wi_authornotes, .wi_news");

        // spoilers
        for (let element of content.querySelectorAll(".sp-wrap")) {
            element.querySelector(".sp-body>.spdiv")?.remove();

            let details = webPageDom.createElement("details");
            let summary = webPageDom.createElement("summary");
            summary.append(...element.querySelector(".sp-head").childNodes);
            details.append(summary);
            details.append(...element.querySelector(".sp-body").childNodes);

            element.replaceWith(details);
        }

        // anouncements
        for (let element of content.querySelectorAll(".wi_news_title")) {
            element.setAttribute("style", "font-weight: bold");
            element.querySelector(".fa-exclamation-triangle").replaceWith("⚠");
        }

        // author notes
        for (let element of content.querySelectorAll(".p-avatar-wrap")) {
            element.remove();
        }

    }

    getInformationEpubItemChildNodes(dom) {
        function cleanTag(tag, index, array) {
            let out = tag.ownerDocument.createElement("a");
            out.setAttribute("href", tag.getAttribute("href"));
            out.innerText = tag.innerText;
            return index < array.length -1 ? [out, ", "] : [out];
        }

        let info = [];

        info.push(dom.createElement("div").innerHTML = "<p><b>Synopsis</b></p>");
        let synopsis = this.extractDescriptionInternal(dom);
        if (synopsis) {
            info.push(...synopsis.childNodes);
        }

        let genre = dom.querySelectorAll(".wi_fic_genre a.fic_genre");
        if (genre.length > 0) {
            info.push(dom.createElement("div").innerHTML = "<p><b>Genre</b></p>");
            info.push(...[...genre].flatMap(cleanTag));
        }

        let fandom = dom.querySelectorAll(".wi_fic_genre a.stag");
        if (fandom.length > 0) {
            info.push(dom.createElement("div").innerHTML = "<p><b>Fandom</b></p>");
            info.push(...[...fandom].flatMap(cleanTag));
        }

        let tags = dom.querySelectorAll(".wi_fic_showtags a.stag");
        if (tags.length > 0) {
            info.push(dom.createElement("div").innerHTML = "<p><b>Tags</b></p>");
            info.push(...[...tags].flatMap(cleanTag));
        }
  
        return info;
    }
}

================================================
FILE: plugin/js/parsers/SecondlifetranslationsParser.js
================================================

"use strict";

parserFactory.register("secondlifetranslations.com", () => new SecondlifetranslationsParser());

class SecondlifetranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("button.accordion").nextElementSibling;
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.entry-title");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("img.novelcover");
        return img === null ? null : img.src;
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        util.removeChildElementsMatchingSelector(content, ".code-block");
        let footnotes = [...content.querySelectorAll("span.modern-footnotes-footnote__note")];
        this.moveFootnotes(webPageDom, content, footnotes);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-entry-content")];
    }
}

================================================
FILE: plugin/js/parsers/SemprotParser.js
================================================

"use strict";

parserFactory.register("semprot.com", () => new SemprotParser());

class SemprotParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        SemprotParser.author = this.findContent(dom)
            .querySelector("article.message")
            .getAttribute("data-Author");
        let baseUri = dom.baseURI;
        let chapters = [this.makeChapter(baseUri, "1")];
        let max = this.lastThreadPageNum(dom);
        for (let i = 2; i <= max; ++i) {
            chapters.push(this.makeChapter(baseUri, i));
        }
        return chapters;
    }

    lastThreadPageNum(dom) {
        let pageUrls = [...dom.querySelectorAll("li.pageNav-page")];
        return (0 < pageUrls.length)
            ? parseInt(pageUrls.pop().textContent)
            : 0;
    }

    makeChapter(baseUrl, pageNum) {
        return {
            sourceUrl:  `${baseUrl}page-${pageNum}`,
            title: `${pageNum}`
        };
    }

    findContent(dom) {
        return [...dom.querySelectorAll("div.block-container")]
            .filter(b => b.querySelector("article"))
            .pop();
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".p-title-value");
    }

    extractAuthor(dom) {
        let authorLabel = SemprotParser.author;
        return (authorLabel == null) ? super.extractAuthor(dom) : authorLabel;
    }

    preprocessRawDom(webPageDom) {
        let articles = [...webPageDom.querySelectorAll("article.message")];
        for (let article of articles) {
            if (article.getAttribute("data-author") !== SemprotParser.author) {
                article.remove();
            } else {
                let body = article.querySelector("article.message-body");
                util.removeChildElementsMatchingSelector(body, ".bbCodeBlock-expandLink, .semprotnenenmontok_sq");
                util.resolveLazyLoadedImages(body, "img");
                article.replaceWith(body);
            }
        }
    }
}

================================================
FILE: plugin/js/parsers/SexStoriesParser.js
================================================

"use strict";

parserFactory.register("sexstories.com", () => new SexStoriesParser());

class SexStoriesParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("tbody");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#story_center_panel");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("#content h3:nth-of-type(2)");
    }

    extractAuthor(dom) {
        return dom.querySelector("h3.notice div.left").textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "button, span.title_link, .top_info," +
            " .story_date, .fontSizer, div.block_panel .story_info, #vote_details_div, #rating, #addfavorite," +
            " .title_panel, #bottom_panel, .count_comments, .pager, #comments");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/ShanghaifantasyParser.js
================================================

"use strict";

parserFactory.register("shanghaifantasy.com", () => new ShanghaifantasyParser());

class ShanghaifantasyParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = this.buildTocUrl(dom);
        let json = (await HttpClient.fetchJson(tocUrl)).json;
        return this.buildChapterUrls(json);
    }

    buildTocUrl(dom) {
        let category = dom.querySelector("ul#chapterList")?.getAttribute("data-cat");
        return `https://shanghaifantasy.com/wp-json/fiction/v1/chapters?category=${category}&order=asc&page=1&per_page=10000`;
    }

    buildChapterUrls(json) {
        return json.map(a => ({
            title: a.title,
            sourceUrl: a.permalink 
        }));
    }

    findContent(dom) {
        let content = dom.querySelector("div.contenta");
        let childCount = content.querySelectorAll("div, p").length;
        return (childCount <= 3)
            ? dom.querySelector("body > div.flex")
            : content;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("title")?.textContent ?? null;
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".patreon1, section, nav, button, template, #comments, footer, .hideme");

        for (let e of [...element.querySelectorAll("div")]) {
            e.removeAttribute(":style");
            e.removeAttribute(":class");
            e.removeAttribute("@click.outside");
        }

        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("title")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".flex-col");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#editdescription")];
    }
}

================================================
FILE: plugin/js/parsers/ShikkakutranslationsParser.js
================================================

/*
  parses shikkakutranslations.org
*/
"use strict";

parserFactory.register( "shikkakutranslations.org", () => new ShikkakutranslationsParser());

class ShikkakutranslationsImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    isImageWrapperElement(element) {
        return ((element.tagName.toLowerCase() === "div") && element.className.startsWith("gallery-group")) ||
            super.isImageWrapperElement(element);
    }
}

//==============================================================

class ShikkakutranslationsParser extends Parser {
    constructor() {
        super(new ShikkakutranslationsImageCollector());
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.menu-header");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div#content-body div.entry");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.page-title");
    }

    removeNextAndPreviousChapterHyperlinks(webPage, element) {
        // override default, just remove all hyperlinks
        // due to links in chapters not matching links in menu.
        [...element.querySelectorAll("a")]
            .filter(l => l.querySelector("img") === null)
            .map(l => this.findParentNodeOfChapterLinkToRemoveAt(l))
            .forEach(u => u.remove());
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        return util.moveIfParent(link, "p");
    }
}

================================================
FILE: plugin/js/parsers/ShinningnoveltranslationsParser.js
================================================

"use strict";

parserFactory.register("shinningnoveltranslations.com", () => new ShinningnoveltranslationsParser());

class ShinningnoveltranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let all = [...dom.querySelectorAll(".entry-content p")];
        let chapters = [];
        let isfree = false;
        for (let i = 0; i < all.length; i++) {
            if (all[i].textContent == "Free") {
                isfree = true;
            }
            let ret = all[i].firstChild;
            if (ret?.href?.includes("shinningnoveltranslations.com")) {
                chapters.push({
                    sourceUrl: ret.href, 
                    title: ret.textContent,
                    isIncludeable: isfree
                });
            }
        }
        return chapters.reverse();
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".wp-block-post-title")?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return dom.querySelector(".wp-block-image > img")?.src ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".entry-content")];
    }

    findContent(dom) {
        return dom.querySelector(".entry-content");
    }

    removeNextAndPreviousChapterHyperlinks(webPage, content) {
        util.removeElements(content.querySelectorAll(".wp-block-columns"));
        RoyalRoadParser.removeOlderChapterNavJunk(content);
    }
}

================================================
FILE: plugin/js/parsers/ShinsoriParser.js
================================================

/*
  Template to use to create a new parser
*/
"use strict";

//dead url/ parser
parserFactory.register("shinsori.com", () => new ShinsoriParser());

class ShinsoriParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            ShinsoriParser.extractPartialChapterList,
            ShinsoriParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static getUrlsOfTocPages(dom) {
        return [...dom.querySelectorAll("ul.lcp_paginator a:not(.lcp_nextlink)")]
            .map(link => link.href);
    }

    static extractPartialChapterList(dom) {
        let lists = [...dom.querySelectorAll("ul.lcp_catlist")];
        return (0 === lists.length) 
            ? [] 
            : util.hyperlinksToChapterList(lists[lists.length - 1]);
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.section-title");
    }

    extractAuthor(dom) {
        let authorLabel = util.getElement(dom, "strong", e => e.textContent === "Author:");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.nextSibling.textContent;
    }

    removeUnwantedElementsFromContentElement(content) {
        util.removeElements(content.querySelectorAll("div.stream-item-below-post-content, div.post-bottom-meta"));
        super.removeUnwantedElementsFromContentElement(content);
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("div.entry-header");
        if (title != null) {
            let junk = title.querySelector("h5");
            if (junk !=  null) {
                junk.remove();
            }
            return title;
        }
        return dom.querySelector("h1");
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        return util.moveIfParent(link, "p");    
    }
    
    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "li.post-item");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.block-custom-content, div.first-half-box")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "a");
    }
}

================================================
FILE: plugin/js/parsers/ShintranslationsParser.js
================================================

"use strict";

parserFactory.register("shintranslations.com", () => new ShintranslationsParser());

class ShintranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.text-formatting a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.content-area");
    }
}

================================================
FILE: plugin/js/parsers/ShirokunsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("shirokuns.com", () => new ShirokunsParser());

class ShirokunsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.blog-post li a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.main h1");
    }

    preprocessRawDom(chapterDom) {
        util.removeChildElementsMatchingSelector(chapterDom, "p.author, div.col-md-12 img");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("article p img");
        return img === null ? null : img.src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#editdescription")];
    }
}

================================================
FILE: plugin/js/parsers/ShitouxsParser.js
================================================

"use strict";

parserFactory.register("shitouxs.com", () => new ShitouxsParser());

class ShitouxsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#listsss");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#TextContent");
    }

    findChapterTitle(dom) {
        return dom.querySelector("#mlfy_main_text > h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".bookcover");
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".red");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".bookintromore")];
    }
}

================================================
FILE: plugin/js/parsers/ShmtranslationsParser.js
================================================

"use strict";

parserFactory.register("shmtranslations.com", () => new ShmtranslationsParser());

class ShmtranslationsParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    findContent(dom) {
        let content = super.findContent(dom);
        if (content !== null) {
            return content;
        }

        // site changed 2019-10-27.  Look for new content and clean
        content = dom.querySelector("article");
        if (content !== null) {
            ShmtranslationsParser.cleanLaterContent(content);
        }
        return content;
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }

    static cleanLaterContent(content) {
        let junk = [...content.querySelectorAll("span[style='color: #ffffff;']")]
            .map(s => s.parentElement)
            .filter(p => p.tagName.toLowerCase() === "p")
            .concat([...content.querySelectorAll("footer, div.awac-wrapper")]);
        util.removeElements(junk);
    }
}

================================================
FILE: plugin/js/parsers/ShubaowbParser.js
================================================

"use strict";

parserFactory.register("shubaowb.com", () => new ShubaowbParser());

class ShubaowbParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages([],
            this.chaptersFromDom,
            urlsOfTocPages,
            chapterUrlsUI
        ));
    }

    chaptersFromDom(dom) {
        return [...dom.querySelectorAll(".book_last dd a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    getUrlsOfTocPages(dom) {
        let optionToUrl = (o) => {
            let v = o.value;
            if (!v.startsWith("/novel")) {
                v = "/novel" + v;
            }
            return "https://shubaowb.com" + v; 
        };

        let listpage = dom.querySelector(".listpage");
        return [...listpage.querySelectorAll("option")]
            .map(optionToUrl);
    }    

    findContent(dom) {
        return dom.querySelector("#chaptercontent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("span.title1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("span.title1");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".book_about")];
    }
}

================================================
FILE: plugin/js/parsers/ShubaowParser.js
================================================

"use strict";

parserFactory.register("shubaow.net", () => new ShubaowParser());

class ShubaowParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("div#list dd a")];
        return this.removeDuplicates(links)
            .map(a => util.hyperLinkToChapter(a));
    }

    removeDuplicates(links) {
        let unique = new Set();
        let dedup = [];
        while (0 < links.length) {
            let link = links.pop();
            if (!unique.has(link.href)) {
                dedup.push(link);
                unique.add(link.href);
            }
        }
        return dedup.reverse();
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div#info h1");
    }

    extractLanguage() {
        return "cn";
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.bookname h1").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#fmimg");
    }

    async fetchChapter(url) {
        return (await HttpClient.wrapFetch(url, this.makeOptions())).responseXML;
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gbk")
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#intro")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script, .adsbygoogle");
    }
}

================================================
FILE: plugin/js/parsers/Shw5Parser.js
================================================

"use strict";

parserFactory.register("shw5.cc", () => new Shw5Parser());
parserFactory.register("bqka.cc", () => new Shw5Parser());

class Shw5Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.listmain");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#chaptercontent");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "a.ll, a.rr");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".intro")];
    }
}

================================================
FILE: plugin/js/parsers/SitesGoogleParser.js
================================================

"use strict";

parserFactory.register("sites.google.com", () => new SitesGoogleParser());

class SitesGoogleParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul[role='navigation']");
        if (menu === null) {
            menu = this.findContent(dom);
        }
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div[role='main']");
    }
}

================================================
FILE: plugin/js/parsers/Sjks88Parser.js
================================================

"use strict";

parserFactory.register("sjks88.com", () => new Sjks88Parser());
parserFactory.register("m.sjks88.com", () => new Sjks88Parser());

class Sjks88Parser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    async fetchChapter(url) {
        let options = { makeTextDecoder: () => new TextDecoder("GB2312") };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc")];
    }
}

================================================
FILE: plugin/js/parsers/SjuukanshuParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("sj.uukanshu.com", () => new SjuukanshuParser());

class SjuukanshuParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#listCont .ml-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#bookContent");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.bookname");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h3");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".book-info");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc")];
    }
}

================================================
FILE: plugin/js/parsers/SkydemonorderParser.js
================================================

"use strict";

parserFactory.register("skydemonorder.com", () => new SkydemonorderParser());

class SkydemonorderParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div[x-show='expanded'] a")]
            .map(a => this.hyperLinkToChapter(a))
            .reverse();
    }

    hyperLinkToChapter(link) {
        let episode = link.parentElement.parentElement
            .querySelector("[x-text='chapter.episode']")
            ?.textContent;
        let titleText = link.querySelector("span").textContent.trim();

        return {
            sourceUrl: link.href,
            title: `Episode ${episode}: ${titleText}`,
        };
    }

    findContent(dom) {
        return dom.querySelector("[wire\\:ignore]");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        let h1 = dom.querySelector("h1");
        return h1.textContent.trim() + ": " + h1.nextElementSibling.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.w-full");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".lg\\:col-span-2 .text-primary-500")];
    }
}

================================================
FILE: plugin/js/parsers/SnoutandcoParser.js
================================================

"use strict";

parserFactory.register("snoutandco.ca", () => new SnoutandcoParser());

class SnoutandcoParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.list-group");
        let chapterList = util.hyperlinksToChapterList(menu);

        // save titles to add back when fetch chapter content
        SnoutandcoParser.titles = new Map();
        chapterList.forEach(l => SnoutandcoParser.titles.set(l.sourceUrl, l.title));

        return chapterList;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1#book-title");
    }

    async fetchChapter(url) {
        let params = new URL(url).searchParams;
        let folder = params.get("folder");
        let chapter = params.get("chapter");
        let contentUrl = `https://snoutandco.ca/${folder}/chapters/${chapter}`;
        let contentText = (await HttpClient.fetchText(contentUrl));
        return this.buildChapter(contentText, url);
    }

    buildChapter(contentText, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = SnoutandcoParser.titles.get(url);
        newDoc.content.appendChild(title);
        Parser.addTextToChapterContent(newDoc, contentText);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/SnowyCodexParser.js
================================================

"use strict";

parserFactory.register("snowycodex.com", () => new SnowyCodexParser());

class SnowyCodexParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.entry-content h2");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.entry-content p")];
    }
}

================================================
FILE: plugin/js/parsers/SonakoParser.js
================================================

/*
  Parses files on sonako.org
*/
"use strict";

parserFactory.register("sonako.wikia.com", () => new SonakoParser());
parserFactory.register("sonako.fandom.com", () => new SonakoParser());

//-----------------------------------------------------------------------------
// class SonakoImageCollector  (derives from ImageCollector)
//-----------------------------------------------------------------------------

class SonakoImageCollector extends BakaTsukiImageCollector {
    constructor() {
        super();
    }

    //  Assume all images can be found on a web page with URL
    //  http://sonako.wikia.com/wiki/File:{data-image-name}
    //  where {data-image-name} is data-image-name element of the img tag.
    //
    extractWrappingUrl(element) {
        let tagName = element.tagName.toLowerCase();
        if (tagName === "a") {
            return element.href;
        }
        let link = element.querySelector("a");
        if (link !== null) {
            return link.href;
        }
        let img = (tagName === "img") ? element : element.querySelector("img");
        let dataImageName = img.getAttribute("data-image-name");

        // ToDo, use utilresolveRelativeUrl() rather than string concatanation
        return (dataImageName === null) ? img.src : "http://sonako.wikia.com/wiki/File:" + dataImageName;
    }

    isImageWrapperElement(element) {
        return (element.tagName === "FIGURE") ||  super.isImageWrapperElement(element);
    }
}

//-----------------------------------------------------------------------------
// class SonakoParser
//-----------------------------------------------------------------------------

class SonakoParser extends BakaTsukiParser {
    constructor() {
        super(new SonakoImageCollector());
    }

    extractTitleImpl(dom) {
        return dom.title;
    }

    extractLanguage(dom) {   // eslint-disable-line no-unused-vars
        // ToDo find language
        return "vi-VN";
    }

    extractSeriesInfo(dom, metaInfo) {   // eslint-disable-line no-unused-vars
        // This parser does not currently support this functionality
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return dom.querySelector("div.mw-content-ltr");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeElements(element.querySelectorAll("script, " +
            "noscript, " +

        // discard table of contents (will generate one from tags later)
            "div#toc-wrapper, " +
            "a.toc-link, " +

            "a.wikia-photogallery-add, " +
            "div.print-no"
        ));
        util.removeElements(util.getElements(element, "div", e => (e.id.startsWith("INCONTENT"))));


        util.removeComments(element);
        // hyperlinks that allow editing text
        util.removeElements(element.querySelectorAll("table, span.editsection"));

        // fix source for delay loaded image tags
        util.fixDelayLoadedImages(element, "data-src");
    }
}

================================================
FILE: plugin/js/parsers/SoverseParser.js
================================================

"use strict";

parserFactory.register("soverse.com", () => new SoverseParser());

class SoverseParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("ul.chapter-list a")]
            .map(SoverseParser.linkToChapter)
            .reverse();
    }

    static linkToChapter(link) {
        link.querySelector("span.time").remove();
        return {
            sourceUrl:  link.href,
            title: link.textContent.trim()
        };        
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".single-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".pub-date, .chapter-nav, .china, #popupreport, .snpconainer, amp-selector");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".single-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".kepalanovel");
    }
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.info")];
    }
}

================================================
FILE: plugin/js/parsers/SpacebattlesParser.js
================================================

"use strict";

parserFactory.register("forums.spacebattles.com", () => new SpacebattlesParser());
//dead url
parserFactory.register("forums.sufficientvelocity.com", () => new SpacebattlesParser());
parserFactory.register("alternatehistory.com", () => new SpacebattlesParser());
//dead url
parserFactory.register("forum.questionablequesting.com", () => new SpacebattlesParser());
parserFactory.register("questionablequesting.com", () => new SpacebattlesParser());

class SpacebattlesParser extends Parser {
    constructor() {
        super();
        this.cache = new FetchCache();
        this.minimumThrottle = 50; //182 at 20
        this.expectedChapterUrl = null;
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.structItem--threadmark a")]
            .filter(this.isLinkToChapter);
        return chapters.map(a => util.hyperLinkToChapter(a));
    }

    isLinkToChapter(link) {
        return !link.querySelector("date")
            && !(new URL(link.href).pathname.startsWith("/awards/award"));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.p-title-value");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a.username");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    async fetchChapter(url) {
        let article = await this.fetchArticle(url);
        if (!article && this.expectedChapterUrl && (this.expectedChapterUrl != url)) {
            article = await this.fetchArticle(this.expectedChapterUrl);
        }
        if (article == null) {
            throw new Error(`Can not find chapter ${url}`);
        }
        this.expectedChapterUrl = this.findExpectedNextChapter(article);

        let newDoc = Parser.makeEmptyDocForContent(url);
        this.addTitleToChapter(newDoc, article);
        let content = article.querySelector("article.message-body");
        util.resolveLazyLoadedImages(content, "img.lazyload");
        newDoc.content.appendChild(content);
        return newDoc.dom;
    }

    async fetchArticle(url) {
        let fetchedDom = await this.cache.fetch(url);
        let newUrl = new URL(url);
        let id = newUrl.hash.substring(1) || newUrl.href.substring(newUrl.href.lastIndexOf("/") + 1);
        let parent = fetchedDom.querySelector(`article.hasThreadmark[data-content='${id}']`);
        if (parent === null)
        {
            parent = fetchedDom.querySelector("#" + id)?.parentElement;
        }
        return parent;
    }

    findExpectedNextChapter(article) {
        return article.querySelector("li.threadmark-nav")
            ?.querySelector("a:nth-of-type(3)")
            ?.href;
    }

    addTitleToChapter(newDoc, parent) {
        let titleElement = parent.querySelector("span.threadmarkLabel");
        if (titleElement !== null)
        {
            let title = newDoc.dom.createElement("h1");
            title.textContent = titleElement.textContent.trim();
            newDoc.content.appendChild(title);
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("article.threadmarkListingHeader-extraInfoChild")];
    }
}

================================================
FILE: plugin/js/parsers/SpiritfanfictionParser.js
================================================

"use strict";

parserFactory.register("spiritfanfiction.com", () => new SpiritfanfictionParser());

class SpiritfanfictionParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("table.listagemCapitulos");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.texto-capitulo");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.tituloPrincipal");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.tituloPrincipal");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "section.boxConteudo");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("section.boxConteudo div.texto")];
    }
}

================================================
FILE: plugin/js/parsers/SspaiParser.js
================================================

/*
  Very basic parser for sspai.com
*/
"use strict";

parserFactory.register("sspai.com", () => new SspaiParser());

class SspaiParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("body");
        return Promise.resolve(util.hyperlinksToChapterList(menu));        
    }

    findContent(dom) {
        return dom.querySelector("div.wangEditor-txt");
    }
}

================================================
FILE: plugin/js/parsers/StarlightstreamParser.js
================================================

"use strict";

parserFactory.register("starlightstream.net", () => new StarlightstreamParser());

class StarlightstreamParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("[role='list']");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("[data-id='rich-content-viewer']");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "[data-hook='buttonViewer']");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "wix-image");
    }
}

================================================
FILE: plugin/js/parsers/StellarRealmParser.js
================================================

"use strict";

parserFactory.registerDeadSite("stellarrealm.net", () => new StellarRealmParser());
parserFactory.register("brightnovels.com", () => new StellarRealmParser());

class StellarRealmParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let json = this.getJson(dom);
        this.InertiaVersion = json.version;
        let url = new URL(dom.baseURI);
        let slug = url.pathname.split("/").filter(a => a != "");
        slug = slug[slug.length-1];
        let bookinfo = (await HttpClient.fetchJson("https://brightnovels.com/series/"+slug+"/chapters?sort_order=asc")).json;
        let chapters = bookinfo.chapters.map(a => ({
            sourceUrl: "https://brightnovels.com/series/"+slug+"/"+a.slug,
            title: a.name,
            isIncludeable: ((a.price == 0) && a.is_premium != true)
        }));
        return chapters;
    }

    getJson(dom) {
        let jsondiv = dom.querySelector("#app");
        return JSON.parse(jsondiv.dataset.page);
    }

    async loadEpubMetaInfo(dom) {
        let xml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let bookinfo = this.getJson(xml);
        this.title = bookinfo.props.series?.title;
        this.tags = bookinfo.props.series.tags?.map(a => a.name);
        this.tags = this.tags.concat(bookinfo.props.series.genre?.map(a => a.name));
        let parsed = util.sanitize(bookinfo.props.series.description);
        this.description = parsed.body.textContent;
        this.img = bookinfo.props.series.cover?.path 
            ? "https://brightnovels.com/storage/"+bookinfo.props.series.cover.path
            : null;
        return;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.title;
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.img;
    }

    async fetchChapter(url) {
    /*
    alternative the this.InertiaVersion can change with time that's why the other version it is the same json
        let header = {"X-Inertia": "true", "X-Inertia-Version": this.InertiaVersion};
        let options = {
            headers: header
        };
        let json = (await HttpClient.fetchJson(url, options)).json;
    */
        let xml = (await HttpClient.wrapFetch(url)).responseXML;
        let json = this.getJson(xml).props;
        return this.buildChapter(json, url);
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        let titleText = "Chapter "+json.chapter.number;
        if (!util.isNullOrEmpty(json.chapter.title)) {
            titleText += ": " + json.chapter.title;
        }
        title.textContent = titleText;
        newDoc.content.appendChild(title);
        let content = util.sanitize(json.chapter.content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/StocxParser.js
================================================

"use strict";

parserFactory.register("sto.cx", () => new StocxParser());

class StocxParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let scripts = StocxParser.findScriptElementWithChapterInfo(dom);
        let chapters = [];
        if (0 < scripts.length) {
            let chapInfo = StocxParser.extractChapterGenInfo(scripts[0]);
            for (let i = 1; i <= chapInfo.maxPage; ++i) {
                chapters.push({
                    sourceUrl: `https://www.sto.cx/book-${chapInfo.bookId}-${i}.html`,
                    title: `${i}`
                });
            }
        }
        return Promise.resolve(chapters);
    }

    static findScriptElementWithChapterInfo(dom) {
        return [...dom.querySelectorAll("script")]
            .filter(s => s.textContent.includes(StocxParser.chapterGenTag))
            .map(s => s.textContent);
    }

    static extractChapterGenInfo(script) {
        let index = script.indexOf(StocxParser.chapterGenTag);
        let split = script.substring(index).split(",");
        return {
            bookId: parseInt(split[1]),
            maxPage: parseInt(split[2]),
        };
    }

    findContent(dom) {
        return dom.querySelector("div#BookContent");
    }

    extractLanguage() {
        return "cn";
    }

    customRawDomToContentStep(chapter, content) {
        let fix = StocxParser.getTextNodesToFixUp(content);
        for (let node of fix) {
            node.nodeValue = StocxParser.fixMangledText(node.nodeValue);
        }
    }

    static getTextNodesToFixUp(content) {
        let n = null; 
        let nodes = [];
        let walk = document.createTreeWalker(content,NodeFilter.SHOW_TEXT,null,false);
        while ((n = walk.nextNode()) !== null) {
            if (n.nodeValue.includes("%")) {
                nodes.push(n);
            }
        }
        return nodes;
    }

    static fixMangledText(text) {
        let bytes = [];
        let i = 0;
        while (i < text.length) {
            if (StocxParser.isEncodeddByte(text, i)) {
                bytes.push(StocxParser.decodeByte(text, i));
                i += 3;
            } else {
                let utf = StocxParser.getUtf8encoder().encode(text[i]);
                for (let u of utf) {
                    bytes.push(u);
                }
                ++i;
            }
        }
        return StocxParser.getUtf8decoder().decode(new Uint8Array(bytes));
    }

    static isEncodeddByte(text, index) {
        return (index + 2 < text.length)
            && (text[index] === "%")
            && (StocxParser.isHexChar(text[index + 1]))
            && (StocxParser.isHexChar(text[index + 2]));
    }

    static isHexChar(char) {
        return !isNaN(parseInt(char[0], 16));
    }

    static decodeByte(text, index) {
        return parseInt(text.substring(index + 1, index + 3), 16);
    }

    static getUtf8decoder() {
        if (StocxParser.utf8decoder === undefined) {
            StocxParser.utf8decoder = new TextDecoder("utf-8");
        }
        return StocxParser.utf8decoder;
    }

    static getUtf8encoder() {
        if (StocxParser.utf8encoder === undefined) {
            StocxParser.utf8encoder = new TextEncoder();
        }
        return StocxParser.utf8encoder;
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }
}

StocxParser.chapterGenTag = "ANP_goToPage(";

================================================
FILE: plugin/js/parsers/StorySeedlingParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("storyseedling.com", () => new StorySeedlingParser());

class StorySeedlingParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("main .grid.w-full a")]
            .map(link => this.linkToChapter(link));
    }

    linkToChapter(link) {
        let title = link.querySelector(".truncate").textContent;
        return ({
            sourceUrl:  link.href,
            title: title,
        });
    }

    findContent(dom) {
        return (
            dom.querySelector("div.prose .mb-4") || dom.querySelector("#chapter-content")
        );
    }

    populateUIImpl() {
        document.getElementById("removeAuthorNotesRow").hidden = false; 
    }

    preprocessRawDom(webPageDom) {
        let notes = webPageDom.querySelector("div.prose .mb-4:nth-of-type(2)");
        if ((notes != null) && !this.userPreferences.removeAuthorNotes.value) {
            this.tagAuthorNotes([notes]);
            this.findContent(webPageDom).appendChild(notes);
        }
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.leading-7 a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".truncate");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div[x-data='']");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.order-2.mb-4")];
    }

}

================================================
FILE: plugin/js/parsers/SweekParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("sweek.com", () => new SweekParser());

class SweekParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let firstUrl = this.findReadUrl(dom);
        let split = firstUrl.split("/");
        let device = split.pop();
        let storyId = split.pop();
        let payload = {
            "operationName":null,
            "variables": {"storyId":storyId,"storyDevice":device},
            "query":"query ($storyId: Int!, $storyDevice: String!) {\n  getChapters(storyId: $storyId, storyDevice: $storyDevice) {\n    ok\n    errorCode\n    chapters {\n      id\n      device\n      title\n      __typename\n    }\n    __typename\n  }\n}\n"
        };
        let options = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
            },
            credentials: "include",
            body: JSON.stringify(payload)
        };
        let json = (await HttpClient.fetchJson("https://sweek.com/graphql", options)).json;
        let chapters = json.data.getChapters.chapters;
        return chapters.map(c => this.decodeTocJson(firstUrl, c));
    }

    decodeTocJson(firstUrl, json) {
        return ({
            sourceUrl:  firstUrl + "/" + json.id + "/" + json.device,
            title: json.title,
        });
    }

    findReadUrl(dom) {
        let link = dom.querySelector("div.buttonContainer-lMpB3JWLYQC5iY4p4kmh5 a");
        return link.href;
    }

    findContent(dom) {
        return dom.querySelector("div.readingScreenContent-1DcfKpNGB8ryskQn_0vAkM");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".actionBar-sVi43NPxX1SfatEP5xyAO");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("img[alt='Story cover']");
        return img === null ? null : img.src;
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("p")];
    }
}

================================================
FILE: plugin/js/parsers/SyosetuParser.js
================================================

"use strict";

parserFactory.register("ncode.syosetu.com", () => new SyosetuParser());
parserFactory.register("novel18.syosetu.com", () => new SyosetuParser());

class SyosetuParser extends Parser {
    constructor() {
        super();
        this.infoPageDom = null;
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            this.extractPartialChapterList,
            this.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    getUrlsOfTocPages(dom) {
        let lastPage = dom.querySelector("a.c-pager__item--last");
        let urls = [];
        if (lastPage) {
            const lastPageNumber = parseInt(lastPage.href.split("?p=")[1]);
            const baseUrl = lastPage.href.substring(0, lastPage.href.lastIndexOf("?p="));
            for (let i = 2; i <= lastPageNumber; i++) {
                urls.push(`${baseUrl}?p=${i}`);
            }
        }
        return urls;
    }

    extractPartialChapterList(dom) {
        let chapterList = dom.querySelector("div.index_box") || dom.querySelector("div.p-eplist");
        if (!chapterList) {
            return [];
        }
        let chapters = [];
        let arcTitle = null;
        for (let element of chapterList.querySelectorAll(
            ".p-eplist__chapter-title, a"
        )) {
            if (element.classList?.contains("p-eplist__chapter-title")) {
                arcTitle = element.textContent.trim();
                continue;
            }
            let chapter = util.hyperLinkToChapter(element);
            if (arcTitle) {
                chapter.newArc = arcTitle;
                arcTitle = null;
            }
            chapters.push(chapter);
        }
        return chapters;
    }

    findContent(dom) {
        return dom.querySelector("div.p-novel__body");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".p-novel__title");
    }

    extractAuthor(dom) {
        const authorDiv = dom.querySelector("div.p-novel__author");
        if (authorDiv) {
            const authorText = authorDiv.textContent.trim().replace(/^作者：/, "");
            return authorDiv.querySelector("a")?.textContent.trim() || authorText;
        }
        return super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        let element = dom.querySelector(".p-novel__title");
        return (element === null) ? null : element.textContent;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("h1.p-novel__title, #novel_ex")];
    }

    extractDescription(dom) {
        return dom.querySelector(".p-novel__summary").textContent.trim();
    }  
}

================================================
FILE: plugin/js/parsers/SystemTranslationParser.js
================================================

"use strict";

parserFactory.register("systemtranslation.com", () => new SystemTranslationParser());

class SystemTranslationParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.eplisterfull ul");
        return util.hyperlinksToChapterList(menu).reverse();
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.thumb");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "p.has-text-align-center");
        super.removeUnwantedElementsFromContentElement(element);
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.entry-content p:not(.has-text-align-center)")];
    }
}

================================================
FILE: plugin/js/parsers/Taffygirl13Parser.js
================================================

"use strict";

parserFactory.register("taffygirl13.wordpress.com", () => new Taffygirl13Parser());

class Taffygirl13Parser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tables = [...dom.querySelectorAll("div.entry-content figure table")]
            .map(table => [...table.querySelectorAll("tr")]
                .map(row => [...row.querySelectorAll("td a")])
            );
        if (tables.length == 0) {
            return super.getChapterUrls(dom);
        }

        let chapters = [];
        for (let table of tables) {
            let rhs = [];
            for (let row of table) {
                chapters.push(row[0]);
                if (row.length == 2) {
                    rhs.push(row[1]);
                }
            }
            chapters = chapters.concat(rhs);
        }
        return chapters.map(a => util.hyperLinkToChapter(a));
    }
}

================================================
FILE: plugin/js/parsers/TapasParser.js
================================================

"use strict";

//not dead yet
parserFactory.register("tapas.io", () => new TapasParser());
//dead url
parserFactory.register("m.tapas.io", () => new TapasParser());

class TapasParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let pageNum = 1;
        let retrieve_count = 20;
        
        let seriesId = dom.querySelector("meta[property='al:android:url']").getAttribute("content").split("/", 4).pop();
        let chapterList = [];
        let chapterResponse = {};

        do
        {
            chapterResponse = await TapasParser.fetchPartialChapterList(seriesId, pageNum++, retrieve_count);
            var chapters = TapasParser.parseEpisodeDataToChapterList(chapterResponse.episodes);
            chapterUrlsUI.showTocProgress(chapters.map(item => item));
            chapterList = chapterList.concat(chapters);
        } while (chapterResponse.pagination.has_next && chapterResponse.episodes.length == retrieve_count);

        return chapterList;
    }

    static async fetchPartialChapterList(id, page, retrieve_count)
    {
        let restUrl = `https://tapas.io/series/${id}/episodes?page=${page}&sort=OLDEST&max_limit=${retrieve_count}`;
        let response = await HttpClient.fetchJson(restUrl);
        return response.json.data;
    }

    static parseEpisodeDataToChapterList(episodes)
    {
        return episodes.filter(item => item.free || item.free_access || item.unlocked)
            .map(item => {
                let title = item.scene + ": " + item.title;
                return {
                    sourceUrl:`https://tapas.io/episode/${item.id}`, 
                    title: title
                };
            } );
    }

    findContent(dom) {
        return dom.querySelector("#viewport") || dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        const title =
            dom.querySelector(".series-root .title") ||
            dom.querySelector(".center-info .center-info__title--small") ||
            dom.querySelector("title");
        return title.textContent;
    }

    extractAuthor(dom) {
        let authorLabel =
            dom.querySelector(".creator") ||
            dom.querySelector(".viewer-section--episode .name-wrapper .name");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        const title =
            dom.querySelector(".center-info .js-ep-title") ||
            dom.querySelector("div.viewer__header p.title");
        return title?.textContent ?? null;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".info--bottom") ||
            util.getFirstImgSrc(dom, ".info-body") ||
            util.getFirstImgSrc(dom, ".thumb");
    }

    customRawDomToContentStep(chapter, content) {
        content.querySelectorAll("*").forEach(element => {
            util.removeAttributes(element, ["dir", "role", "lang"]);
            util.replaceSemanticInlineStylesWithTags(element, true);
            if (element.id?.startsWith("docs-internal-guid-")) {
                element.removeAttribute("id");
            }
            element.classList.remove("MsoNormal");

            if (element.tagName?.toLowerCase() === "w:sdt") {
                // tag <w:sdt> is not valid XHTML, convert it to span with class="sdttag"
                util.removeAttributes(element, ["id", "sdttag"]);
                const spanElement = element.ownerDocument.createElement("span");
                spanElement.classList.add("sdttag");
                util.convertElement(element, spanElement);
            }
        });
    }

    preprocessRawDom(webPageDom) {
        util.resolveLazyLoadedImages(webPageDom, "article img.js-lazy");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".description__body")];
    }
}

================================================
FILE: plugin/js/parsers/TapreadParser.js
================================================

"use strict";

parserFactory.register("tapread.com", () => new TapreadParser());

class TapreadParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("a.chapter-item")]
            .map(TapreadParser.linkToChapter);
        if (chapters.length == 0) {
            chapters = this.fetchToc(dom.baseURI);
        }
        return chapters;
    }

    static linkToChapter(link) {
        let title = link.querySelector("p");
        title.querySelector("span").remove();
        return ({
            sourceUrl: link.href,
            title: title.textContent
        });
    }

    async fetchToc(url) {
        let bookId = new URL(url).pathname.split("/").pop();
        let body = `bookId=${bookId}`;
        let fetchUrl = "http://www.tapread.com/ajax/book/contents";
        let json = await this.fetchJson(fetchUrl, body);
        return json.result.chapterList.map(j => this.jsonToChapterUrl(j, bookId));
    }

    jsonToChapterUrl(json, bookId) {
        return {
            sourceUrl: `http://www.tapread.com/book/index/${bookId}/${json.chapterId}`,
            title: json.chapterName
        };
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-name");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author > span.name");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-img");
    }

    async fetchChapter(url) {
        let parts = new URL(url).pathname.split("/");
        let chapterId = parts.pop();
        let bookId = parts.pop();
        let body = `bookId=${bookId}&chapterId=${chapterId}`;
        let fetchUrl = "http://www.tapread.com/ajax/book/chapter";
        let json = await this.fetchJson(fetchUrl, body);
        return TapreadParser.jsonToHtml(json, fetchUrl);
    }

    async fetchJson(url, body) {
        let options = {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            credentials: "include",
            body: body
        };
        return (await HttpClient.fetchJson(url, options)).json;
    }

    static jsonToHtml(json, fetchUrl) {
        let newDoc = Parser.makeEmptyDocForContent(fetchUrl);
        let header = newDoc.dom.createElement("h1");
        header.textContent = json.result.chapterName;
        newDoc.content.appendChild(header);
        let content = util.sanitize(json.result.content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.synopsis p.desc")];
    }
}

================================================
FILE: plugin/js/parsers/TeanovelParser.js
================================================

"use strict";

parserFactory.register("teanovel.com", () => new TeanovelParser());
//dead url
parserFactory.register("teanovel.net", () => new TeanovelParser());

class TeanovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let storyName = new URL(dom.baseURI).pathname.split("/").pop();
        let tocUrl = `https://www.teanovel.com/novel/${storyName}/chapter-list`;
        let chapterDom = (await HttpClient.fetchHtml(tocUrl)).responseXML;
        return [...chapterDom.querySelectorAll("a.flex")]
            .map(a => this.linkToChapter(a))
            .filter(a => a.title);
    }

    linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector("p.text-sm")?.innerText?.trim(),
        });
    }

    findContent(dom) {
        return dom.querySelector("div.prose");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "flex");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("main img")?.src;
    }
    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("article")];
    }
}

================================================
FILE: plugin/js/parsers/TeenficParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("teenfic.net", () => new TeenficParser());

class TeenficParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = [...dom.querySelectorAll("ul.chapters")].pop();
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a[itemprop='author']");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#story-detail");
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let content = this.findContent(dom);
        let pageUrls = this.findOtherPagesOfChapter(dom);
        for (let nextUrl of pageUrls) {
            let newDom = (await HttpClient.wrapFetch(nextUrl)).responseXML;
            let newContent = this.findContent(newDom);
            util.moveChildElements(newContent, content);
        }
        return dom;
    }

    findOtherPagesOfChapter(dom) {
        let seen = new Set();
        let urls = [];
        let links = [...dom.querySelectorAll("ul.page li:not(.active) a")]
            .map(link => link.href);
        for (let link of links) {
            if (!seen.has(link)) {
                urls.push(link);
                seen.add(link);
            }
        }
        return urls;
    }

    getInformationEpubItemChildNodes(dom) {
        return [dom.querySelector("div.description")];
    }
}

================================================
FILE: plugin/js/parsers/Template.js
================================================

/*
  Template to use to create a new parser
*/
"use strict";

// Use one or more of these to specify when the parser is to be used
/*
// Use this function if site's host name is sufficient.  
// i.e. All pages are on same site, and use same format.
parserFactory.register("template.org", () => new TemplateParser());

// Use this function if site's URL is sufficient
parserFactory.registerUrlRule(
    url => TemplateParser.urlMeetsSelectionCriteria(url),
    () => new TemplateParser()
);

// Use this if pages are on multiple sites, or host name isn't unique
parserFactory.registerRule(
    function(url, dom) {
        return TemplateParser.urlMeetsSelectionCriteria(url) ||
            TemplateParser.domMeetsSelectionCritera(dom);
    },
    () => new TemplateParser()
);
*/

class TemplateParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
        //Optional Parameters:

        /*
        // Minimum delay (in ms) between page requests. Useful for 403 error prevention.
        // If the sites this parser accesses throttles requests or uses cloudflare, it is recommended to set this.
        this.minimumThrottle = 3000;
        */
    }

    // returns promise with the URLs of the chapters to fetch
    // promise is used because may need to fetch the list of URLs from internet
    /*
    async getChapterUrls(dom, chapterUrlsUI) {
        // Most common implementation is to find element holding the hyperlinks to 
        // the web pages holding the chapters.  Then call util.hyperlinksToChapterList()
        // to convert the links into a list of URLs the parser will collect.
        let menu = dom.querySelector("div.su-tabs-panes");
        return util.hyperlinksToChapterList(menu);

        // Almost as common, find links on page and convert.
        return [...dom.querySelectorAll("li.wp-manga-chapter.free-chap a")]
            .map(a => util.hyperLinkToChapter(a));

        // Need to walk multiple ToC pages, page by page
        return (await this.walkTocPages(dom, 
            TemplateParser.chaptersFromDom, 
            TemplateParser.nextTocPageUrl, 
            chapterUrlsUI
        ));

        // Can get list of all ToC pages
        let tocPage1chapters = TemplateParser.extractPartialChapterList(dom);
        let urlsOfTocPages  = TemplateParser.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            TemplateParser.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        ));
    }
    */

    // returns the element holding the story content in a chapter
    /*
    findContent(dom) {
        // typical implementation is find node with all wanted content
        // return is the element holding just the wanted content.
        return dom.querySelector("article");
    }
    */

    // title of the story  (not to be confused with title of each chapter)
    /*
    extractTitleImpl(dom) {
        // typical implementation is find node with the Title and return name from title
        // NOTE. Can return Title as a string, or an  HTML element
        return dom.querySelector("h1");
    }
    */

    // author of the story
    // Optional, if not provided, will default to "<unknown>"
    /*
    extractAuthor(dom) {
        // typical implementation is find node with the author's name and return name from title
        // Major points to note
        //   1. Return the Author's name as a string, not a HTML element
        //   2. If can't find Author, call the base implementation
        let authorLabel = dom.querySelector(".meta span a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }
    */

    // language used
    // Optional, if not provided, will default to ISO code for English "en"
    /*
    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }
    */

    // load EpubMetaInfo async in local variable to retieve with all other Metadata functions
    // Optional, will default to "return"
    /*
    async loadEpubMetaInfo(){
        let data = (await HttpClient.fetchJson(api)).json;
        this.subject = data.subject;
        ...
        return;
    }
    */

    // Genre of the story
    // Optional, Genre for metadata, if not provided, will default to ""
    /*
    extractSubject(dom) {
        let tags = [...dom.querySelectorAll("[property='genre']")];
        return tags.map(e => e.textContent.trim()).join(", ");
    }
    */

    // Description of the story
    // Optional, Description for metadata, if not provided, will default to ""
    /*
    extractDescription(dom) {
        return dom.querySelector("div [property='description']").textContent.trim();
    }
    */

    // Optional, supply if need to do special manipulation of content
    // e.g. decrypt content
    /*
    customRawDomToContentStep(chapter, content) {
        // for example of this, refer to LnmtlParser
    }
    */

    // Optional, supply if need to do custom cleanup of content
    /*
    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "button");
        super.removeUnwantedElementsFromContentElement(element);
    }
    */

    // Optional, supply if individual chapter titles are not inside the content element
    /*
    findChapterTitle(dom) {
        // typical implementation is find node with the Title
        // Return Title element, OR the title as a string
        return dom.querySelector("h3.dashhead-title");
    }
    */

    // Optional, if "next/previous chapter" are nested inside other elements,
    // this says how to find the highest parent element to remove
    /*
    findParentNodeOfChapterLinkToRemoveAt(link) {
        // The links may be wrapped, so need to walk up tree to find the 
        // highest element holding the chapter links.
        // e.g. Following code assumes links are sometimes enclosed in a <strong> tag
        // that is enclosed in a <p> tag.  We want to remove the <p> tag
        // and everything inside it
        let toRemove = util.moveIfParent(link, "strong");
        return util.moveIfParent(toRemove, "p");    
    }
    */

    // Optional, supply if cover image can usually be found on inital web page
    // Notes.
    //   1. If cover image is first image in content section, do not implement this function
    /*
    findCoverImageUrl(dom) {
        // Most common implementation is get first image in specified container. e.g. 
        return util.getFirstImgSrc(dom, "div.td-ss-main-sidebar");
    }
    */

    // Optional, supply if need to chase hyperlinks in page to get all chapter content
    // or site can send challenge pages for some chapters
    /*
    async fetchChapter(url) {
        return (await HttpClient.wrapFetch(url)).responseXML;

        // Handling to catch sites that send challenge pages
        // Note, need to implement isCustomError() and setCustomErrorResponse()
        let options = { parser: this };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }
    */

    // Optional, supply these if site can send challenge pages for some chapters
    /*
    // return true if response is a challenge response
    isCustomError(response){
        return (response.responseXML.title == "Just a moment...");
    }

    // what to do if encounter challenge
    setCustomErrorResponse(url, wrapOptions){
        let newresp = {};
        newresp.url = url;
        newresp.wrapOptions = wrapOptions;
        newresp.response = {};
        newresp.response.url = this.RestToUrl(checkedresponse.response.url);
        newresp.response.status = 403;
        return newresp;
    }
    */

    // Optional, supply if need to modify DOM before normal processing steps
    /*
    preprocessRawDom(webPageDom) {
    }
    */

    // Optional, called when user presses the "Pack EPUB" button.
    // Implement if parser needs to do anything after user sets UI settings 
    // but before collecting pages
    /*
    onStartCollecting() {
    }
    */

    // Optional, Return elements from page
    // that are to be shown on epub's "information" page
    /*
    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-details")];
    }
    */

    // Optional, Any cleanup operations to perform on the nodes
    // returned by getInformationEpubItemChildNodes
    /*
    cleanInformationNode(node) {
        return node;
    }
    */
}

================================================
FILE: plugin/js/parsers/TigertranslationsParser.js
================================================

"use strict";

parserFactory.register("tigertranslations.org", () => new TigertranslationsParser());

class TigertranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.the-content");
        this.cleanInitialDom(menu);
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div.the-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "p.taxonomies, "+
            ".tiger-after-content, .jp-relatedposts");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }

    async fetchChapter(url) {
        let urls = new Set();
        urls.add(url);
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let content = this.findContent(dom);
        this.cleanInitialDom(content);
        let nextUrl = this.findNextPageOfChapterUrl(content, urls, url);
        while (nextUrl != null) {
            let newDom = (await HttpClient.wrapFetch(nextUrl)).responseXML;
            let newContent = this.findContent(newDom);
            this.cleanInitialDom(newContent);
            nextUrl = this.findNextPageOfChapterUrl(newContent, urls, url);
            util.moveChildElements(newContent, content);
        }
        return dom;
    }

    findNextPageOfChapterUrl(content, urls, url) {
        let chapterName = util.extractFilenameFromUrl(url);
        let candidates = [...content.querySelectorAll("a")]
            .filter(a => util.extractFilename(a) === chapterName)
            .filter(a => !urls.has(a.href));

        let nextPageUrl = null;
        if (0 < candidates.length) {
            nextPageUrl = candidates[0].href;
            urls.add(nextPageUrl);
        }

        let toRemove = [...content.querySelectorAll("a")]
            .filter(this.isTigerTranslationsHost);
        util.removeElements(toRemove);            

        return nextPageUrl;
    }    

    isTigerTranslationsHost(link) {
        return new URL(link.href).host === "tigertranslations.org";        
    }

    cleanInitialDom(element) {
        util.removeChildElementsMatchingSelector(element, "p.taxonomies, "+
            ".tiger-after-content, .jp-relatedposts, .sharedaddy");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.the-content")];
    }

    cleanInformationNode(node) {
        this.cleanInitialDom(node);
        let toRemove = [...node.querySelectorAll("p")]
            .filter(p => p.querySelector("a") !== null);
        util.removeElements(toRemove);
    }
}

================================================
FILE: plugin/js/parsers/TimotxtParser.js
================================================

"use strict";

parserFactory.register("timotxt.com", () => new TimotxtParser());

class TimotxtParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.baseURI + "dir";
        let tocDom =  (await HttpClient.fetchHtml(tocUrl)).responseXML;
        let menu = tocDom.querySelector("ul.all");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        return dom.querySelector("#detail span.author")?.textContent ?? super.extractAuthor(dom);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#detail");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".intro")];
    }
}

================================================
FILE: plugin/js/parsers/TitannovelParser.js
================================================

"use strict";

parserFactory.register("titannovel.net", () => new TitannovelParser());

class TitannovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".meta h1 a");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".meta span a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".jp-relatedposts");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#content-a")];
    }
}

================================================
FILE: plugin/js/parsers/ToctruyenParser.js
================================================

"use strict";

parserFactory.register("toctruyen.net", () => new ToctruyenParser());

class ToctruyenParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        // eslint-disable-next-line
        let regex = new RegExp("\/truyen\/.+");
        let urlpart = dom.baseURI.match(regex)?.[0].slice(8);
        let leaves = urlpart.split("/");
        let id = leaves[0];
        let bookinfo = (await HttpClient.fetchJson("https://toctruyen.net/content/subitems?pid=" + id)).json;
        let chapters = bookinfo.data.e.map(a => ({
            sourceUrl:  a[3],
            title: a[2]  
        }));
        return chapters.reverse();
    }

    findContent(dom) {
        return dom.querySelector(".novel-reading-content .novel-reading-viewport");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".novel-reading-header h2");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".novel-header h1").textContent;
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll(".detail-genres a")].map(a => a.textContent.trim());
        return tags.join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("#description").textContent;
    }

    findCoverImageUrl(dom) {
        let test = dom.querySelector(".novel-thumb");
        return test.dataset.original;
    }
}

================================================
FILE: plugin/js/parsers/TomotranslationsParser.js
================================================

"use strict";

parserFactory.register("tomotranslations.com", () => new TomotranslationsParser());

class TomotranslationsParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("section.entry");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("section.entry");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.taxonomies");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.title");
    }
}

================================================
FILE: plugin/js/parsers/TongrenquanParser.js
================================================

"use strict";

parserFactory.register("tongrenquan.org", () => new TongrenquanParser());

class TongrenquanParser extends Parser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.book_list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".read_chapterDetail");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".infos h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".date span");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    findChapterTitle(dom) {
        return dom.querySelector(".read_chapterName h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book_info");
    }

    async fetchChapter(url) {
        let options = ({
            makeTextDecoder: () => new TextDecoder("gbk")
        });
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".infos > p")];
    }
}

================================================
FILE: plugin/js/parsers/TranslationChickenParser.js
================================================

"use strict";

parserFactory.register("translationchicken.com", () => new TranslationChickenParser());

class TranslationChickenParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    findContent(dom) {
        let content = dom.querySelector("div.post-content");
        let feature = dom.querySelector("div.featured-media");
        if (feature !== null)
        {
            feature.remove();
            content.insertBefore(feature, content.children[0]);
        }
        return content;
    }
}

================================================
FILE: plugin/js/parsers/TravistranslationsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("travistranslations.com", () => new TravistranslationsParser());

class TravistranslationsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("section.mb-4 ul.grid a")]
            .map(a => ({
                sourceUrl:  a.href,
                title: a.querySelector("span").textContent.trim()
            }));
    }

    findContent(dom) {
        return dom.querySelector("div.reader-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1[title]");
    }

    findChapterTitle(dom) {
        let h2 = dom.querySelector("div.header h2");
        let span = h2.parentElement.querySelector("span")?.textContent ?? "";
        return h2.textContent + " " + span;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#primary .container")
            ?.replace("q=55", "q=100") ?? null;
    }

    preprocessRawDom(webPageDom) {
        util.resolveLazyLoadedImages(webPageDom, "img");
        this.addAuthorNotes(webPageDom);
    }

    addAuthorNotes(webPageDom) {
        let content = this.findContent(webPageDom); 
        for (let n of [...content.parentElement.querySelectorAll("div.py-1")]) {
            content.append(n);
        }
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div[property='description']")];
    }
}

================================================
FILE: plugin/js/parsers/TruyenfullParser.js
================================================

"use strict";

parserFactory.register("truyenfull.vn", () => new TruyenfullParser());

class TruyenfullParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            TruyenfullParser.extractPartialChapterList,
            TruyenfullParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static getUrlsOfTocPages(dom) {
        let urls = [];
        let input = dom.querySelector("input#total-page");
        if (input != null) {
            let totalp = parseInt(input.getAttribute("value"));
            for (let i = 2; i <= totalp; ++i ) {
                urls.push(`${dom.baseURI}trang-${i}/`);
            }
        }
        return urls;
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.list-chapter a")]
            .map(link => util.hyperLinkToChapter(link));
    }

    findContent(dom) {
        return dom.querySelector("div.chapter-c");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a[itemprop='author']");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        let title = dom.querySelector("a.chapter-title");
        return (title === null) ? super.findChapterTitle(dom) : title.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc-text")];
    }
}

================================================
FILE: plugin/js/parsers/TruyenFullVisionParser.js
================================================

"use strict";
parserFactory.register("truyenfull.vision", () => new TruyenFullVisionParser());

class TruyenFullVisionParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            TruyenFullVisionParser.extractPartialChapterList,
            TruyenFullVisionParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static getUrlsOfTocPages(dom) {
        let urls = [];
        let input = dom.querySelector("input#total-page");
        if (!input) return urls;

        let totalp = parseInt(input.getAttribute("value"), 10);
        let current = new URL(dom.baseURI);

        // Remove any existing /trang-<n>/ suffix from pathname
        let basePath = current.pathname.replace(/\/trang-\d+\/?$/, "");
        if (!basePath.endsWith("/")) basePath += "/";

        for (let i = 2; i <= totalp; ++i) {
            let u = new URL(current); // clone
            u.hash = "";             // drop fragment
            u.search = "";           // drop query if you don't want it
            u.pathname = basePath + `trang-${i}/`;
            urls.push(u.toString());
        }
        return urls;
    }

    static extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("ul.list-chapter a")]
            .map(link => util.hyperLinkToChapter(link));
    }


    findContent(dom) {
        return dom.querySelector("div.chapter-c");
    }
    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("a[itemprop='author']");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractDescription(dom) {
        return dom.querySelector(".desc-text").textContent.trim();
    }
    
    findChapterTitle(dom) {
        let title = dom.querySelector("a.chapter-title");
        return (title === null) ? super.findChapterTitle(dom) : title.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.desc-text")];
    }
}

================================================
FILE: plugin/js/parsers/TruyenParser.js
================================================

"use strict";

parserFactory.register("truyennhabo.com", () => new TruyenParser());

class TruyenParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        const chapterLinks = [...dom.querySelectorAll("#clwd ul a")];
        const chapterTitles = [...dom.querySelectorAll("#clwd span.block")];
        const chapterUrls = [];
        for (let i = 0; i < chapterLinks.length; i++) {
            const chapterLink = chapterLinks[i];
            const chapterTitle = chapterTitles[i];
            chapterUrls.push({
                sourceUrl: chapterLink.href,
                title: chapterTitle.textContent,
            });
        }
        return chapterUrls.reverse();
    }

    findContent(dom) {
        return (
            dom.querySelector("article.blog")
        );
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("#extra-info dd");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector("header h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.auto-rows-max");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#synopsis")];
    }

    removeUnwantedElementsFromContentElement(element) {
        let mark = element.querySelector("a");
        mark.remove();
        super.removeUnwantedElementsFromContentElement(element);
    }

}

================================================
FILE: plugin/js/parsers/TruyenyyParser.js
================================================

"use strict";

parserFactory.register("truyenyy.com", () => new TruyenyyParser());

class TruyenyyParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            TruyenyyParser.extractPartialChapterList,
            TruyenyyParser.getUrlsOfTocPages,
            chapterUrlsUI
        );
    }

    static extractPartialChapterList(dom) {
        let previousText = "";
        let mergedlinks = [];
        for (let l of dom.querySelectorAll("table.table a")) {
            if (l.className === "table-chap-title") {
                l.textContent = previousText + ": " + l.textContent.trim();
                mergedlinks.push(l);
            }
            previousText = l.textContent.trim();
        }
        return mergedlinks.map(a => util.hyperLinkToChapter(a));
    }

    static getUrlsOfTocPages(dom) {
        let pagination = dom.querySelector("ul.pagination");
        let tocUrls = [];
        if (pagination != null ) {
            let tocLinks = [...dom.querySelectorAll("a.page-link")]
                .map(a => a.href)
                .filter(href => href.includes("?p="));
            let maxPage = tocLinks
                .map(href => parseInt(href.split("?p=")[1]))
                .reduce((p, c) => Math.max(p, c), -1);
            if (1 < maxPage) {
                let base = tocLinks[0].split("?p=")[0];
                for (let i = 2; i <= maxPage; ++i) {
                    tocUrls.push(`${base}?p=${i}`);
                }
            }
        }
        return tocUrls;
    }

    findContent(dom) {
        return dom.querySelector("div#id_chap_content div.inner");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.novel-info .name");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.novel-info .author a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("div#id_chap_content .chapter-title");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("div.novel-info img");
        return (img === null) ? img : img.getAttribute("data-src");
    }
}

================================================
FILE: plugin/js/parsers/TrxsParser.js
================================================

"use strict";

parserFactory.registerDeadSite("trxs.me", () => new TrxsParser());
parserFactory.register("trxs.cc", () => new TrxsParser());
parserFactory.register("tongrenshe.cc", () => new TrxsParser());

class TrxsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".book_list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".read_chapterDetail");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".read_chapterName.tc h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".pic");
    }

    extractLanguage() {
        return "zh-CN";
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".infos > h1:nth-child(1)");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".date > span:nth-child(1) > a:nth-child(1)");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    async fetchChapter(url) {
        let options = { makeTextDecoder: () => new TextDecoder("gbk") };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    extractDescription(dom) {
        return dom.querySelector(".infos > p:nth-child(4)").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".infos p")];
    }
}

================================================
FILE: plugin/js/parsers/TumblrParser.js
================================================

"use strict";

parserFactory.registerUrlRule(
    url => (util.extractHostName(url).endsWith(".tumblr.com")),
    () => new TumblrParser()
);

class TumblrParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = this.findContent(dom);
        this.removeUnwantedContent(menu);
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        let content = dom.querySelector("main div.post") ||
            dom.querySelector("main div.post-main") ||
            dom.querySelector("article div.post-content");
        //fix embeded image links
        for (let e of content.querySelectorAll("a[data-big-photo]")) {
            e.href = e.dataset?.bigPhoto;
        }
        return content;
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        this.removeUnwantedContent(this.findContent(dom));
        let photoset = dom.querySelector("iframe.photoset");
        if (photoset !== null) {
            let iframe = (await HttpClient.wrapFetch(photoset.src)).responseXML;
            let images = iframe.querySelector("div.photoset");
            if (images === null) {
                this.fixupPhotoset(dom);        
            } else {
                photoset.replaceWith(images);
            }
        }
        return dom;
    }

    removeUnwantedContent(content) {
        util.removeChildElementsMatchingSelector(content, "footer, #disqus_thread, #notes");
    }

    fixupPhotoset(dom) {
        let photoset = dom.querySelector("div.html_photoset");
        if (photoset !== null) {
            for (let url of this.getPhotosetUrls(dom)) {
                let img = document.createElement("img");
                img.src = url;
                photoset.appendChild(img);
            }
        }
    }

    getPhotosetUrls(dom) {
        let meta = [...dom.querySelectorAll("meta[property='og:image']")];
        return meta.map(m => m.getAttribute("content"))
            .filter(u => !util.isNullOrEmpty(u));
    }
}

================================================
FILE: plugin/js/parsers/TwkanParser.js
================================================

"use strict";

parserFactory.register("twkan.com", () => new TwkanParser());

class TwkanParser extends Parser {
    constructor() {
        super();
        // Add delay between requests to avoid rate limiting
        this.minimumThrottle = 1000;
    }

    async getChapterUrls(dom) {
        // Extract book ID from the current URL
        let bookId = this.extractBookId(dom.baseURI);
        if (!bookId) {
            // Fallback: try to get from meta tag
            let metaBookId = dom.querySelector("meta[property='og:book_id']");
            if (metaBookId) {
                bookId = metaBookId.getAttribute("content");
            }
        }
        
        if (!bookId) {
            throw new Error("Could not extract book ID from URL");
        }

        // Fetch the FULL chapter list directly from the AJAX endpoint
        // This bypasses the "Load More" button entirely
        let ajaxUrl = `https://twkan.com/ajax_novels/chapterlist/${bookId}.html`;
        let response = await HttpClient.wrapFetch(ajaxUrl);
        let chapterListDom = response.responseXML;
        
        // The AJAX response contains <ul><li><a href="...">Chapter Title</a></li>...</ul>
        // Get all chapter links from the response
        let links = [...chapterListDom.querySelectorAll("ul li a")]
            .filter(a => a.href.includes("/txt/"));
        
        return links.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        // User provided: #txtcontent0
        return dom.querySelector("#txtcontent0");
    }

    extractTitleImpl(dom) {
        // From main book page: .booknav2 h1 a or h1 a
        let titleEl = dom.querySelector(".booknav2 h1 a, .booknav2 h1, h1 a");
        if (titleEl) {
            return titleEl.textContent.trim();
        }
        // Fallback: try meta tag
        let metaTitle = dom.querySelector("meta[property='og:title']");
        if (metaTitle) {
            return metaTitle.getAttribute("content");
        }
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        // From main book page: .booknav2 p contains "作者：" followed by author link
        let authorEl = dom.querySelector(".booknav2 p a[href*='/author/']");
        if (authorEl) {
            return authorEl.textContent.trim();
        }
        // Fallback: try meta tag
        let metaAuthor = dom.querySelector("meta[property='og:novel:author']");
        if (metaAuthor) {
            return metaAuthor.getAttribute("content");
        }
        return super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    extractSubject(dom) {
        // Get category/genre from meta tag or page
        let metaCategory = dom.querySelector("meta[property='og:novel:category']");
        if (metaCategory) {
            return metaCategory.getAttribute("content");
        }
        let categoryEl = dom.querySelector(".booknav2 p a[href*='/class/']");
        return categoryEl?.textContent?.trim() ?? "";
    }

    extractDescription(dom) {
        // Get description from meta tag or page
        let metaDesc = dom.querySelector("meta[property='og:description']");
        if (metaDesc) {
            return metaDesc.getAttribute("content");
        }
        let descEl = dom.querySelector(".navtxt p");
        return descEl?.textContent?.trim() ?? "";
    }

    findChapterTitle(dom) {
        // User provided: #container > div.mybox > div.txtnav > h1
        // Also try simpler selectors
        return dom.querySelector(".txtnav h1, #container .txtnav h1, h1");
    }

    findCoverImageUrl(dom) {
        // First try the og:image meta tag (most reliable)
        let metaImage = dom.querySelector("meta[property='og:image']");
        if (metaImage) {
            return metaImage.getAttribute("content");
        }
        
        // Try to find cover image in page
        let coverImg = dom.querySelector(".bookimg2 img, .bookimg img");
        if (coverImg) {
            return coverImg.src;
        }
        
        // Fallback: construct URL from book ID
        // Pattern: https://twkan.com/files/article/image/76/76222/76222s.jpg
        let bookId = this.extractBookId(dom.baseURI);
        if (bookId) {
            let prefix = bookId.substring(0, 2);
            return `https://twkan.com/files/article/image/${prefix}/${bookId}/${bookId}s.jpg`;
        }
        
        return null;
    }

    extractBookId(url) {
        // Extract book ID from URL like:
        // https://twkan.com/book/76222.html
        // https://twkan.com/book/76222/index.html
        // https://twkan.com/txt/76222/46362641
        let match = url.match(/\/(?:book|txt)\/(\d+)/);
        return match ? match[1] : null;
    }

    removeUnwantedElementsFromContentElement(element) {
        // Remove common unwanted elements
        util.removeChildElementsMatchingSelector(element, 
            "script, .ads, .ad, .advertisement, #ad, .social-share, .share-buttons, " +
            ".txtcenter, .adsbygoogle, ins.adsbygoogle"
        );
        super.removeUnwantedElementsFromContentElement(element);
    }

    // Note: getInformationEpubItemChildNodes intentionally not defined
    // to skip info page (DOMPurify not available in this extension build)
}

================================================
FILE: plugin/js/parsers/UaaParser.js
================================================

"use strict";

parserFactory.register("uaa.com", () => new UaaParser());

class UaaParser extends Parser {
    constructor() {
        super();

        this.minimumThrottle = 3000; //Might not be necessary, but keeping it just to be safe.
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".catalog_ul");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".article");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".dizhi");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".title_box h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover"); // Cover Image is hidden being an API call. 
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".info_box > h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".info_box > div:nth-child(4) > a:nth-child(1)");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractDescription(dom) {
        return dom.querySelector("div.txt").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".detail_box")];
    }
}

================================================
FILE: plugin/js/parsers/UltimaguilParser.js
================================================

/*
  Parses <www.ultimaguil.org>
*/
"use strict";

//dead url/ parser
parserFactory.register("ultimaguil.org", () => new UltimaguilParser(new VariableSizeImageCollector()));

class UltimaguilParser extends Parser {
    constructor(imageCollector) {
        super(imageCollector);
    }

    getChapterUrls(dom) {
        return Promise.resolve(util.hyperlinksToChapterList(dom));
    }

    extractTitleImpl(dom) {   // eslint-disable-line no-unused-vars
        return "Twintails";
    }

    extractAuthor(dom) {   // eslint-disable-line no-unused-vars
        return "Mizusawa Yume";
    }

    // find the node(s) holding the story content
    findContent(dom) {
        let div = dom.querySelector("div#inside");
        return div;
    }

    populateUIImpl() {
        document.getElementById("highestResolutionImagesRow").hidden = false;
    }

    webPageToEpubItems(webPage, epubItemIndex) {
        let content = this.convertRawDomToContent(webPage);
        let items = [];
        if (content != null) {
            items = this.splitContentIntoEpubItems(content, webPage.sourceUrl, epubItemIndex);
        }
        return items;
    }

    splitContentIntoEpubItems(content, baseUri, epubItemIndex) {
        this.convertMidpartToHeaders(content);
        let items = BakaTsukiParser.splitContentOnHeadingTags(content);
        return BakaTsukiParser.itemsToEpubItems(items, epubItemIndex, baseUri);
    }

    convertMidpartToHeaders(content) {
        let doc = content.ownerDocument;
        for (let midpart of content.querySelectorAll("div.part.midpart.gear")) {
            let parent = midpart.parentElement;
            let h3 = doc.createElement("h2");
            let link = midpart.querySelector("a");
            h3.appendChild(doc.createTextNode(link.getAttribute("title")));
            parent.replaceWith(h3);
        }
    }

    customRawDomToContentStep(chapter, content) {
        this.flattenContent(content);
        this.removeLinkFromHeaders(content);
    }

    /**
     *  "flatten" content.  Chapter parts may be <div> sections after the read_content span
    */
    flattenContent(content) {
        let read_content = content.querySelector("span#read_content");
        if (read_content !== null) {
            let parent = read_content.parentElement;
            while (read_content.hasChildNodes()) {
                let node = read_content.childNodes[0];
                if (node.tagName.toLowerCase() === "div") {
                    let div = node;
                    while (div.hasChildNodes()) {
                        parent.insertBefore(div.childNodes[0], read_content);
                    }
                    div.remove();
                } else {
                    parent.insertBefore(node, read_content);
                }
            }
        }
    }

    removeLinkFromHeaders(content) {
        let document = content.ownerDocument;
        for (let link of content.querySelectorAll("h2 a")) {
            link.replaceWith(document.createTextNode(link.textContent));
        }
    }
}

================================================
FILE: plugin/js/parsers/UnlimitedNovelFailuresParser.js
================================================

/*
  Parses unlimitednovelfailures.mangamatters.com
*/
"use strict";

//dead url/ parser
parserFactory.register("unlimitednovelfailures.mangamatters.com",
    () => new UnlimitedNovelFailuresParser()
);

class UnlimitedNovelFailuresParser extends Parser {
    constructor(imageCollector) {
        super(imageCollector);
    }

    getChapterUrls(dom) {
        return Promise.resolve(util.hyperlinksToChapterList(dom));
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".entry-title");
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return WordpressBaseParser.findContentElement(dom);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }

    webPageToEpubItems(webPage, epubItemIndex) {
        let content = this.convertRawDomToContent(webPage);
        let items = [];
        if (content != null) {
            items = this.splitContentIntoEpubItems(content, webPage.sourceUrl, epubItemIndex);
        }
        BakaTsukiParser.fixupInternalHyperLinks(items);
        return items;
    }

    splitContentIntoEpubItems(content, baseUri, epubItemIndex) {
        this.convertAnchorsToHeaders(content);
        let items = BakaTsukiParser.splitContentOnHeadingTags(content);
        return BakaTsukiParser.itemsToEpubItems(items, epubItemIndex, baseUri);
    }

    convertAnchorsToHeaders(content) {
        let document = content.ownerDocument;
        for (let link of content.querySelectorAll("a[id]")) {
            let h2 = document.createElement("h2");
            h2.id = link.id;
            h2.appendChild(document.createTextNode(link.textContent));
            let parent = link.parentElement;
            if (parent.tagName.toLowerCase() === "p") {
                parent.after(h2);
                link.remove();
            } else {
                link.replaceWith(h2);
            }
        }
    }
}

================================================
FILE: plugin/js/parsers/UntamedAlleyParser.js
================================================

"use strict";

parserFactory.register("untamedalley.com", () => new UntamedAlleyParser());

class UntamedAlleyParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        return (await this.walkTocPages(dom, 
            this.chaptersFromDom, 
            this.nextTocPageUrl, 
            chapterUrlsUI
        )).reverse();
    }

    chaptersFromDom(dom) {
        return [...dom.querySelectorAll("#primary h2 a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    nextTocPageUrl(dom) {
        return dom.querySelector("div.nav-previous a")?.href;
    }

    findContent(dom) {
        return dom.querySelector("div.entry-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".page-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".entry-title");
    }
}

================================================
FILE: plugin/js/parsers/VelvetReverieParser.js
================================================

"use strict";

parserFactory.register("velvet-reverie.org", () => new VelvetReverieParser());

class VelvetReverieParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let table = dom.querySelector("div.story-toc ul");
        return util.hyperlinksToChapterList(table);
    }

    findContent(dom) {
        let temp = dom.querySelector("div.mbs_posts_text");
        let ToRemove = temp.querySelectorAll(".jum"); 
        for (let element of ToRemove) {
            element.remove();
        }
        return temp;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.story-info-column h1");
    }

    extractDescription(dom) {
        let temp = dom.querySelector("div.story-synopsis");
        let ToRemove = temp.querySelectorAll(".jum"); 
        for (let element of ToRemove) {
            element.remove();
        }
        return temp.textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2.mbs_posts_title");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("img.story-cover")?.src ?? null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.story-synopsis p")];
    }
}

================================================
FILE: plugin/js/parsers/VipNovelParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("vipnovel.com", () => new VipNovelParser());

class VipNovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("li.wp-manga-chapter a")]
            .map(a => util.hyperLinkToChapter(a))
            .reverse();
    }

    findContent(dom) {
        return dom.querySelector("div.reading-content");
    }

    extractTitleImpl(dom) {
        let title = dom.querySelector("div.post-title h1, div.post-title h3");
        util.removeChildElementsMatchingSelector(title, "span.hot");
        return title;
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary_content, div.summary__content")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "#init-links");
    }
}

================================================
FILE: plugin/js/parsers/VolarenovelsParser.js
================================================

"use strict";

parserFactory.register("volarenovels.com", () => new VolarenovelsParser());

class VolarenovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("ul.list-chapters a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.panel-body div.fr-view");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h3.title");
    }

    extractDescription(dom) {
        return dom.querySelector("div#Details").textContent.trim();
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.panel-body h4");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#content-container");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#Details")];
    }
}

================================================
FILE: plugin/js/parsers/VynovelParser.js
================================================

"use strict";

parserFactory.register("vynovel.com", () => new VynovelParser());

class VynovelParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.list");
        let links = [...menu.querySelectorAll("a")];
        return this.chaptersFromList(links).reverse();
    }

    chaptersFromList(list) {
        return list.map(a => ({
            sourceUrl: a.href, 
            title: a.querySelector("span").innerText.trim()
        }));
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return dom.querySelector("div.img-manga > img")?.src ?? null;
    }

    extractAuthor(dom) {
        let author = dom.querySelector("div.fic-header h4 span a");
        return author?.textContent?.trim() ?? super.extractAuthor(dom);
    }

    extractSubject(dom) {
        let tags = [...dom.querySelectorAll("div.div-manga a")].filter(a => a.href.includes("https://www.vynovel.com/genre"));
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.summary > .content").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.div-manga")];
    }
}

================================================
FILE: plugin/js/parsers/WanderinginnParser.js
================================================

"use strict";

parserFactory.register("wanderinginn.com", () => new WanderinginnParser());

class WanderinginnParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("#table-of-contents a:not(.book-title-num, .volume-book-card)")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#reader-content");
    }

    findChapterTitle(dom) {
        const titles = dom.querySelectorAll("h2.elementor-heading-title");
        for (const title of titles) {
            // default fetch of the page has a copy of title "loading..." preceding the real one, for some reason
            if (title.textContent.trim() !== "loading...") {
                return title;
            }
        }
        return null;
    }
    
    extractTitleImpl() {
        return "The Wandering Inn";
    }
    
    extractAuthor() {
        return "pirateaba";
    }
    
    removeNextAndPreviousChapterHyperlinks(webPage, content) {
        util.removeElements(content.querySelectorAll("a[href*='https://wanderinginn.com/']"));
    }

    preprocessRawDom(webPageDom) {
        const content = this.findContent(webPageDom);
        if (content) {
            // Add italics to all .mrsha-write elements
            // "mrsha-write" used to be italics, but is now is a custom font in the
            // web reader which doesn't get copied over to the epub. This fixes that.
            for (const element of content.querySelectorAll(".mrsha-write")) {
                element.setAttribute("style", "font-style: italic;");
            }

            // Add iBooks dark theme class to spans with color styles
            // This allows apple iBooks to display colors in dark mode, for specific elements.
            // The Wandering Inn colors were already meant to be displayed in dark mode, so this works great!
            for (const span of content.querySelectorAll("span[style*='color:']")) {
                span.classList.add("ibooks-dark-theme-use-custom-text-color");
            }
        }
    }
}

================================================
FILE: plugin/js/parsers/WatashiwasugoidesuParser.js
================================================

"use strict";

parserFactory.register("watashiwasugoidesu.com", () => new WatashiwasugoidesuParser());

class WatashiwasugoidesuParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.display-posts-listing");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#wtr-content");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#primary");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.wp-block-media-text__content p")];
    }
}

================================================
FILE: plugin/js/parsers/WattpadParser.js
================================================

"use strict";

parserFactory.register("wattpad.com", () => new WattpadParser());

class WattpadImageCollector extends ImageCollector {
    constructor() {
        super();
    }

    extractWrappingUrl(element) {
        let url = super.extractWrappingUrl(element);
        return this.removeSizeParamsFromQuery(url);
    }

    removeSizeParamsFromQuery(originalUrl) {
        let url = new URL(originalUrl);
        if (!url.hostname.toLowerCase().includes("wattpad")) {
            return originalUrl;
        }
        url.search = "";
        return url.href;
    }
}

class WattpadParser extends Parser {
    constructor() {
        super(new WattpadImageCollector());
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("ul.table-of-contents");
        if (menu == null) {
            return this.fetchChapterList(dom);
        }
        return util.hyperlinksToChapterList(menu);
    }

    async fetchChapterList(dom) {
        let storyId = WattpadParser.extractIdFromUrl(dom.baseURI);
        let chaptersUrl = `https://www.wattpad.com/api/v3/stories/${storyId}`;
        let json = (await HttpClient.fetchJson(chaptersUrl)).json;
        return json.parts.map(p => ({sourceUrl: p.url, title: p.title}));
    }

    static extractIdFromUrl(url) {
        let path = new URL(url).pathname;
        return path.split("/").filter(s => s.includes("-"))[0].split("-")[0];
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let extraUris = this.findURIsWithRestOfChapterContent(dom);
        return this.fetchAndAddExtraContentForChapter(dom, extraUris);
    }

    findURIsWithRestOfChapterContent(dom) {
        let info = { "pages" : 1 };
        let json = this.findJsonWithRestOfChapterUriInfo(dom);
        if (json != null) {
            info.pages = json.pages;
            info.refreshToken = json.text_url.refresh_token;
            let uri = json.text_url.text;
            let index = uri.indexOf("?");
            info.uriStart = uri.substring(0, index);
            info.uriEnd = uri.substring(index);
        }
        return info;
    }

    findJsonWithRestOfChapterUriInfo(dom) {
        let searchString = ".metadata\":{\"data\":";
        for (let s of [...dom.querySelectorAll("script")]) {
            let source = s.innerHTML;
            let index = source.indexOf(searchString);
            if (0 <= index) {
                return util.locateAndExtractJson(source, searchString);
            }
        }
    }

    async fetchAndAddExtraContentForChapter(dom, extraUris) {
        let extraContent = (await this.fetchExtraChapterContent(extraUris));
        this.addExtraContent(dom, extraContent);
        return WattpadParser.removeDuplicateParagraphs(dom);
    }

    async fetchExtraChapterContent(extraUris) {
        let extraContent = [];
        for (let page = 2; page <= extraUris.pages; ++page) {
            let text = (await this.fetchPage(extraUris, page));
            extraContent.push(text);
        }
        return extraContent;
    }

    async fetchPage(extraUris, page) {
        let retry = 4;
        while (0 <= --retry) {
            let url = `${extraUris.uriStart}-${page}${extraUris.uriEnd}`;
            try {
                let text = (await HttpClient.fetchText(url));
                return text;
            } catch (err) { 
                try {
                    let json = (await HttpClient.fetchJson(extraUris.refreshToken)).json;
                    if (!util.isNullOrEmpty(json.token)) {
                        extraUris.uriEnd = "?" + json.token;
                    }
                } catch (err) { 
                    // eslint-disable-line no-empty
                }
            }
        }

        throw new Error("Unable to fetch " + extraUris.uriStart);
    }

    addExtraContent(dom, extraContent) {
        let content = this.findContent(dom);
        for (let s of extraContent) {
            content.appendChild(this.toHtml(s));
        }
        return dom;
    }

    static removeDuplicateParagraphs(dom) {
        let s = new Set();
        for (let p of [...dom.querySelectorAll("p[data-p-id]")]) {
            let id = p.getAttribute("data-p-id");
            if (s.has(id)) {
                p.remove();
            } else {
                s.add(id);
            }
        }
        return dom;
    }

    toHtml(extraContent) {
        return util.sanitize("<div>" + extraContent + "</div>")
            .querySelector("div");
    }

    findContent(dom) {
        return dom.querySelector("div[data-page-number]");
    }

    // title of the story  (not to be confused with title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector("div.story-info span.sr-only");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.af6dp a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractSubject(dom) {
        let tags = ([...dom.querySelectorAll("div._9c7jH a")]);
        return tags.map(e => e.textContent.trim()).join(", ");
    }

    extractDescription(dom) {
        return dom.querySelector("div.glL-c").textContent.trim();
    }

    // custom cleanup of content
    removeUnwantedElementsFromContentElement(element) {
        let keep = [...element.querySelectorAll("p")];
        util.removeElements([...element.children]);
        for (let e of keep) {
            element.appendChild(e);
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    // individual chapter titles are not inside the content element
    findChapterTitle(dom) {
        return dom.querySelector("h1.h2");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div[data-testid='cover']");
    }
}

================================================
FILE: plugin/js/parsers/WebNovelOnlineParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("webnovelonline.com", () => new WebNovelOnlineParser());

class WebNovelOnlineParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [...dom.querySelectorAll("div.chapter-list a")]
            .map(a => util.hyperLinkToChapter(a));
        return Promise.resolve(chapters.reverse());
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.novel-dexc h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.novel-desc > div.info > p:nth-child(1) > span:nth-child(2)");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book");
    }

    async fetchChapter(url) {
        let xhr = await HttpClient.wrapFetch(url);
        return WebNovelOnlineParser.buildContentHtml(xhr.responseXML, url);
    }
 
    static buildContentHtml(dom, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        newDoc.content.appendChild(dom.querySelector("div.chapter-info h3"));
        let text = WebNovelOnlineParser.getStringWithContent(dom);
        if (text.includes("</p>")) {
            WebNovelOnlineParser.addHtmlToDocument(newDoc.content, text);
        } else {
            WebNovelOnlineParser.addTextToDocument(newDoc, text);
        }
        return newDoc.dom;
    }

    static addTextToDocument(newDoc, text) {
        let paragraphs = text
            .split("\n")
            .filter(p => (p !== null) && (0 < p.length));
        for (let text of paragraphs) {
            let p = newDoc.dom.createElement("p");
            p.appendChild(newDoc.dom.createTextNode(text));
            newDoc.content.appendChild(p);
        }
    }

    static addHtmlToDocument(content, text) {
        text = "<div id=\"raw\">" + text + "</div>";
        let rawDom = util.sanitize(text);
        content.appendChild(rawDom.querySelector("div#raw"));
    }

    static getStringWithContent(dom) {
        let script = [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(t => t.includes("window._INITIAL_DATA_"));
        let index = script[0].indexOf("[");
        let json = script[0].substring(index,  script[0].length - 1);
        let content = JSON.parse(json)
            .filter(o => (o != null) && (o.chapter !== undefined));
        return content[0].chapter; 
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.novel-desc, div.summary")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "div.action");
    }
}

================================================
FILE: plugin/js/parsers/Wenku8Parser.js
================================================

"use strict";

parserFactory.register("wenku8.net", () => new Wenku8Parser());

class Wenku8Parser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let id = Wenku8Parser.extractBookId(dom);
        let tocUrl = ` https://www.wenku8.net/modules/article/reader.php?aid=${id}`;
        return HttpClient.wrapFetch(tocUrl, this.makeOptions()).then(function(xhr) {
            let menu = xhr.responseXML.querySelector("table");
            return Promise.resolve(util.hyperlinksToChapterList(menu));
        });
    }

    static extractBookId(dom) {
        let path = new URL(dom.baseURI).pathname.split("/");
        return path[path.length - 1].split(".")[0];
    }

    findContent(dom) {
        return dom.querySelector("#contentmain");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("tbody td b").textContent;
    }

    extractLanguage() {
        return "zh";
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "ul#contentdp");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#content");
    }

    fetchChapter(url) {
        // site does not tell us GBK is used to encode text
        return HttpClient.wrapFetch(url, this.makeOptions()).then(function(xhr) {
            return Promise.resolve(xhr.responseXML);
        });
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("GBK")
        });
    }
}

================================================
FILE: plugin/js/parsers/WetriedTlsParser.js
================================================

"use strict";

parserFactory.register("wetriedtls.com", () => new WetriedTlsParser());

class WetriedTlsParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 2000;
        this.chaptersSourceTitleMap = new Map();
    }

    async getChapterUrls() {
        const chapterJson = (
            await HttpClient.fetchJson(
                "https://api.wetriedtls.com/chapters/" +
                    this.id +
                    "?page=1&perPage=9999&order=asc"
            )
        ).json;

        const chapters = chapterJson.data.map((chapter) => {
            const seriesUrl =
                "https://wetriedtls.com/series/" + chapter.series.series_slug;

            const mapObj = {
                sourceUrl: `${seriesUrl}/${chapter.chapter_slug}`,
                title: chapter.chapter_title,
            };
            this.chaptersSourceTitleMap.set(mapObj.sourceUrl, mapObj.title);
            return mapObj;
        });

        return chapters;
    }

    async loadEpubMetaInfo(dom) {
        const bookTitle = dom
            .querySelector("section .text-xl")
            .textContent.trim();

        let series = (
            await HttpClient.fetchJson(
                "https://api.wetriedtls.com/query?adult=true&query_string=" +
                    bookTitle
            )
        ).json;

        if (series.data.length === 0) {
            throw new Error("No series found for the given title.");
        }

        const novelData = series.data[0];

        this.id = novelData.id;
        this.title = novelData.title;
        this.thumbnail = novelData.thumbnail;
        this.description = novelData.description;
        return;
    }
    async fetchChapter(url) {
        const dom = (await HttpClient.wrapFetch(url)).responseXML;

        const startString = "self.__next_f.push(";
        const scriptElements = Array.from(dom.querySelectorAll("script"))
            .map((el) => el.textContent)
            .filter((text) => text.includes(startString));

        // Parse all push statements
        const parsedChunks = scriptElements
            .map((script) => {
                const jsonText = script.slice("self.__next_f.push(".length, -1); // remove wrapper
                try {
                    return JSON.parse(jsonText);
                } catch {
                    return null;
                }
            })
            .filter(Boolean);

        // Find the longest chunk with HTML content
        const htmlChunk = parsedChunks.find(
            ([type, data]) =>
                type === 1 &&
                typeof data === "string" &&
                /<p\b[^>]*>|<div\b[^>]*>|<br\b[^>]*>|<\/?strong\b[^>]*>/i.test(
                    data
                ) && // looks like HTML
                data.length > 1000 // avoid short status chunks
        );

        if (!htmlChunk) throw new Error("No HTML chapter content found.");

        return this.buildChapter(htmlChunk[1], url);
    }

    buildChapter(rawHtml, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let content = util.sanitize(rawHtml);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return this.title.trim();
    }

    extractAuthor(dom) {
        if (!dom) return super.extractAuthor(dom);

        const authorLabel = Array.from(
            dom.querySelectorAll("span.text-muted-foreground")
        ).find((el) => el.innerText.trim() === "Author");
        const authorValue = authorLabel?.parentElement?.querySelector(
            ":scope span:last-child"
        );

        return authorValue?.innerText || super.extractAuthor(dom);
    }

    extractDescription() {
        return this.description.trim();
    }

    findCoverImageUrl() {
        return this.thumbnail;
    }

    findChapterTitle(dom) {
        return this.chaptersSourceTitleMap.get(dom.baseURI);
    }
}

================================================
FILE: plugin/js/parsers/WfxsParser.js
================================================

"use strict";

parserFactory.register("wfxs.tw", () => new WfxsParser());

class WfxsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = this.makeTocUrl(dom.baseURI);
        let tocHtml = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        let menu = [...tocHtml.querySelectorAll("#readerlists")].pop();
        return util.hyperlinksToChapterList(menu);
    }

    makeTocUrl(url) {
        return url.substring(0, url.length - 1)
            .replace("xiaoshuo", "booklist") + ".html";
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);        
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".booktitle h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#bookimg");
    }

    async fetchChapter(url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        newDoc.content.appendChild(this.findRawContent(dom));
        let nextPageUrl = this.findNextPageUrl(dom);
        while (nextPageUrl != null) {
            dom = (await HttpClient.wrapFetch(nextPageUrl)).responseXML;
            newDoc.content.appendChild(this.findRawContent(dom));
            nextPageUrl = this.findNextPageUrl(dom);
        }
        return newDoc.dom;
    }

    findRawContent(dom) {
        return dom.querySelector(".chapter-content");
    }

    findNextPageUrl(dom) {
        let link = [...dom.querySelectorAll(".foot-nav a")]
            .map(l => l.href)[2];
        return ((link != null)  && link.endsWith(".html"))
            ? link
            : null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#intro_win p")];
    }
}

================================================
FILE: plugin/js/parsers/WikipediaParser.js
================================================

/*
  Parses files on wikipedia.org
*/
"use strict";

parserFactory.registerUrlRule(
    url => util.extractHostName(url).endsWith(".wikipedia.org"),
    () => new WikipediaParser()
);

parserFactory.registerManualSelect(
    "Wikipedia",
    () => new WikipediaParser()
);

class WikipediaParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        // special case, just return URL of current page
        let chapter = {
            sourceUrl:  dom.baseURI,
            title: dom.title
        };
        return Promise.resolve([chapter]);
    }

    // returns the element holding the story content in a chapter
    findContent(dom) {
        return dom.getElementById("bodyContent");
    }

    removeUnwantedElementsFromContentElement(element) {
        super.removeUnwantedElementsFromContentElement(element);
        this.removeEditElements(element);
        this.removeExternalLinkTables(element);
        this.removeExternalHyperlinks(element);
    }

    removeEditElements(element) {
        util.removeElements(element.querySelectorAll("span.mw-editsection"));
    }

    removeExternalLinkTables(element) {
        util.removeElements(element.querySelectorAll("div.navbox"));
    }

    removeExternalHyperlinks(element) {
        for (let a of util.getElements(element, "a", e => !this.isLinkToKeep(e))) {
            this.replaceHyperlinkWithTextContent(a);
        }
    }
    
    isLinkToKeep(hyperlink) {
        return !util.isNullOrEmpty(hyperlink.hash) ||
            (hyperlink.querySelector("img, image") !== null);
    }

    replaceHyperlinkWithTextContent(hyperlink) {
        let newText = hyperlink.textContent;
        if (util.isNullOrEmpty(newText)) {
            hyperlink.remove();
        } else {
            let textNode = hyperlink.ownerDocument.createTextNode(newText);
            hyperlink.replaceWith(textNode);
        }
    }
}

================================================
FILE: plugin/js/parsers/WixParser.js
================================================

/*
   parser for*.wixsite.com
   This site unusual as it does not put the content directly in the HTML for each "chapter/page".
   Instead the javascript in the chapter/page makes an AJAX/REST call to get the content.
   So, this parser needs to obtain the URL for the AJAX/REST calls for the content and use them.
*/
"use strict";

parserFactory.registerUrlRule(
    url => util.extractHostName(url).endsWith(".wixsite.com"),
    () => new WixParser()
);

class WixParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        this.mapPageUrltoRestUrl = this.buildMapOfPageUrltoRestUrlWithContent(dom);
        let chapters = util.hyperlinksToChapterList(dom.body);
        this.mapPageUrlToPageTitle = this.buildMapOfPageUrlsToPageTitles(chapters);
        return Promise.resolve(chapters);
    }

    buildMapOfPageUrltoRestUrlWithContent(dom) {
        let json = this.findJsonWithRestUrls(dom);
        return this.extractRestUrlsFromJson(json);
    }

    findJsonWithRestUrls(dom) {
        for (let script of dom.querySelectorAll("script")) {
            let text = script.textContent;
            let json = util.locateAndExtractJson(text, "var publicModel =");
            if (json != null) {
                return json;
            }
        }
    }    

    extractRestUrlsFromJson(json) {
        let topology = json.pageList.topology[0];
        let urlsFromPage = function(page) {
            return { 
                pageUrl: json.externalBaseUrl + "/" + page.pageUriSEO,
                restUrl: topology.baseUrl + 
                    topology.parts.replace("{filename}",  page.pageJsonFileName)
            };
        };
        return json.pageList.pages
            .map(page => urlsFromPage(page))
            .reduce((acc, urls) => acc.set(urls.pageUrl, urls.restUrl), new Map());
    }

    buildMapOfPageUrlsToPageTitles(chapters) {
        return chapters.reduce((acc, c) => acc.set(c.sourceUrl, c.title), new Map());
    }

    findContent(dom) {
        return dom.querySelector("div");
    }

    async fetchChapter(url) {
        let restUrl = this.mapPageUrltoRestUrl.get(url);
        let handler = await HttpClient.fetchJson(restUrl);
        let content = this.findContentInJson(handler.json);
        return this.constructDoc(content, url);
    }
    
    findContentInJson(json) {
        // find names of the document_data fields holding content
        let contentFieldNames = json.structure.components
            .filter(c => c.styleId === "txtNew")
            .map(f => f.dataQuery.substring(1));
 
        // get content   
        let content = contentFieldNames.map(f => json.data.document_data[f].text);
       
        // assume longest content is the story
        return content.reduce((a, b) => (a.length > b.length) ? a : b );        
    }

    constructDoc(content, url) {
        let html = "<html><head><title></title><body><div>" +
            "<h1>" + this.mapPageUrlToPageTitle.get(url) + "</h1>" +
            content + 
            "</div></body></html>";
        let doc = util.sanitize(html);
        doc.baseUrl = url;
        return doc;
    }
}

================================================
FILE: plugin/js/parsers/WLPublishingParser.js
================================================

/*
  Parser for World Literature Publishing websites
*/

"use strict";

parserFactory.register("finestories.com", () => new WLPublishingParser());
parserFactory.register("scifistories.com", () => new WLPublishingParser());
parserFactory.register("storiesonline.net", () => new WLPublishingParser());

parserFactory.registerManualSelect(
    "WLPublishing",
    () => new WLPublishingParser()
);

class WLPublishingParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let index = dom.querySelector("div#index-list");
        if (index === null) {
            let baseUrl = this.getBaseUrl(dom);
            return this.singleChapterStory(baseUrl, dom);
        }
        for (let link of index.querySelectorAll("a")) {
            if (link.hasAttribute("title") && (link.getAttribute("title") === "download")) {
                link.remove();
            }
        }
        return util.hyperlinksToChapterList(index);
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractAuthor(dom) {
        let title = dom.querySelector("title").textContent;
        if (title != null) {
            return title.substring(0, title.indexOf(":"));
        }
        return super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.date");
        util.removeChildElementsMatchingSelector(element, "span.conTag");
        util.removeChildElementsMatchingSelector(element, "span.curr");
        util.removeChildElementsMatchingSelector(element, "div.pager");
        util.removeChildElementsMatchingSelector(element, "div.end-note");
        util.removeChildElementsMatchingSelector(element, "div.vform");
        util.removeChildElementsMatchingSelector(element, "div.sale-link");
        util.removeChildElementsMatchingSelector(element, "div.reco");
        util.removeChildElementsMatchingSelector(element, ".end");
        util.removeChildElementsMatchingSelector(element, "h4.c");
        util.removeMicrosoftWordCrapElements(element);
        util.removeScriptableElements(element);
        util.removeComments(element);
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h2");
    }

    async fetchChapter(url) {
        let chapterDom = (await HttpClient.wrapFetch(url)).responseXML;
        let extraURLs = WLPublishingParser.findURLsOfChapterPages(chapterDom);
        for (let pageUrl of extraURLs) {
            let pageDom = (await HttpClient.wrapFetch(pageUrl)).responseXML;
            chapterDom = this.addPageToChapter(chapterDom, pageDom);
        }
        return chapterDom;
    }

    /*
      Chapters are composed of multiple pages.
      There are links to all of the pages in the chapter at the top and bottom of each page.
      Along with the link to each page of the chapter, there is a link to the next page, which is a duplicate.
      Single page chapters have no pager element.
    */
    static findURLsOfChapterPages(dom) {
        let urls = [];
        let pager = dom.querySelector("div.pager");
        if (pager) {
            for (let link of pager.querySelectorAll("a")) {
                if (link.textContent != "Next") {
                    urls.push(link.href);
                }
            }
        }
        return urls;
    }

    addPageToChapter(chapterDom, pageDom) {
        let chapterContent = this.findContent(chapterDom);
        let pageContent = this.findContent(pageDom);
        while (pageContent.childNodes.length > 0) {
            let child = pageContent.childNodes[0];
            // The chapter title appears on each page in the chapter and we only want it from the first.
            if ((child.tagName == "H1") || (child.tagName == "H2")) {
                child.remove();
            } else {
                chapterContent.appendChild(child);
            }
        }
        return chapterDom;
    }
}

================================================
FILE: plugin/js/parsers/WnmtlOrgParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("wnmtl.org", () => new WnmtlOrgParser());

class WnmtlOrgParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let bookId = this.idFromUrl(dom.baseURI);
        let tocUrl = this.makeTocUrl(bookId, 1);
        let data = (await HttpClient.fetchJson(tocUrl)).json.data;
        let chapters = this.extractPartialChapterListFromJson(data);
        for (let url of this.makeUrlsOfTocPages(bookId, data.totalPages)) {
            data = (await HttpClient.fetchJson(url)).json.data;
            let partialList = this.extractPartialChapterListFromJson(data);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    idFromUrl(url) {
        return new URL(url).pathname.split("/").pop().split("-")[0];
    }

    makeTocUrl(bookId, page) {
        return "https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/page?sortDirection=ASC" +
            `&bookId=${bookId}&pageNumber=${page}&pageSize=100`;
    }

    makeUrlsOfTocPages(bookId, totalPages) {
        let urls = [];
        for (let page = 2; page <= totalPages; ++page) {
            urls.push(this.makeTocUrl(bookId, page));
        }
        return urls;
    }

    extractPartialChapterListFromJson(data) {
        return data.list.map(e => ({
            sourceUrl:  `https://wnmtl.org/chapter/${e.id}-dummy`,
            title: `${e.chapterOrder}. ${e.title}`
        }));
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-name");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-name");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.cover");
    }

    async fetchChapter(url) {
        let restUrl = this.calcRestUrlForContent(url);
        let data = (await HttpClient.fetchJson(restUrl)).json.data;
        return WnmtlOrgParser.buildChapter(data, url);
    }

    calcRestUrlForContent(url) {
        // assumes chapter URL like https://wnmtl.org/chapter/148888-untitled
        // and REST URL like https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/148888
        let id = this.idFromUrl(url);
        return `https://api.mystorywave.com/story-wave-backend/api/v1/content/chapters/${id}`;
    }

    static buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = `${json.chapterOrder}. ${json.title}`;
        newDoc.content.appendChild(title);
        let paragraphs = json.content.split("\n")
            .filter(p => !util.isNullOrEmpty(p));
        for (let text of paragraphs) {
            let p = newDoc.dom.createElement("p");
            p.appendChild(newDoc.dom.createTextNode(text));
            newDoc.content.appendChild(p);
        }
        return newDoc.dom;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#about-panel")];
    }
}

================================================
FILE: plugin/js/parsers/WnmtlParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("wnmtl.com", () => new WnmtlParser());
class WnmtlParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let items = [...dom.querySelectorAll("article div.t a")]
            .filter(link => link.parentElement.parentElement.className !== "text-mutedxxx")
            .map(link => util.hyperLinkToChapter(link));
        return Promise.resolve(items);
    }

    findContent(dom) {
        util.removeElements(dom.querySelectorAll("div#ct div.article-social"));
        return dom.querySelector("div#ct");
    }

    // title of the story  (not to be confused with title of each chapter)
    extractTitleImpl(dom) {
        return dom.querySelector("article header h2, article header h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.article-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "p.focus");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("article p.time, article p.note")];
    }
}

================================================
FILE: plugin/js/parsers/WoopreadParser.js
================================================

"use strict";

parserFactory.register("woopread.com", () => new WoopreadParser());

class WoopreadParser extends Parser {
    constructor() {
        super();
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.text-3xl");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.relative .text-text-secondary")];
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.mb-4:nth-of-type(4) a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.relative");
    }

    async getChapterUrls(dom) {
        const chapterLinks = [...dom.querySelectorAll("main.grow .notranslate .mt-8 .grid-cols-1 a")];
        const chapterTitles = [...dom.querySelectorAll("main.grow .line-clamp-2")];

        let chapterList = [];
        for (let i = 0; i < chapterLinks.length; i++) {
            chapterList.push({
                sourceUrl: chapterLinks[i].href,
                title: chapterTitles[i].textContent,
            });
        }

        return chapterList.reverse();
    }
    
    findChapterTitle(dom) {
        return dom.querySelector("h2.text-2xl");
    }

    findContent(dom) {
        return dom.querySelector("div[id^='chapter']");
    }
}

================================================
FILE: plugin/js/parsers/WordexcerptParser.js
================================================

"use strict";

parserFactory.register("wordexcerpt.com", () => new WordexcerptParser());

class WordexcerptParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.listing-chapters_wrap");
        return Promise.resolve(util.hyperlinksToChapterList(menu).reverse());
    }

    findContent(dom) {
        return dom.querySelector("div.reading-content div.text-left");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.post-title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.author-content a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    removeUnwantedElementsFromContentElement(element) {
        let ads = [...element.querySelectorAll("div.adsbyvli")]
            .map(e => e.parentElement)
            .filter(p => p.tagName.toUpperCase() === "CENTER");
        util.removeElements(ads);
        for (let node of util.getElements(element, "B:IF")) {
            util.flattenNode(node);
        }
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("ol.breadcrumb li.active").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.summary_image");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.summary__content p")];
    }
}

================================================
FILE: plugin/js/parsers/WordpressBaseParser.js
================================================

/*
  Basic functionality for parsing wordpress (I hope)
*/
"use strict";

parserFactory.register("bakapervert.wordpress.com", () => new WordpressBaseParser());
parserFactory.register("crimsonmagic.me", () => new WordpressBaseParser());
parserFactory.register("shalvationtranslations.wordpress.com", () => new WordpressBaseParser());
parserFactory.register("frostfire10.wordpress.com", () => new WordpressBaseParser());
parserFactory.register("isekaicyborg.wordpress.com", () => new WordpressBaseParser());
parserFactory.register("moonbunnycafe.com", () => new WordpressBaseParser());
//dead url
parserFactory.register("rainingtl.org", () => new WordpressBaseParser());
//dead url
parserFactory.register("raisingthedead.ninja", () => new WordpressBaseParser());
//dead url
parserFactory.register("skythewoodtl.com", () => new WordpressBaseParser());
//dead url
parserFactory.register("yoraikun.wordpress.com", () => new WordpressBaseParser());
parserFactory.register("wanderertl130.id", () => new Wanderertl130Parser());
parserFactory.register("sasakitomyiano.wordpress.com", () => new WordpressBaseParser());

parserFactory.registerRule(
    // return probability (0.0 to 1.0) web page is a Wordpress page
    function(url, dom) {
        return ((WordpressBaseParser.findContentElement(dom) != null) &&
            (WordpressBaseParser.findChapterTitleElement(dom) != null)) * 0.5;
    },
    () => new WordpressBaseParser()
);

parserFactory.registerManualSelect(
    "Wordpress",
    () => new WordpressBaseParser()
);

class WordpressBaseParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let content = this.findContent(dom).cloneNode(true);
        this.removeUnwantedElementsFromContentElement(content);
        return util.hyperlinksToChapterList(content);
    }

    static findContentElement(dom) {
        return dom.querySelector("div.entry-content") ||
            dom.querySelector("div.post-content") ||
            dom.querySelector("ul.wp-block-post-template") ||
            dom.querySelector(".wp-block-cover__inner-container");
    }

    // find the node(s) holding the story content
    findContent(dom) {
        return WordpressBaseParser.findContentElement(dom);
    }

    findParentNodeOfChapterLinkToRemoveAt(link) {
        // "next" and "previous" chapter links may be inside <strong> then <p> tag
        let toRemove = util.moveIfParent(link, "strong");
        return util.moveIfParent(toRemove, "p");
    }

    static findChapterTitleElement(dom) {
        return dom.querySelector(".entry-title") ||
            dom.querySelector(".page-title") ||
            dom.querySelector("header.post-title h1") ||
            dom.querySelector(".post-title") ||
            dom.querySelector("#chapter-heading") ||
            dom.querySelector(".wp-block-post-title");
    }

    findChapterTitle(dom) {
        return WordpressBaseParser.findChapterTitleElement(dom);
    }
}

class Wanderertl130Parser extends  WordpressBaseParser {
    constructor() {
        super();
    }

    preprocessRawDom(webPageDom) {
        let content = this.findContent(webPageDom);
        let footnotes = [...webPageDom.querySelectorAll("span.modern-footnotes-footnote__note")];
        this.moveFootnotes(webPageDom, content, footnotes);
    }
}

================================================
FILE: plugin/js/parsers/WorldnovelOnlineParser.js
================================================

"use strict";

parserFactory.register("worldnovel.online", () => new WorldnovelOnlineParser());

class WorldnovelOnlineParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let chapters = [];
        let category = dom.body.getAttribute("attr");
        let numTocPages = [...dom.querySelectorAll("div[data-paged]")].length;
        for (let page = 1; page <= numTocPages; ++page) {
            let url = "https://www.worldnovel.online/wp-json/novel-id/v1/dapatkan_chapter_dengan_novel?category=" + 
                category + "&perpage=100&order=ASC&paged=" + page;
            let partialList = (await HttpClient.fetchJson(url)).json
                .map(this.jsonToChapter);
            chapterUrlsUI.showTocProgress(partialList);
            chapters = chapters.concat(partialList);
        }
        return chapters;
    }

    jsonToChapter(json) {
        return {
            sourceUrl: json.permalink,
            title: json.post_title,
            newArc: null
        };
    }

    findContent(dom) {
        return dom.querySelector("div#soop");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("li.breadcrumb-item.active");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".code-block, ins, .chapternav, a[href='javascript:void(0)']");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h3.post-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "main#main div.container");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#maintab div.post-content")];
    }
}

================================================
FILE: plugin/js/parsers/WtnovelsParser.js
================================================

"use strict";

parserFactory.register("wtnovels.com", () => new WtnovelsParser());

class WtnovelsParser extends WordpressBaseParser { // eslint-disable-line no-unused-vars
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = this.extractPartialChapterList(dom);
        let urlsOfTocPages  = this.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            this.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    extractPartialChapterList(dom) {
        return [...dom.querySelectorAll("div.chapters-list a")]
            .map(link => ({
                sourceUrl: link.href,
                title: link.querySelector("h3").textContent,
                isIncludeable: link.querySelector(".chapter-paid-points") == null
            }));
    }

    getUrlsOfTocPages(dom) {
        let tocUrls = [];
        let link = [...dom.querySelectorAll("nav.cgl-pagination a.cgl-page")].pop()?.href;
        if (link) {
            let splitUrl = link.split("/");
            if (splitUrl.length >= 7) {
                let maxPage = parseInt(splitUrl[6]);
                for (let i = 2; i <= maxPage; ++i) {
                    splitUrl[6] = i;
                    tocUrls.push(splitUrl.join("/"));
                }
            }
        }
        return tocUrls;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.novel-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".novel-header");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".novel-summary-initial")];
    }
}

================================================
FILE: plugin/js/parsers/WtrlabParser.js
================================================

"use strict";

parserFactory.register("wtr-lab.com", () => new WtrlabParser());

class WtrlabParser extends Parser {
    constructor() {
        super();
        this.minimumThrottle = 12000;
    }

    populateUIImpl() {
        document.getElementById("removeChapterNumberRow").hidden = false; 
        // raw download no longer supported as the raw text is encoded and i don't know how.
        // leaving old code in case it gets solved.
        // document.getElementById("selectTranslationAiRow").hidden = false;
        document.getElementById("selectRetryLongerRow").hidden = false;  
    }

    async getChapterUrls(dom) {
        let json = dom.querySelector("script#__NEXT_DATA__")?.textContent;
        json = JSON.parse(json);
        this.magickey = json?.buildId;
        let leaves = dom.baseURI.split("/");
        let novelIndex = leaves.indexOf("novel");
        let language = leaves[novelIndex - 1];
        let id = leaves[novelIndex + 1];
        let slug = leaves[leaves.length - 1].split("?")[0];
        this.slug = slug;
        let chapters = (await HttpClient.fetchJson("https://wtr-lab.com/api/chapters/" + id)).json;
        let serie_id = chapters.chapters[0].serie_id;
        try {
            let terms = (await HttpClient.fetchJson("https://wtr-lab.com/api/v2/user/config")).json;
            terms = terms?.config?.terms.filter(a => (a[4] == null) || (a[4].includes(serie_id)));
            terms = terms.map(a => ({from:a[2].split("|"), to:a[1]}));
            let index = 0;
            this.terms = [];
            for (let i = 0; i < terms.length; i++) {
                for (let j = 0; j < terms[i].from.length; j++) {
                    this.terms[index] = ({from: terms[i].from[j], to: terms[i].to});
                    index++;
                }
            }

        } catch (error) {
            this.terms = [];
        }
        return chapters.chapters.map(a => ({
            sourceUrl: "https://wtr-lab.com/"+language+"/novel/"+id+"/"+slug+"/chapter-"+a.order, 
            title: (document.getElementById("removeChapterNumberCheckbox").checked)?a.title:a.order+": "+a.title
        }));
    }


    async loadEpubMetaInfo(dom) {
        let json = dom.querySelector("script#__NEXT_DATA__")?.textContent;
        json = JSON.parse(json);
        this.img = json?.props.pageProps.serie.serie_data.data.image;
        return;
    }

    formatTitle(link) {
        let span = link.querySelector("span").textContent.trim();
        let num = link.querySelector("b").textContent.trim().replace("#", "");
        return num + ": " + span;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl() {
        return this.img;
    }

    extractSubject(dom) {
        let tagsgenre = [...dom.querySelectorAll("span.genre")].map(a => a.textContent);
        let tagstags = [...dom.querySelectorAll(".tags a.tag")].map(a => a.textContent.replace(",", ""));
        let tags = tagsgenre;
        tags = tags.concat(tagstags);
        return tags.map(e => e.trim()).join(", ");
    }

    extractDescription(dom) {
        let desc = dom.querySelector("span.description");
        return desc.textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#contents-tabpane-about")];
    }

    async fetchChapter(url) {
        let leaves = url.split("/");
        let novelIndex = leaves.indexOf("novel");
        let language = leaves[novelIndex - 1];
        let id = leaves[novelIndex + 1];
        let chapterPart = leaves[leaves.length - 1];
        let chapter = chapterPart.startsWith("chapter-")
            ? chapterPart.slice(8)
            : chapterPart;
        let fetchUrl = "https://wtr-lab.com/api/reader/get";
        let formData = 
            {
                "translate":"ai",
                "language":language,
                "raw_id":id,
                "chapter_no":chapter,
                "retry":false,
                "force_retry":false
            };
        let header = {"Content-Type": "application/json;charset=UTF-8"};
        let options = {
            method: "POST",
            body: JSON.stringify(formData),
            headers: header,
            parser: this
        };
        let json = (await HttpClient.fetchJson(fetchUrl, options)).json;
        return this.buildChapter(json, url);
    }
    isCustomError(response) {
        if (response.json.data?.data?.body?false:true) {
            return true;
        }
        if (response.json.requireTurnstile) {
            return true;
        }
        return false;
    }

    setCustomErrorResponse(url, wrapOptions, checkedresponse) {
        if (checkedresponse.json.requireTurnstile || checkedresponse.json.code == 1401) {
            let newresp = {};
            newresp.url = url;
            newresp.wrapOptions = wrapOptions;
            newresp.response = {};
            newresp.response.url = this.PostToUrl(checkedresponse.response.url, JSON.parse(wrapOptions.fetchOptions.body));
            newresp.response.status = 403;
            return newresp;
        } else {
            let newresp = {};
            newresp.url = url;
            newresp.wrapOptions = wrapOptions;
            newresp.response = {};
            newresp.response.url = this.PostToUrl(checkedresponse.response.url, JSON.parse(wrapOptions.fetchOptions.body));
            newresp.response.status = 999;
            if (document.getElementById("selectRetryLongerCheckbox").checked) {
                newresp.response.retryDelay = [80,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120];
            } else {
                newresp.response.retryDelay = [80,40,25,25,25];
            }
            newresp.errorMessage = "Fetch of URL '"+newresp.response.url+"' failed.\nThe server sends an empty Chapter try to open the URL and try again if you can see the Chapter on the normal website.\nIt could also be that you try to get an Ai translated novel that isn't Ai tranlated.";
            return newresp;
        }
    }

    PostToUrl(url, body) {
        let hostname = new URL(url).hostname;
        let translate = body.translate;
        let language = body.language;
        let raw_id = body.raw_id;
        let chapter_no = body.chapter_no;
        return "https://"+hostname+"/"+language+"/novel/"+raw_id+"/"+this.slug+"/chapter-"+chapter_no+"?service="+translate;
    }

    buildChapter(json, url) {
        let leaves = url.split("/");
        let chapter = leaves[leaves.length - 1].replace("chapter-","");
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = ((document.getElementById("removeChapterNumberCheckbox").checked)?"":chapter+": ")+json.chapter.title;
        newDoc.content.appendChild(title);
        let br = newDoc.dom.createElement("br");
        let imagecounter = 0;
        for (let element of json.data.data.body) {
            if (element == "[image]") {
                let imgnode = newDoc.dom.createElement("img");
                let imghref = json.data.data?.images?.[imagecounter++]??"";
                if (imghref == "") {
                    continue;
                }
                imgnode.src = imghref;
                newDoc.content.appendChild(imgnode);
            } else {
                let pnode = newDoc.dom.createElement("p");
                let newtext = element;
                // replace provided translation with custom one
                for (let i = 0; i < json?.data?.data?.glossary_data?.terms?.length??0; i++) {
                    for (let term of this.terms) {
                        if ((json.data.data.glossary_data.terms[i][1]??"") == term?.from) {
                            json.data.data.glossary_data.terms[i][0] = term?.to;
                        }
                    }
                }
                // replace with provided translation
                for (let i = 0; i < json?.data?.data?.glossary_data?.terms?.length??0; i++) {
                    let term = json.data.data.glossary_data.terms[i][0]??"※"+i+"⛬";
                    newtext = newtext.replaceAll("※"+i+"⛬", term);
                    newtext = newtext.replaceAll("※" + i + "〓", term);
                }
                // replace custom terms
                for (let term of this.terms) {
                    newtext = newtext.replaceAll(term?.from, term?.to);
                }
                pnode.textContent = newtext;
                newDoc.content.appendChild(pnode);
            }
            newDoc.content.appendChild(br);
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/WuxiaBlogParser.js
================================================

"use strict";

parserFactory.register("wuxia.blog", () => new WuxiaBlogParser());

class WuxiaBlogParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom, chapterUrlsUI) {
        let tocPage1chapters = WuxiaBlogParser.extractPartialChapterList(dom);
        let urlsOfTocPages  = WuxiaBlogParser.getUrlsOfTocPages(dom);
        return (await this.getChaptersFromAllTocPages(tocPage1chapters,
            WuxiaBlogParser.extractPartialChapterList,
            urlsOfTocPages,
            chapterUrlsUI
        )).reverse();
    }

    static extractPartialChapterList(dom) {
        let menu = dom.querySelector("tbody#chapters");
        return util.hyperlinksToChapterList(menu);
    }

    static getUrlsOfTocPages(dom) {
        let urls = [];
        let paginationUrl = WuxiaBlogParser.getLastPaginationUrl(dom);
        if (paginationUrl !== null) {
            let index = paginationUrl.lastIndexOf("/");
            let maxPage = parseInt(paginationUrl.substring(index + 1));
            let prefix = paginationUrl.substring(0, index + 1);
            for (let i = 2; i <= maxPage; ++i) {
                urls.push(prefix + i);
            }
        }
        return urls;
    }

    static getLastPaginationUrl(dom) {
        let urls = [...dom.querySelectorAll("ul.pagination li a")];
        return (0 === urls.length) ? null : urls.pop().href;
    }

    findContent(dom) {
        return dom.querySelector("div.article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h4.panel-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "ul.pager, button, div.recently-nav, div.fb-like");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.imageCover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div[itemprop='description']")];
    }
}

================================================
FILE: plugin/js/parsers/WuxiacityParser.js
================================================

"use strict";

parserFactory.register("wuxia.city", () => new WuxiacityParser());

class WuxiacityParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        if (!dom.baseURI.endsWith("/table-of-contents")) {
            dom = (await HttpClient.wrapFetch(dom.baseURI + "/table-of-contents")).responseXML;
        }
        return [...dom.querySelectorAll("ul.chapters a")]
            .reverse()
            .map(WuxiacityParser.linkToChapter);
    }

    static linkToChapter(link) {
        return ({
            sourceUrl:  link.href,
            title: link.querySelector(".chapter-name").textContent.replace(/\n/g, " ")
        });
    }

    findContent(dom) {
        return dom.querySelector("#chapter-content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".book-name");
    }

    findChapterTitle(dom) {
        return dom.querySelector(".chapter-title p").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.book-synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/WuxiaworldCoParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("wuxiaworld.co", () => new WuxiaworldCoParser());
//dead url
parserFactory.register("m.wuxiaworld.co", () => new WuxiaworldCoParser());
//dead url
parserFactory.register("novelupdates.cc", () => new WuxiaworldCoParser());

class WuxiaworldCoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let list = dom.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(list);
    }

    findContent(dom) {
        return dom.querySelector("div.section-list");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.book-name");
    }

    extractAuthor(dom) {
        return dom.querySelector("div.author span.name").textContent;
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.book-img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.synopsis")];
    }
}

================================================
FILE: plugin/js/parsers/WuxiaworldeuParser.js
================================================

"use strict";

parserFactory.register("wuxiaworld.eu", () => new WuxiaworldeuParser());
parserFactory.register("wuxia.click", () => new WuxiaworldeuParser());

class WuxiaworldeuParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let host = new URL(dom.baseURI).host;
        let tocUrl = dom.baseURI.replace("/novel/", "/api/chapters/") + "/";
        let json = (await HttpClient.fetchJson(tocUrl)).json;
        return json.map(j => this.toChapter(j, host));
    }

    toChapter(json, host) {
        return ({
            sourceUrl:  `https://${host}/chapter/${json.novSlugChapSlug}`,
            title: json.title
        });
    }

    findContent(dom) {
        return dom.querySelector("#chapterText")?.parentElement?.parentElement;
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h5");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "div.mantine-Group-root, div.mantine-Container-root");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.mantine-Image-imageWrapper");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".mantine-Spoiler-root")];
    }
}

================================================
FILE: plugin/js/parsers/WuxiaworldParser.js
================================================

/*
  Parses <www.wuxiaworld.com>
*/
"use strict";

parserFactory.register("wuxiaworld.com", () => new WuxiaworldParser());

class WuxiaworldParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let chapters = [];
        let chaptersElement = dom.querySelector("div.content div.panel-group");
        if (chaptersElement != null) {
            chapters = util.hyperlinksToChapterList(chaptersElement, 
                WuxiaworldParser.isChapterHref, WuxiaworldParser.getChapterArc);
            WuxiaworldParser.removeArcsWhenOnlyOne(chapters);
        }
        if (0 == chapters.length) {
            chapters = [...dom.querySelectorAll("li.chapter-item a")]
                .map(link => util.hyperLinkToChapter(link));
        }
        return Promise.resolve(chapters);  
    }

    static isChapterHref(link) {
        let parent = link.parentNode;
        return (parent.tagName.toLowerCase() === "li")
            && (parent.className === "chapter-item");
    }

    static getChapterArc(link) {
        let isPanel = function(element) {
            return (element.tagName.toLowerCase() === "div")
                && (element.className === "panel panel-default");
        };
        
        let parent = link;
        do {
            parent = parent.parentNode;
            if (parent == null) {
                return null;
            }
        } while (!isPanel(parent));
        
        let arc = parent.querySelector("span.title a");
        return arc == null ? null : arc.textContent.trim();
    }

    static removeArcsWhenOnlyOne(chapters) {
        let arcCount = chapters.reduce((p, c) => p + (c.newArc != null), 0);
        if (arcCount < 2) {
            chapters.forEach(c => c.newArc = null);
        }
    }

    // find the node(s) holding the story content
    findContent(dom) {
        let candidates = [...dom.querySelectorAll("div.fr-view:not(.panel-body)")];
        let content = WuxiaworldParser.elementWithMostParagraphs(candidates);
        this.cleanContent(content);
        return content;
    }

    static elementWithMostParagraphs(elements) {
        if (elements.length === 0) {
            return null;
        }
        return elements.map(
            e => ({e: e, numParagraphs: [...e.querySelectorAll("p")].length})
        ).reduce(
            (a, c) => a.numParagraphs < c.numParagraphs ? c : a
        ).e;
    }

    cleanContent(content)
    {
        util.removeChildElementsMatchingSelector(content, "button, #spoiler_teaser");
        let toDelete = [...content.querySelectorAll("a")]
            .filter(a => a.textContent === "Teaser");
        util.removeElements(toDelete);
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.caption h4");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.novel-index");
    }

    getInformationEpubItemChildNodes(dom) {
        let nodes = [...dom.querySelectorAll("div.media-novel-index div.media-body")];
        let summary = [...dom.querySelectorAll("div.fr-view")];
        nodes.push(summary[1]);
        return nodes;
    }
}

================================================
FILE: plugin/js/parsers/WuxiaworldWorldParser.js
================================================

/*
*/
"use strict";

//dead url/ parser
parserFactory.register("wuxiaworld.world", () => new WuxiaworldWorldParser());

class WuxiaworldWorldParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("div.manga_chapter_list");
        return Promise.resolve(util.hyperlinksToChapterList(menu).reverse());
    }

    findContent(dom) {
        return dom.querySelector("div.list_img");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.manga_name h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("div.manga_des a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.manga_view_name h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div.manga_info_img");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.manga_description")];
    }
}

================================================
FILE: plugin/js/parsers/WxscsPaser.js
================================================

"use strict";

parserFactory.register("wxscs.com", () => new WxscsParser());

class WxscsParser extends Parser {
    constructor() {
        super();
        this.state.indexDom = null;
        this.state.indexUrl = null;
    }

    async onLoadFirstPage(url, firstPageDom) {
        // If we're on a chapter page, fetch and cache the index page
        if (!firstPageDom.querySelector("div#all-chapter")) {
            let bookId = this.extractBookId(firstPageDom);
            if (bookId) {
                this.state.indexUrl = `https://www.wxscs.com/book/${bookId}/`;
                this.state.indexDom = (await HttpClient.wrapFetch(this.state.indexUrl)).responseXML;
                // Update firstPageDom to be the index page
                firstPageDom = this.state.indexDom;
                url = this.state.indexUrl;
            }
        } else {
            // We're already on the index page
            this.state.indexDom = firstPageDom;
            this.state.indexUrl = url;
        }

        this.state.firstPageDom = firstPageDom;
        this.state.chapterListUrl = url;
        
        super.onLoadFirstPage(url, firstPageDom);
    }

    async getChapterUrls(dom) {
        // Extract urls from the chapter list div if it exists
        let chapterList = dom.querySelector("div#all-chapter");
        if (!chapterList && this.state.indexDom) {
            // We're on a chapter page and have cached index, use its chapter list
            chapterList = this.state.indexDom.querySelector("div#all-chapter");
        }
        
        if (chapterList) {
            return [...chapterList.querySelectorAll(".panel-body a")]
                .map(a => util.hyperLinkToChapter(a));
        }
        return [];
    }

    // Get the actual content by handling pagination
    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let extraPages = this.getExtraPageUrls(dom);
        return this.fetchAndAddExtraContent(dom, extraPages);
    }

    // Extract urls of additional pages from the pagination div
    getExtraPageUrls(dom) {
        let urls = [];
        let pagination = dom.querySelector("div.page");
        if (pagination) {
            let pages = [...pagination.querySelectorAll("ul.pagination li a")]
                .map(a => a.href)
                .filter(h => h); // Filter out any null/empty urls
            urls.push(...pages);
        }
        return urls;
    }

    // Fetch additional pages and combine content
    async fetchAndAddExtraContent(dom, extraPages) {
        let mainContent = this.findContent(dom);
        
        for (let pageUrl of extraPages) {
            try {
                let pageDom = (await HttpClient.wrapFetch(pageUrl)).responseXML;
                let pageContent = this.findContent(pageDom);
                if (pageContent) {
                    // Append the content from additional pages
                    mainContent.appendChild(pageContent);
                }
            } catch (error) {
                ErrorLog.log(`Failed to fetch page ${pageUrl}: ${error}`);
            }
        }
        return dom;
    }

    findContent(dom) {
        return dom.querySelector("div#cont-body");
    }

    extractBookId(dom) {
        // Try to get book ID from script tag
        let scripts = [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(s => s.includes("book.id="));
            
        if (scripts.length > 0) {
            let match = scripts[0].match(/book\.id="(\d+)"/);
            if (match) {
                return match[1];
            }
        }
        
        // Fallback: try to get from URL
        let url = new URL(dom.baseURI);
        let parts = url.pathname.split("/");
        if (parts.length >= 3 && parts[1] === "book") {
            return parts[2];
        }
        
        return null;
    }

    // Get chapter title from h1 element
    findChapterTitle(dom) {
        return dom.querySelector("h1.cont-title");
    }

    // Get novel title 
    extractTitleImpl(dom) {
        // Use index page title if available
        if (this.state.indexDom) {
            let indexTitle = this.state.indexDom.querySelector("h1.book-name");
            if (indexTitle) {
                return indexTitle;
            }
        }
        return dom.querySelector("h1.book-name");
    }

    findCoverImageUrl(dom) {
        // Use index page cover if available
        if (this.state.indexDom) {
            let coverImg = this.state.indexDom.querySelector(".book-img-middel");
            if (coverImg?.src) {
                return coverImg.src;
            }
        }
        let coverImg = dom.querySelector(".book-img-middel");
        if (coverImg?.src) {
            return coverImg.src;
        }
    }

    getInformationEpubItemChildNodes() {
        if (this.state.indexDom) {
            // Get book description
            let description = this.state.indexDom.querySelector("div.book-detail");
            if (description) {
                let descriptionClone = description.cloneNode(true);
                // Cleanup description
                this.removeUnwantedElementsFromContentElement(descriptionClone);
                return [descriptionClone];
            }
        }
        return [];
    }

    // Get author (optional)
    extractAuthor(dom) {
        // Try book info div (for index page)
        let authorLink = dom.querySelector("div.book-info a[href*='author']");
        if (authorLink?.textContent) {
            return authorLink.textContent;
        }

        // Try meta tag
        let metaAuthor = dom.querySelector("meta[property='og:novel:author']")?.content;
        if (metaAuthor) {
            return metaAuthor;
        }

        // Try book object in script (for chapter pages)
        let scripts = [...dom.querySelectorAll("script")]
            .map(s => s.textContent)
            .filter(s => s.includes("book.author="));
            
        if (scripts.length > 0) {
            let match = scripts[0].match(/book\.author="([^"]+)"/);
            if (match) {
                return match[1];
            }
        }

        return super.extractAuthor(dom);
    }

    removeUnwantedElementsFromContentElement(element) {
        // Remove any ads or unwanted elements here
        util.removeChildElementsMatchingSelector(element, "script");
        super.removeUnwantedElementsFromContentElement(element);
    }
}

================================================
FILE: plugin/js/parsers/XbiqugeParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("xbiquge.so", () => new XbiqugeParser());

class XbiqugeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div#list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    extractLanguage() {
        return "cn";
    }

    findChapterTitle(dom) {
        return dom.querySelector("div.bookname h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#fmimg");
    }

    async fetchChapter(url) {
        // site does not tell us gbk is used to encode text
        let options = { 
            makeTextDecoder: () => new TextDecoder("gbk") 
        };
        return (await HttpClient.wrapFetch(url, options)).responseXML;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#info")];
    }
}

================================================
FILE: plugin/js/parsers/XenforoBatchParser.js
================================================

"use strict";
parserFactory.registerManualSelect(
    "Xenforo Batch Post Parser",
    () => new XenforoBatchParser()
);

class XenforoBatchParser extends Parser {
    constructor() {
        super();
        this.cache = new FetchCache();
        this.subParser = null;
    }

    getSubParser(dom)
    {
        if (!this.subParser)
        {
            this.subParser = parserFactory.fetchByUrl(dom.baseURI);
            this.minimumThrottle = this.subParser.minimumThrottle;
        }
        return this.subParser;
    }
    
    // returns promise with the URLs of the chapters to fetch
    // promise is used because may need to fetch the list of URLs from internet
    async getChapterUrls(dom) {
        let pagingUriComponent = "page-";
        let baseURI = null;
        let pageCount = 1;
        {
            let lastPage = dom.querySelector("div.pageNav li:last-child a");
            baseURI = lastPage.baseURI;
            let pageRegexResult = /\d+\/?$/.exec(lastPage.href);
            if (pageRegexResult)
            {
                pageCount = parseInt(pageRegexResult[0]);
            }
            pagingUriComponent = new RegExp(baseURI+"(.*?)\\d+/?$").exec(lastPage.href)[1] ?? pagingUriComponent;
        }
        return [...Array(pageCount).keys()].map(index => ({ 
            sourceUrl: `${baseURI}${pagingUriComponent}${index}`,
            title: `Page ${index + 1}`
        }));
    }
    
    async fetchChapter(url) {
        let fetchedDom = await this.cache.fetch(url);
        let newDoc = Parser.makeEmptyDocForContent(url);
        [... fetchedDom.querySelectorAll("article.message")].forEach(parent => {
            let author = parent.dataset["author"];
            let postIdElement = parent.querySelector("header.message-attribution ul.message-attribution-opposite li:last-child a");
            let title = "";
            
            let chapterBody = parent.querySelector("article.message-body");
            let titleElement = parent.querySelector("span.threadmarkLabel");
            if (titleElement)
            {
                title = titleElement.textContent.trim();
            }
            else
            {
                title = postIdElement.textContent;
                let possibleTitle = chapterBody.querySelector("div.bbWrapper").firstChild.textContent;
                if (possibleTitle.length < 100) //prevent overly-long titles
                {
                    title = `${title}: ${possibleTitle}`;
                }
            }
            title = `${title} — ${author}`;
            titleElement = newDoc.dom.createElement("h1");
            titleElement.textContent = title;
            newDoc.content.appendChild(titleElement);
            util.resolveLazyLoadedImages(chapterBody, "img.lazyload");
            newDoc.content.appendChild(chapterBody);
        });
        return newDoc.dom;
    }

    isLinkToChapter(link) {
        return this.subParser.isLinkToChapter(link);
    }

    findContent(dom) {
        return this.getSubParser(dom).findContent(dom);
    }

    extractTitleImpl(dom) {
        return this.getSubParser(dom).extractTitleImpl(dom);
    }

    extractAuthor(dom) {
        return this.getSubParser(dom).extractAuthor(dom);
    }

    //addTitleToChapter(newDoc, parent) {}

    getInformationEpubItemChildNodes(dom) {
        return this.getSubParser(dom).getInformationEpubItemChildNodes(dom);
    }
}

================================================
FILE: plugin/js/parsers/XiaoshubaoParser.js
================================================

"use strict";

parserFactory.register("xiaoshubao.net", () => new XiaoshubaoParser());

class XiaoshubaoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("#list > dl > dd a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".booktitle h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("#info p a");
        return authorLabel?.textContent ?? super.extractAuthor(dom);
    }

    extractLanguage() {
        return "zh";
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "p.to_nextpage");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".bookname h1");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "#fmimg");
    }

    async fetchChapter(url) {
        return this.walkPagesOfChapter(url, this.moreChapterTextUrl);
    }

    moreChapterTextUrl(dom) {
        let nextUrl = dom.querySelector("p.to_nextpage a");
        return (nextUrl != null && nextUrl.href.includes("_"))
            ? nextUrl.href
            : null;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("#intro")];
    }
}

================================================
FILE: plugin/js/parsers/XiaoshuoguiParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("xiaoshuogui.com", () => new XiaoshuoguiParser());

class XiaoshuoguiParser extends Parser {
    constructor() {
        super();
    }

    getChapterUrls(dom) {
        let menu = dom.querySelector("#chapterList");
        return Promise.resolve(util.hyperlinksToChapterList(menu));
    }

    findContent(dom) {
        return dom.querySelector("div#mlfy_main_text");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("div.d_title h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector("span.p_author a");
        return (authorLabel === null) ? super.extractAuthor(dom) : authorLabel.textContent;
    }

    extractLanguage() {
        return "zh";
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, "div#bookinfo");
    }

    fetchChapter(url) {
        // site does not tell us gb18030 is used to encode text
        return HttpClient.wrapFetch(url, this.makeOptions()).then(function(xhr) {
            return Promise.resolve(xhr.responseXML);
        });
    }

    makeOptions() {
        return ({
            makeTextDecoder: () => new TextDecoder("gb18030")
        });
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div#bookinfo div.bookright")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "script");
    }
}

================================================
FILE: plugin/js/parsers/XiaxuenovelsParser.js
================================================

"use strict";

parserFactory.register("xiaxuenovels.xyz", () => new XiaxuenovelsParser());

class XiaxuenovelsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        return [...dom.querySelectorAll("div.sp-body a")]
            .map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div.post-title");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, ".cb_p6_patreon_button, "+
            ".jp-relatedposts, xiaxu-after-content");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".entry-content");
    }    
}

================================================
FILE: plugin/js/parsers/XklxswParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("m.xklxsw.net", () => new XklxswParser());

class XklxswParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("#allChapters2");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("#nr");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".cover h2 a");
    }
    findChapterTitle(dom) {
        return dom.querySelector("#nr_title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".intro_info")];
    }
}

================================================
FILE: plugin/js/parsers/YedugeParser.js
================================================

"use strict";

parserFactory.register("yeduge.com", () => new YedugeParser());

class YedugeParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector(".chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector(".content");
    }

    removeUnwantedElementsFromContentElement(element) {
        util.removeChildElementsMatchingSelector(element, "lock");
        super.removeUnwantedElementsFromContentElement(element);
    }

    findChapterTitle(dom) {
        return dom.querySelector(".title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".cover");
    }

    extractLanguage(dom) {
        return dom.querySelector("html").getAttribute("lang");
    }

    extractTitleImpl(dom) {
        return dom.querySelector(".info > h1");
    }

    extractAuthor(dom) {
        let authorLabel = dom.querySelector(".info > p:nth-child(2)");
        return authorLabel?.textContent.replace("作者：", "").trim() ?? super.extractAuthor(dom);
    }

    extractDescription(dom) {
        return dom.querySelector(".desc").textContent.trim();
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".novel")];
    }
}

================================================
FILE: plugin/js/parsers/YushuboParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("yushubo.net", () => new YushuboParser());

class YushuboParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocUrl = dom.baseURI.replace("book_", "list_other_");
        let tocDoc = (await HttpClient.wrapFetch(tocUrl)).responseXML;
        let menu = tocDoc.querySelector("ul.chapter-list");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.article-title");
    }

    findCoverImageUrl(dom) {
        return util.getFirstImgSrc(dom, ".bigpic");
    }

    async fetchChapter(url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        newDoc.content.appendChild(this.findChapterTitle(dom));
        newDoc.content.appendChild(this.findRawContent(dom));
        let nextPageUrl = this.findNextPageUrl(dom);
        while (nextPageUrl != null) {
            dom = (await HttpClient.wrapFetch(nextPageUrl)).responseXML;
            newDoc.content.appendChild(this.findRawContent(dom));
            nextPageUrl = this.findNextPageUrl(dom);
        }
        return newDoc.dom;
    }

    findRawContent(dom) {
        return dom.querySelector("#BookText");
    }

    findNextPageUrl(dom) {
        let links = [...dom.querySelectorAll("div.articlebtn a")]
            .filter(a => a.textContent === "下一页")
            .slice(-1);
        return links[0]?.href;
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll(".book-intro")];
    }

    cleanInformationNode(node) {
        util.removeChildElementsMatchingSelector(node, "ul.lastchapter");
        return node;
    }
}

================================================
FILE: plugin/js/parsers/ZenithNovelsParser.js
================================================

"use strict";

//dead url/ parser
parserFactory.register("zenithnovels.com", () => new ZenithNovelsParser());

class ZenithNovelsParser extends WordpressBaseParser {
    constructor() {
        super();
    }

    getChapterUrls(dom, chapterUrlsUI) {
        return this.getChapterUrlsFromMultipleTocPages(dom,
            ZenithNovelsParser.extractPartialChapterList,
            ZenithNovelsParser.getUrlsOfTocPages,
            chapterUrlsUI
        ).then(l => l.reverse());
    }

    static getUrlsOfTocPages(dom) {
        return [...dom.querySelectorAll("ul.lcp_paginator a:not(.lcp_nextlink)")]
            .map(link => link.href);
    }
    
    static extractPartialChapterList(dom) {
        let list = dom.querySelector("ul.lcp_catlist");
        return util.hyperlinksToChapterList(list);
    }
    
    findContent(dom) {
        return dom.querySelector("article");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.entry p")];
    }
}

================================================
FILE: plugin/js/parsers/ZenithtlsParser.js
================================================

"use strict";

parserFactory.register("zenithtls.com", () => new ZenithtlsParser());

class ZenithtlsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let leaves = dom.baseURI.split("/");
        let id = leaves[leaves.length - 1];
        id = id.replace(/#google_vignette.*$/,"");
        let chapters = (await HttpClient.fetchJson("https://www.zenithtls.com/api/chapter?novelId="+id+"&limit=0&page=1")).json;
        return chapters.chapters.map(a => ({
            sourceUrl: "https://www.zenithtls.com/chapter/" + a.id, 
            title: a.title, 
            isIncludeable: (a.price==0||a.price==null)
        }));
    }
    
    async loadEpubMetaInfo(dom) {
        let leaves = dom.baseURI.split("/");
        let id = leaves[leaves.length - 1];
        let bookinfo = (await HttpClient.fetchJson("https://www.zenithtls.com/api/novels/" + id)).json;
        this.title = bookinfo?.title;
        this.author = bookinfo?.translator?.username;
        this.tags = bookinfo?.tags;
        this.description = bookinfo?.synopsis;
        this.img = (bookinfo?.cover?.url!=null)?"https://www.zenithtls.com/"+bookinfo?.cover?.url:"";
        return;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    extractTitleImpl() {
        return (this.title!=null)?this.title:"";
    }

    extractAuthor() {
        return (this.author!=null)?this.author:"";
    }

    extractSubject() {
        let tags = this.tags;
        return tags.join(", ");
    }

    extractDescription() {
        return (this.description!=null)?this.description.trim():"";
    }

    findCoverImageUrl() {
        return this.img;
    }
    
    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let startString = "self.__next_f.push(";
        let scriptElement = [...dom.querySelectorAll("script")].map(a => a.textContent).filter(s => s.includes(startString));
        let json = [];
        let i = 0;
        let j = 0;
        let longestindex = 0;
        let longestcontent = 0;
        //search longest content to build chapter
        while ( j < scriptElement.length) {
            try {
                json[i] = this.parseNextjsHydration(scriptElement[j]);
                i++;
                if (scriptElement[j].length > longestcontent) {
                    longestcontent = scriptElement[j].length;
                    longestindex = i-1;
                }
            } catch (error) {
                //catch maleformed json
            }
            j++;
        }
        if (json[longestindex].webtoepubformat == "backslash") {
            json[longestindex].title = "";
            for (let jsonentry of json) {
                try {
                    json[longestindex].title = jsonentry.chapter.title.trim();
                } catch (error) {
                    //set title
                }
            }
        }
        return this.buildChapter(json[longestindex], url);
    }

    parseNextjsHydration(nextjs) {
        let malformedjson = nextjs.match(/{.*}/s);
        let json;
        if (malformedjson == null) {
            malformedjson = nextjs.match(/\[.*\]/s);
            let ret = malformedjson[0];
            json = JSON.parse(ret);
            json.webtoepubformat = "backslash";
        } else {
            let ret = malformedjson[0];
            ret = ret.replaceAll("\\\\\\\"", "[webtoepubescape\"]");
            ret = ret.replaceAll("\\", "");
            ret = ret.replaceAll("[webtoepubescape\"]","\\\"");
            json = JSON.parse(ret);
            json.webtoepubformat = "array";
        }
        return json;
    }

    buildChapter(json, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        let br = newDoc.dom.createElement("br");
        if (json.webtoepubformat == "backslash") {
            title.textContent = json.title;
            newDoc.content.appendChild(title);
            let text = json[json[0]];
            text = text.replaceAll("\n\n", "\n");
            text = text.split("\n");
            for (let element of text) {
                let pnode = newDoc.dom.createElement("p");
                //filter title
                if (element != json.title) {
                    pnode.textContent = element;
                    newDoc.content.appendChild(pnode);
                }
                newDoc.content.appendChild(br);
            }
        } else {
            title.textContent = json.chapter.title;
            newDoc.content.appendChild(title);
            let textleaves = json.chapter.content.root.children.filter(a => a.direction!=null);
            for (let element of textleaves) {
                let newtext = "";
                element.children.map(a => newtext += a.text);
                let pnode = newDoc.dom.createElement("p");
                pnode.textContent = newtext;
                newDoc.content.appendChild(pnode);
                newDoc.content.appendChild(br);
            }
        }
        return newDoc.dom;
    }
}

================================================
FILE: plugin/js/parsers/ZeonicrepublicParser.js
================================================

"use strict";

parserFactory.register("zeonic-republic.net", () => new ZeonicrepublicParser());

class ZeonicrepublicParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let links = [...dom.querySelectorAll("div.info a")];
        if (links.length === 0) {
            links = [...dom.querySelectorAll("div.entry a")];
        }
        return links.map(a => util.hyperLinkToChapter(a));
    }

    findContent(dom) {
        return dom.querySelector("div#content");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h2.title");
    }

    findCoverImageUrl(dom) {
        let img = dom.querySelector("div.book-info .cover img");
        return (img === null)
            ? util.getFirstImgSrc(dom, "div.entry")
            : util.getFirstImgSrc(dom, "div.book-info .cover");
    }
}

================================================
FILE: plugin/js/parsers/ZhenhunxiaoshuoParser.js
================================================

"use strict";

parserFactory.register("zhenhunxiaoshuo.com", () => new ZhenhunxiaoshuoParser());

class ZhenhunxiaoshuoParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let menu = dom.querySelector("div.excerpts");
        return util.hyperlinksToChapterList(menu);
    }

    findContent(dom) {
        return dom.querySelector("article");
    }

    extractTitleImpl(dom) {
        return dom.querySelector("h1.focusbox-title");
    }

    findChapterTitle(dom) {
        return dom.querySelector("h1.article-title");
    }

    getInformationEpubItemChildNodes(dom) {
        return [...dom.querySelectorAll("div.focusbox div.container")];
    }
}

================================================
FILE: plugin/js/parsers/ZirusMusingsParser.js
================================================

/*
  Parses the Lazy Dungeon Master story on <https://zirusmusings.com/ldm-ch84/>
*/
"use strict";

//dead url
parserFactory.register("zirusmusings.com", () => new ZirusMusingsParser());
parserFactory.register("zirusmusings.net", () => new ZirusMusingsParser());

class ZirusMusingsParser extends Parser {
    constructor() {
        super();
    }

    async getChapterUrls(dom) {
        let tocHtml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let nextjsraw = tocHtml.querySelector("#__NEXT_DATA__").innerHTML;
        let nextjsjson = JSON.parse(nextjsraw);
        let chaps = nextjsjson.props.pageProps.data.volumes;
        chaps = chaps.map(a => a.chapters).map(a => {
            a[0].newArc = a[0].volumeTitle;
            return a;
        });
        chaps = chaps.flatMap(a => a).filter(a => a.published!=null);
        return chaps.map(a => ({
            sourceUrl: "https://www.zirusmusings.net/series/" + a.series + "/" + a.chapter, 
            title: a.title,
            newArc: a.newArc
        }));
    }
    
    async loadEpubMetaInfo(dom) {
        let tocHtml = (await HttpClient.wrapFetch(dom.baseURI)).responseXML;
        let nextjsraw = tocHtml.querySelector("#__NEXT_DATA__").innerHTML;
        let nextjsjson = JSON.parse(nextjsraw);
        let bookinfo = nextjsjson.props.pageProps.data;
        this.title = bookinfo?.name;
        this.author = bookinfo?.author;
        this.description = bookinfo?.summary;
        this.img = (bookinfo?.cover!=null)?"https://www.zirusmusings.net"+bookinfo?.cover:"";
        return;
    }

    extractTitleImpl() {
        return (this.title!=null)?this.title:"";
    }

    extractAuthor() {
        return (this.author!=null)?this.author:"";
    }

    extractDescription() {
        return (this.description!=null)?this.description.trim():"";
    }

    findCoverImageUrl() {
        return this.img;
    }

    findContent(dom) {
        return Parser.findConstrutedContent(dom);
    }

    async fetchChapter(url) {
        let dom = (await HttpClient.wrapFetch(url)).responseXML;
        let nextjsraw = dom.querySelector("#__NEXT_DATA__").innerHTML;
        let nextjsjson = JSON.parse(nextjsraw);
        return this.buildChapter(nextjsjson.props.pageProps, url);
    }

    buildChapter(chapcontent, url) {
        let newDoc = Parser.makeEmptyDocForContent(url);
        let title = newDoc.dom.createElement("h1");
        title.textContent = chapcontent.data.title?chapcontent.data.title:"Chapter "+chapcontent.data.chapter;
        newDoc.content.appendChild(title);
        let content = util.sanitize(chapcontent.content);
        util.moveChildElements(content.body, newDoc.content);
        return newDoc.dom;
    }
}

================================================
FILE: testdata/Baka-Tsuki.html
================================================

﻿<!DOCTYPE html>
<!-- saved from url=(0075)http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub -->
<html lang="en" dir="ltr" class="client-js">
<head>
    <title>Web to Epub:Volume 103 - Baka-Tsuki</title>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Web_to_Epub skin-vector action-view vector-animateLayout webfonts-changed">
    <div id="mw-page-base" class="noprint"></div>
    <div id="mw-head-base" class="noprint"></div>
    <div id="content" class="mw-body" role="main">
        <a id="top"></a>
        <h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Web to Epub</span></h1>
        <div id="bodyContent" class="mw-body-content">
            <div id="siteSub">From Baka-Tsuki</div>
            <div id="contentSub"></div>
            <div id="jump-to-nav" class="mw-jump">
                Jump to:     <a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub#mw-navigation">navigation</a>,      <a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub#p-search">search</a>
            </div>
            <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
                <div id="toc" class="toc">
                    <div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub#" id="togglelink">hide</a>]&nbsp;</span></div>
                </div>
                <h2><span class="mw-headline" id="Novel_Illustrations">Novel Illustrations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub&action=edit&section=1" title="Edit section: Novel Illustrations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
                <ul class="gallery mw-gallery-traditional">
                    <li class="gallerybox" style="width: 155px">
                        <div style="width: 155px">
                            <div class="thumb" style="width: 150px;"><div style="margin:15px auto;"><a href="http://www.baka-tsuki.org/project/index.php?title=File:Web_to_Epub_Cover-Mini.jpg" class="image"><img alt="" src="./Web to Epub - Baka-Tsuki_files/thumb.php" width="80" height="125" data-file-width="400" data-file-height="600"></a></div></div>
                            <div class="gallerytext">
                                <p>
                                    Cover
                                </p>
                            </div>
                        </div>
                    </li>
                    <li class="gallerybox" style="width: 155px">
                        <div style="width: 155px">
                            <div class="thumb" style="width: 150px;"><div style="margin:33px auto;"><a href="http://www.baka-tsuki.org/project/index.php?title=File:Web_to_Epub_Page_2.png" class="image"><img alt="" src="./Web to Epub - Baka-Tsuki_files/thumb(1).php" width="120" height="80" data-file-width="2900" data-file-height="2000"></a></div></div>
                            <div class="gallerytext">
                                <p>
                                    Page 2
                                </p>
                            </div>
                        </div>
                    </li>
                </ul>
                <h2><span class="mw-headline" id="1._Introduction">1. Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub_1._Introduction&action=edit&section=T-1" title="Web_to_Epub rudra">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
                <p>If you're like me, you will have...</p>
                <h2><span class="mw-headline" id="2._Using_the_Code_or_How_to_load_an_Extension_into_Chrome">2. Using the Code or "How to load an Extension into Chrome</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub_2._Using_the_Code_or_How_to_load_an_Extension_into_Chrome&action=edit&section=T-2" title="Web_to_Epub rudra">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
                <p>
                    <br>
                </p>
                <table border="1" cellpadding="5" cellspacing="0" style="margin: 1em 1em 1em 0; background: #f9f9f9; border: 1px #aaaaaa solid; padding: 0.2em; border-collapse: collapse;">
                    <tbody>
                        <tr>
                            <td>
                            </td>
                            <td>
                            </td>
                            <td>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <!--
                NewPP limit report
                CPU time usage: 0.618 seconds
                Real time usage: 0.763 seconds
                Preprocessor visited node count: 813/1000000
                Preprocessor generated node count: 3632/1000000
                Post‐expand include size: 344952/2097152 bytes
                Template argument size: 0/2097152 bytes
                Highest expansion depth: 3/40
                Expensive parser function count: 0/100
                -->
                <!-- Saved in parser cache with key haruhiwiki:pcache:idhash:79100-0!*!0!!en!5!* and timestamp 20151205134707 and revision id 465598
                 -->
            </div>         <div class="printfooter">
                Retrieved from "<a dir="ltr" href="http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub&oldid=465598">http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub&amp;oldid=465598</a>"
            </div>
            <div id="catlinks" class="catlinks catlinks-allhidden"></div>            <div class="visualClear"></div>
        </div>
    </div>
    <div id="mw-navigation">
    </div>
    <div id="footer" role="contentinfo">
    </div>
</body>
</html>

================================================
FILE: testdata/DredC1.html
================================================

﻿<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="keywords" content="fanfiction, transformative works, otw, fair use, archive" />
    <meta name="language" content="en-US" />
    <meta name="subject" content="fandom" />
    <title>
        Web to EPUB Extension for Chrome - Chapter 1 - By David Teviotdale
    </title>
    <base href="http://archiveofourown.org/works/123456/chapters/9876543" />
</head>
<body class="logged-out javascript" style="zoom: 1;">
    <div id="outer" class="wrapper">
        <ul id="skiplinks"><li><a href="http://archiveofourown.org/works/123456/chapters/9876543#main">Main Content</a></li></ul>
        <div id="inner" class="wrapper">
            <div id="main" class="chapters-show region" role="main">

                <div class="flash"></div>
                <div class="work">
                    <p class="landmark"><a name="top">&nbsp;</a></p>
                    <h3 class="landmark heading">Actions</h3>
                    <ul class="work navigation actions" role="menu">

                        <li class="chapter" aria-haspopup="true">
                            <a class="collapsed" href="http://archiveofourown.org/works/123456/chapters/9876543#">Chapter Index</a>
                            <ul id="chapter_index" class="expandable secondary hidden" style="display: block;">
                                <li>
                                    <form accept-charset="UTF-8" action="./Web to EPUB Extension for Chrome - Chapter 1 - David Teviotdale [Archive of Our Own].html" method="get">
                                        <div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓" /></div>
                                        <p>
                                            <select id="selected_id" name="selected_id">
                                                <option value="9876543" selected="selected">1. Introduction</option>
                                                <option value="9876544">2. Using the Code or "How to load an Extension into Chrome"</option>
                                                <option value="9876545">3. Basics of Building a Chrome extension</option>
                                                <option value="9876546">4. How to read the HTML of a web page on a Chrome tab.</option>
                                                <option value="9876547">5. Using Chrome's &quot;Inspect Element&quot; to examine the DOM</option>
                                            </select>
                                            <span class="submit actions"><input name="commit" type="submit" value="Go" /></span>
                                        </p>
                                    </form>
                                </li>
                                <li><a href="http://archiveofourown.org/works/123456/">Full-page index</a></li>
                            </ul>
                        </li>

                    </ul>

                    <h3 class="landmark heading">Work Header</h3>


                    <div id="workskin">
                        <div class="preface group">
                            <h2 class="title heading">
                                Web *to EPUB: Extension \for Chrome?
                            </h2>
                            <h3 class="byline heading">
                                <a href="http://archiveofourown.org/users/DavidTeviotdale/pseuds/DavidTeviotdale" class="login author" rel="author">David &amp; Teviotdale</a>
                            </h3>

                        </div>
                        <div id="chapters">
                            <div class="chapter" id="chapter-1">

                                <div class="chapter preface group" role="complementary">
                                    <h3 class="title">
                                        <a href="./Web to EPUB Extension for Chrome - Chapter 1 - By David Teviotdale [Archive of Our Own].html">Introduction</a>
                                    </h3>

                                </div>
                                <!--main content-->
                                <div class="userstuff module" role="article">
                                    <h3 class="landmark heading" id="work">Chapter Text</h3>
                                    <p>If you're like me, you will have...</p>
                                </div>
                                <!--/main-->

                            </div>
                        </div>


                    </div>
                </div>
            </div>
        </div>
    </div>

</body>
</html>

================================================
FILE: testdata/FanFiction.html
================================================

﻿<!DOCTYPE html>
<html class="wf-verdana-n4-active wf-active" style="height: 100%;">
<head>
    <title>Web to Epub fanfic | FanFiction</title>
</head>
<body style="margin-top: 0px; position: relative; min-height: 100%; top: 0px; background-color: rgb(228, 227, 213);" class="yes-fontsmoothing">
    <canvas width="35" height="35" style="display: none;"></canvas>

    <div style="width:100%;" class="xcontrast_outer" id="content_parent">
        <div class="xcontrast maxwidth" id="content_wrapper" style="width: 1300px; background-color: white;">
            <div id="content_wrapper_inner" style="padding:0.5em;">
                <div id="img_large" class="hide modal fade" style="color:black;"><div class="modal-body" align="center"></div></div><div id="profile_top" style="min-height:112px;">
                    <b class="xcontrast_txt">Web to Epub</b>
                    <a class="xcontrast_txt" href="https://www.fanfiction.net/u/9876543/David-Teviotdale">David &amp; Teviotdale</a>
                </div>
                <span style="float:right; "><select id="chap_select" title="Chapter Navigation" name="chapter" onchange="self.location = &#39;/s/1234567/&#39;+ this.options[this.selectedIndex].value + &#39;/WebToEpub&#39;;">
                    <option value="1" selected="">1. Introduction</option>
                    <option value="2">2. Using the Code or "How to load an Extension into Chrome"</option>
                    <option value="3">3. Basics of Building a Chrome extension</option>
                    <option value="4">4. How to read the HTML of a web page on a Chrome tab.</option>
                    <option value="5">5. Using Chrome's &quot;Inspect Element&quot; to examine the DOM</option>
                </select></span>
                <div role="main" aria-label="story content" class="storytextp" id="storytextp" align="center" style="padding: 0px 0.5em; -webkit-user-select: none;">
                    <div class="storytext xcontrast_txt nocopy" id="storytext">
                        <p>If you're like me, you will have...</p>
                    </div>
                </div>
                <span style="float:right; "><select id="chap_select" title="Chapter Navigation" name="chapter" onchange="self.location = &#39;/s/1234567/&#39;+ this.options[this.selectedIndex].value + &#39;/WebToEpub&#39;;">
                    <option value="1" selected="">1. Introduction</option>
                    <option value="2">2. Using the Code or "How to load an Extension into Chrome"</option>
                    <option value="3">3. Basics of Building a Chrome extension</option>
                    <option value="4">4. How to read the HTML of a web page on a Chrome tab.</option>
                    <option value="5">5. Using Chrome's &quot;Inspect Element&quot; to examine the DOM</option>
                </select></span>
            </div>
        </div>
    </div>
</body>
</html>

================================================
FILE: testdata/FanFictionSinglePage.html
================================================

﻿<!DOCTYPE html>
<html class="wf-verdana-n4-active wf-active" style="height: 100%;">
<head>
    <title>Web to Epub fanfic | FanFiction</title>
</head>
<body style="margin-top: 0px; position: relative; min-height: 100%; top: 0px; background-color: rgb(228, 227, 213);" class="yes-fontsmoothing">
    <canvas width="35" height="35" style="display: none;"></canvas>

    <div style="width:100%;" class="xcontrast_outer" id="content_parent">
        <div class="xcontrast maxwidth" id="content_wrapper" style="width: 1300px; background-color: white;">
            <div id="content_wrapper_inner" style="padding:0.5em;">
                <div id="img_large" class="hide modal fade" style="color:black;"><div class="modal-body" align="center"></div></div><div id="profile_top" style="min-height:112px;">
                    <b class="xcontrast_txt">Web to Epub</b>
                    <a class="xcontrast_txt" href="https://www.fanfiction.net/u/9876543/David-Teviotdale">David &amp; Teviotdale</a>
                </div>
                <div role="main" aria-label="story content" class="storytextp" id="storytextp" align="center" style="padding: 0px 0.5em; -webkit-user-select: none;">
                    <div class="storytext xcontrast_txt nocopy" id="storytext">
                        <p>If you're like me, you will have...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

================================================
FILE: testdata/muggleNet.html
================================================

﻿<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Web to Epub by David &amp; Teviotdale</title>
</head>
<body>
    <div class="container">
        <div class="contentContainer">
            <div class="contentLeft">
                <div id="pagetitle"><a href="http://fanfiction.mugglenet.com/viewstory.php?sid=123456">Web to Epub</a> by <a href="http://fanfiction.mugglenet.com/viewuser.php?uid=123456">David &amp; Teviotdale</a></div>
                <div class="jumpmenu"><form name="jump" action=""><select class="textbox" name="chapter" ><option value="1">1. Introduction</option><option value="2" selected="">2. Using the Code or "How to load an Extension into Chrome</option><option value="3">3. Basics of Building a Chrome extension</option><option value="4">4. How to read the HTML of a web page on a Chrome tab.</option><option value="5">5. Using Chrome's &quot;Inspect Element&quot; to examine the DOM</option></select></form></div>
                <div id="story"><span style="font-size: 100%;"><b></b><center><b>If you're like me, you will have...</b></center></span></div>
            </div>
        </div>
    </div>
</body>
</html>

================================================
FILE: testdata/muggleNetSinglePage.html
================================================

﻿<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Web to Epub by David &amp; Teviotdale</title>
</head>
<body>
    <div class="container">
        <div class="contentContainer">
            <div class="contentLeft">
                <div id="pagetitle"><a href="http://fanfiction.mugglenet.com/viewstory.php?sid=123456">Web to Epub</a> by <a href="http://fanfiction.mugglenet.com/viewuser.php?uid=123456">David &amp; Teviotdale</a></div>
                <div id="story"><span style="font-size: 100%;"><b></b><center><b>If you're like me, you will have...</b></center></span></div>
            </div>
        </div>
    </div>
</body>
</html>

================================================
FILE: unitTest/polyfillChrome.js
================================================

// polyfill for Chrome functions not available under qunit

"use strict";

class Chrome {
    constructor() {
        this.messages = new Map();
        this.messages.set("defaultUUID", "No UUID supplied");
        this.messages.set("defaultTitle", "No title supplied");
        this.messages.set("defaultAuthor", "No author supplied");
    }
}

Chrome.prototype.i18n = {
    getMessage: id => new Chrome().messages[id]
}

Chrome.prototype.downloads = {
    onChanged: {
        addListener: () => {}
    }
};

var chrome = new Chrome();

================================================
FILE: unitTest/Tests.html
================================================

﻿<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebToEpub QUnit tests</title>
    <link rel="stylesheet" href="qunit/qunit-1.19.0.css">
    <base />
</head>
<body>
    <!-- QUnit boilerplate -->
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="qunit/qunit-1.19.0.js"></script>
    <script src="../plugin/dompurify/dist/purify.min.js"></script>

    <!-- App Source Files -->
    <script src="polyfillChrome.js"></script>
    <script src="TestUtils.js"></script>
    <script src="../plugin/js/ReadingList.js"></script>
    <script src="../plugin/js/UserPreferences.js"></script>
    <script src="../plugin/js/UIText.js"></script>
    <script src="../plugin/js/EpubMetaInfo.js"></script>
    <script src="../plugin/js/ErrorLog.js"></script>
    <script src="../plugin/js/Util.js"></script>
    <script src="../plugin/js/Firefox.js"></script>
    <script src="../plugin/js/DebugUtil.js"></script>
    <script src="../plugin/js/Download.js"></script>
    <script src="../plugin/js/HttpClient.js"></script>
    <script src="../plugin/js/EpubItem.js"></script>
    <script src="../plugin/js/ParserFactory.js"></script>
    <script src="../plugin/js/ImageCollector.js"></script>
    <script src="../plugin/js/Imgur.js"></script>
    <script src="../plugin/js/ChapterUrlsUI.js"></script>
    <script src="../plugin/js/DefaultParserUI.js"></script>
    <script src="../plugin/js/ProgressBar.js"></script>
    <script src="../plugin/js/Parser.js"></script>
    <script src="../plugin/js/parsers/WordpressBaseParser.js"></script>
    <script src="../plugin/js/parsers/ActiveTranslationsParser.js"></script>
    <script src="../plugin/js/parsers/ArchiveOfOurOwnParser.js"></script>
    <script src="../plugin/js/parsers/BakaTsukiParser.js"></script>
    <script src="../plugin/js/parsers/BakaTsukiSeriesPageParser.js"></script>
    <script src="../plugin/js/parsers/BlogspotParser.js"></script>
    <script src="../plugin/js/parsers/ChickengegeParser.js"></script>
    <script src="../plugin/js/parsers/ChineseFantasyNovelsParser.js"></script>
    <script src="../plugin/js/parsers/ComrademaoParser.js"></script>
    <script src="../plugin/js/parsers/DefaultParser.js"></script>
    <script src="../plugin/js/parsers/DeviantArtParser.js"></script>
    <script src="../plugin/js/parsers/FanFictionParser.js"></script>
    <script src="../plugin/js/parsers/FicwadParser.js"></script>
    <script src="../plugin/js/parsers/GravityTalesParser.js"></script>
    <script src="../plugin/js/parsers/JpmtlParser.js"></script>
    <script src="../plugin/js/parsers/LightNovelBastionParser.js"></script>
    <script src="../plugin/js/parsers/LightNovelWorldParser.js"></script>
    <script src="../plugin/js/parsers/LiteroticaParser.js"></script>
    <script src="../plugin/js/parsers/LnmtlParser.js"></script>
    <script src="../plugin/js/parsers/MangadexParser.js"></script>
    <script src="../plugin/js/parsers/MangaHereParser.js"></script>
    <script src="../plugin/js/parsers/MuggleNetParser.js"></script>
    <script src="../plugin/js/parsers/NovelfullParser.js"></script>
    <script src="../plugin/js/parsers/NovelSpreadParser.js"></script>
    <script src="../plugin/js/parsers/NovelUniverseParser.js"></script>
    <script src="../plugin/js/parsers/NovelUpdatesParser.js"></script>
    <script src="../plugin/js/parsers/NrvnqsrParser.js"></script>
    <script src="../plugin/js/parsers/QidianParser.js"></script>
    <script src="../plugin/js/parsers/QinxiaoshuoParser.js"></script>
    <script src="../plugin/js/parsers/RanobesParser.js"></script>
    <script src="../plugin/js/parsers/ReadComicOnlineParser.js"></script>
    <script src="../plugin/js/parsers/RoyalRoadParser.js"></script>
    <script src="../plugin/js/parsers/ShinsoriParser.js"></script>
    <script src="../plugin/js/parsers/StocxParser.js"></script>
    <script src="../plugin/js/parsers/TapreadParser.js"></script>
    <script src="../plugin/js/parsers/TruyenfullParser.js"></script>
    <script src="../plugin/js/parsers/TruyenyyParser.js"></script>
    <script src="../plugin/js/parsers/AsianHobbyistParser.js"></script>
    <script src="../plugin/js/parsers/LightNovelsTranslationsParser.js"></script>
    <script src="../plugin/js/parsers/NepustationParser.js"></script>
    <script src="../plugin/js/parsers/ShmtranslationsParser.js"></script>
    <script src="../plugin/js/parsers/TranslationChickenParser.js"></script>
    <script src="../plugin/js/parsers/WattpadParser.js"></script>
    <script src="../plugin/js/parsers/WebNovelOnlineParser.js"></script>
    <script src="../plugin/js/parsers/WuxiaBlogParser.js"></script>
    <script src="../plugin/js/parsers/WuxiaworldParser.js"></script>
    <script src="../plugin/js/parsers/ZirusMusingsParser.js"></script>
    <script src="../plugin/@zip.js/zip.js/dist/zip-no-worker.min.js"></script>
    <script src="../plugin/js/EpubItemSupplier.js"></script>
    <script src="../plugin/js/CoverImageUI.js"></script>
    <script src="../plugin/js/EpubPacker.js"></script>

    <!-- UnitTests -->
    <!--
        <script src='UtestZipAndDownload.js'></script>
    -->
    <script src="UtestReadingList.js"></script>
    <script src="UtestUserPreferences.js"></script>
    <script src='UtestUtil.js'></script>
    <script src="UtestFirefox.js"></script>
    <script src="UtestDebugUtil.js"></script>
    <script src='UtestDownload.js'></script>
    <script src='UtestEpubItem.js'></script>
    <script src='UtestEpubMetaInfo.js'></script>
    <script src='UtestEpubPacker.js'></script>
    <script src='UtestChapterUrlsUI.js'></script>
    <script src='UtestHttpClient.js'></script>
    <script src='UtestParser.js'></script>
    <script src="UtestActiveTranslationsParser.js"></script>
    <script src="UtestBakaTsukiParser.js"></script>
    <script src="UtestBlogspotParser.js"></script>
    <script src="UtestChickengegeParser.js"></script>
    <script src="UtestChineseFantasyNovelsParser.js"></script>
    <script src="UtestComrademaoParser.js"></script>
    <script src="UtestDefaultParser.js"></script>
    <script src="UtestDeviantArtParser.js"></script>
    <script src="UtestGravityTalesParser.js"></script>
    <script src="UtestImageCollector.js"></script>
    <script src='UtestArchiveOfOurOwnParser.js'></script>
    <script src='UtestFanFictionParser.js'></script>
    <script src="UtestFicwadParser.js"></script>
    <script src="UtestJpmtlParser.js"></script>
    <script src="UtestLightNovelWorldParser.js"></script>
    <script src="UtestLiteroticaParser.js"></script>
    <script src="UtestLnmtlParser.js"></script>
    <script src="UtestImgur.js"></script>
    <script src="UtestMangaHereParser.js"></script>
    <script src="UtestMuggleNetParser.js"></script>
    <script src="UtestNepustationParser.js"></script>
    <script src="UtestNovelSpreadParser.js"></script>
    <script src="UtestNovelfullParser.js"></script>
    <script src="UtestNovelUpdatesParser.js"></script>
    <script src="UtestQidianParser.js"></script>
    <script src="UtestQinxiaoshuoParser.js"></script>
    <script src="UtestRanobesParser.js"></script>
    <script src="UtestReadComicOnlineParser.js"></script>
    <script src="UtestRoyalRoadParser.js"></script>
    <script src="UtestShinsoriParser.js"></script>
    <script src="UtestShmtranslationsParser.js"></script>
    <script src="UtestStocxParser.js"></script>
    <script src="UtestTapreadParser.js"></script>
    <script src="UtestTruyenfullParser.js"></script>
    <script src="UtestTruyenyyParser.js"></script>
    <script src="UtestTranslationChickenParser.js"></script>
    <script src="UtestWattpadParser.js"></script>
    <script src="UtestWebNovelOnlineParser.js"></script>
    <script src="UtestWuxiaBlogParser.js"></script>
    <script src="UtestWuxiaworldParser.js"></script>
    <script src='UtestParserFactory.js'></script>

    <!-- elements Plug-in needs in its HTML -->
    <div hidden>
        <span id="findingChapterUrlsMessageRow"></span>
        <select id="themeColorTag"></select>
    </div>
</body>
</html>

================================================
FILE: unitTest/TestUtils.js
================================================

/*
  Helper functions for testing
*/
"use strict";

class TestUtils {
    constructor() {
    }

    static makeDomWithBody(innerTextForBody) {
        let html = "<html><head><title></title></head><body>" +
            innerTextForBody +
            "</body></html>";
        return new DOMParser().parseFromString(html, "text/html");
    }
}

================================================
FILE: unitTest/UtestActiveTranslationsParser.js
================================================

"use strict";

module("ActiveTranslationsParser");

QUnit.test("parseStyle", function (assert) {
  let dom = new DOMParser().parseFromString(ActiveTranslationsParserSamplePage, "text/html");
  let content = dom.querySelector("div.entry-content");
  let parser = new ActiveTranslationsParser()
  let rules = parser.parseStyle(content);
  assert.equal(rules.get("wf4214c10952dc478f1fb93d23f43555a").before, "“Oh, well, you really");
  assert.equal(rules.get("z164e488f661f2e907e2d1cd362e204aa").after, "out.");
});

QUnit.test("unscrambleText", function (assert) {
    let dom = new DOMParser().parseFromString(ActiveTranslationsParserSamplePage, "text/html");
    let parser = new ActiveTranslationsParser()
    let content = dom.querySelector("div.entry-content");
    parser.unscrambleText(dom, content);
    let paragraphs = [...dom.querySelectorAll("p")];
    assert.equal(paragraphs[0].textContent, "“Oh, well, you really came out.”");
    assert.equal(paragraphs[1].textContent, "There was Min Ha-Yul, who freaked him out.");
    assert.equal(paragraphs[2].textContent, "{Uploaded for Premium Users on Sep. 29, 2020}");
});

let ActiveTranslationsParserSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
<title>Everyone Else Is A Returnee Chapter 359</title>
<base href="https://activetranslations.xyz/eer/everyone-else-is-a-returnee-chapter-359" />
</head>
<body>
<div class="entry-content">
<p class=""><span class=" wf4214c10952dc478f1fb93d23f43555a"> came </span></p>
<p><span class=" z164e488f661f2e907e2d1cd362e204aa"> him </span></p>
<p><span class=" a0fdfb5e8cc4ea6c3bbf56ff708a2ddd3"> Premium Users on </span></p>
<style>
.a0fdfb5e8cc4ea6c3bbf56ff708a2ddd3::before {content: '{Uploaded for';}.a0fdfb5e8cc4ea6c3bbf56ff708a2ddd3::after {content: 'Sep. 29, 2020}';}
.wf4214c10952dc478f1fb93d23f43555a::before {
  content: '“Oh, well, you really';
}
.wf4214c10952dc478f1fb93d23f43555a::after {
  content: 'out.”';
}
.z164e488f661f2e907e2d1cd362e204aa::before {
  content: 'There was Min Ha-Yul, who freaked';
}
.z164e488f661f2e907e2d1cd362e204aa::after {
  content: 'out.';
}
</style>
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestArchiveOfOurOwnParser.js
================================================

"use strict";

module("ArchiveOfOurOwnParser");

/// Load the sample file
/// As file operation is async, load the sample file into dom, and call doneCallback when file loaded
function asyncLoadArchiveOfOurOwnSampleDoc(doneCallback) {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", "../testdata/DredC1.html");
    xhr.responseType = "document";
    xhr.onload = function () {
        let dom = this.responseXML;
        util.setBaseTag("<http://archiveofourown.org/works/123456/chapters/9876543>", dom);
        doneCallback(dom);
    }
    xhr.send();
}

function syncLoadArchiveOfOurOwnSampleDoc() {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", "../testdata/DredC1.html", false);
    xhr.send(null);
    let dom = new DOMParser().parseFromString(xhr.responseText, "text/html");
    util.setBaseTag("<http://archiveofourown.org/works/123456/chapters/9876543>", dom);
    return dom;
}

QUnit.test("findContent", function (assert) {
    let parser = new ArchiveOfOurOwnParser();
    let content = parser.findContent(syncLoadArchiveOfOurOwnSampleDoc());
    equal(content.firstElementChild.className, "chapter");
});

QUnit.test("getEpubMetaInfo", function (assert) {
    let parser = new ArchiveOfOurOwnParser();
    let metaInfo = parser.getEpubMetaInfo(syncLoadArchiveOfOurOwnSampleDoc());
    equal(metaInfo.title, "Web *to EPUB: Extension \\for Chrome?");
    equal(metaInfo.author, "David & Teviotdale");
    equal(metaInfo.language, "en-US");
    equal(metaInfo.fileName, "Web_to_E...r_Chrome");
    equal(metaInfo.seriesName, null);
});

QUnit.test("parserFactory", function (assert) {
    let parser = parserFactory.fetch("<http://archiveofourown.org/works/123456/chapters/9876543>");
    assert.ok(parser instanceof ArchiveOfOurOwnParser );
});

================================================
FILE: unitTest/UtestBakaTsukiParser.js
================================================

"use strict";

module("BakaTsuki");

/// Load the sample file
/// As file operation is async, load the sample file into dom, and call doneCallback when file loaded
function syncLoadBakaTsukiSampleDoc() {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", "../testdata/Baka-Tsuki.html", false);
    xhr.send(null);
    let dom = new DOMParser().parseFromString(xhr.responseText, "text/html");
    util.setBaseTag("<http://www.baka-tsuki.org/project/index.php?title=Web_to_Epub>", dom);
    return dom;
}

function getTestDom() {
    return new DOMParser().parseFromString(
        "<x>" +
           "<!-- comment 1 -->" +
           "<h1>T1</h1>" +
           "<div id=\"toc\"></div>" +
           "<!-- comment 2 -->" +
           "<script>\"use strict\"</script>" +
           "<h2>T1.1</h2>" +
        "</x>",
        "text/html"
    );
}

QUnit.test("parserFactory", function (assert) {
    let parser = parserFactory.fetch("<http://www.baka-tsuki.org/project/index.php?title=File:WebToEpub.jpg>");
    assert.ok(parser instanceof BakaTsukiParser);
});

QUnit.test("getEpubMetaInfo", function (assert) {
    let parser = new BakaTsukiParser();
    let metaInfo = parser.getEpubMetaInfo(syncLoadBakaTsukiSampleDoc());
    equal(metaInfo.title, "Web to Epub");
    equal(metaInfo.author, "<unknown>");
    equal(metaInfo.language, "en");
    equal(metaInfo.seriesName, "Web to Epub");
    equal(metaInfo.seriesIndex, "103");
});

QUnit.test("noSeriesInfo", function (assert) {
    let parser = new BakaTsukiParser();
    let dom = syncLoadBakaTsukiSampleDoc();
    dom.querySelector("title").innerText = "Web to Epub";
    let metaInfo = parser.getEpubMetaInfo(dom);
    equal(metaInfo.seriesName, null);
});

QUnit.test("findContent", function (assert) {
    let parser = new BakaTsukiParser();
    let content = parser.findContent(syncLoadBakaTsukiSampleDoc());
    equal(content.childNodes.length, 21);
    equal(content.childNodes[3].innerText, "Novel Illustrations[edit]");
});

QUnit.test("removeUnwantedElementsFromContentElement", function (assert) {
    let parser = new BakaTsukiParser();
    let dom = getTestDom();
    parser.removeUnwantedElementsFromContentElement(dom.documentElement);
    assert.equal(dom.body.innerHTML, "<x><h1>T1</h1><h2>T1.1</h2></x>");
});

function removeElementsTestDom() {
    return new DOMParser().parseFromString(
        "<x>" +
           "<h1>T1<span class=\"mw-editsection\">Edit 1</span></h1>" +
           "<div class=\"toc\">" +
               "<script>\"use strict\"</script>" +
               "<div class=\"tok\">" +
                   "<h3>T1.1</h3>" +
               "</div>" +
           "</div>" +
           "<h2>T1.1</h2>" +
           "<table><tbody><tr><th>Table4" +
               "<table><tbody><tr><th>Table5</th></tr></tbody></table>" +
           "</th></tr></tbody></table>" +
           "<span class=\"mw-editsection\">Edit 2</span>"+
        "</x>",
        "text/html"
    );
}

QUnit.test("removeElementsSafeToCallMultipleTimes", function (assert) {
    assert.expect(0);
    let dom = removeElementsTestDom();
    let parser = new BakaTsukiParser();
    let tok = dom.getElementsByClassName["tok"](0);
    util.removeElements([tok]);
    util.removeElements([tok]);
});

QUnit.test("removeElementsSafeToCallOnChildOfDeletedElement", function (assert) {
    assert.expect(0);
    let dom = removeElementsTestDom();
    let parser = new BakaTsukiParser();
    let toc = dom.getElementsByClassName["toc"](0);
    let tok = dom.getElementsByClassName["tok"](0);
    util.removeElements([toc]);
    util.removeElements([tok]);
});

QUnit.test("removeComments", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<x>" +
           "<!-- comment 1 -->" +
           "<h1>T1</h1>" +
           "<div class=\"toc\">"+
               "<!-- comment 2 -->" +
           "</div>" +
        "</x>",
        "text/html"
    );

    let parser = new BakaTsukiParser();
    util.removeComments(dom.documentElement);
    assert.equal(dom.body.innerHTML, "<x><h1>T1</h1><div class=\"toc\"></div></x>");
});

QUnit.test("removeUnwantedTableWhenSingleTable", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<x>" +
           "<h1>H1</h1>" +
           "<table><tbody><tr><th>Table1</th></tr><tr><td><a href=\"http:\\dummy.html\">a</a></td></tr></tbody></table>" +
        "</x>",
        "text/html"
    );

    BakaTsukiParser.removeUnwantedTable(dom.documentElement);
    assert.equal(dom.body.innerHTML, "<x><h1>H1</h1></x>");
});

QUnit.test("removeUnwantedTableWhenTableNested", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<x>" +
           "<table><tbody><tr><th>Table1</th></tr></tbody></table>" +
           "<table><tbody><tr><th>Table2" +
               "<table><tbody><tr><th>Table3</th></tr></tbody></table>" +
           "</th></tr></tbody></table>" +
           "<table><tbody><tr><th>Table4" +
               "<table><tbody><tr><th>Table5</th></tr><tr><td><a href=\"http:\\dummy.html\">a</a></td></tr></tbody></table>" +
           "</th></tr></tbody></table>" +
        "</x>",
        "text/html"
    );

    BakaTsukiParser.removeUnwantedTable(dom.documentElement);
    assert.equal(dom.body.innerHTML,
        "<x>" +
           "<table><tbody><tr><th>Table1</th></tr></tbody></table>" +
           "<table><tbody><tr><th>Table2" +
               "<table><tbody><tr><th>Table3</th></tr></tbody></table>" +
           "</th></tr></tbody></table>" +
        "</x>");
});

QUnit.test("removeTextBeforeGallery", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<p>misc text</p>" +
        "<h2>Image Gallery</h2>" +
        "<p>misc text 2</p>" +
        "<div></div>" +
        "<ul class=\"gallery mw-gallery-traditional\"></ul>"
    );

    let gallery = dom.getElementsByTagName("ul")[0];
    BakaTsukiParser.removeTextBeforeGallery(gallery);
    assert.equal(dom.body.innerHTML,
        "<p>misc text</p>" +
        "<h2>Image Gallery</h2>" +
        "<div></div>" +
        "<ul class=\"gallery mw-gallery-traditional\"></ul>");
});

QUnit.test("replaceImageTags", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<x>" +
           "<div></div>" +
           "<p>misc text</p>" +
           "<ul class=\"gallery mw-gallery-traditional\">"+
               "<li class=\"gallerybox\" style=\"width: 155px\"><div style=\"width: 155px\">" +
                   "<div class=\"thumb\">" +
                       "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                            "<img src=\"./Baka to Tesuto to Syokanju_Volume1 - Baka-Tsuki_files/120px-BTS_vol_01_000a.jpg\" >" +
                       "</a>" +
                       "<div class=\"thumbcaption\">" +
                           "<div class=\"magnify\">" +
                               "<a href=\"/project/index.php?title=File:Mondaiji-tachi_ga_isekai_kara_kuru_soudesu_yo_V10_Color_Pic.jpg\" class=\"internal\" title=\"Enlarge\"></a>" +
                           "</div>" +
                           "<sup id=\"cite_ref-1\" class=\"reference\"><a href=\"#cite_note-1\">[1]</a></sup>" +
                       "</div>" +
                   "</div>" +
               "</div></li>"+
               "<li class=\"comment\"></li>" +
           "</ul>" +
           "<div class=\"thumb tright\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000b.png\" class=\"image\">" +
                    "<img src=\"./Baka to Tesuto to Syokanju_Volume1 - Baka-Tsuki_files/120px-BTS_vol_01_000b.png\" >" +
                "</a>" +
           "</div>" +
           "<div class=\"thumbinner\">T1</div>" +
           "<div class=\"floatright\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                    "<img src=\"./Baka to Tesuto to Syokanju_Volume1 - Baka-Tsuki_files/120px-BTS_vol_01_000a.jpg\" >" +
                "</a>" +
                "<div class=\"thumbcaption\">comment</div>" +
           "</div>" +
           "<div class=\"floatleft\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_V01_Cover.jpg\" class=\"image\">" +
                    "<img src=\"./Baka to Tesuto to Syokanju_Volume1 - Baka-Tsuki_files/120px-BTS_V01_Cover.jpg\" >" +
                "</a>" +
           "</div>" +
           "<div class=\"rating-section\">" +
                    "<img src=\"https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\" >" +
           "</div>" +
           "<p>"+
                "<img src=\"https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\" >" +
           "</p>"+
           "<p><i><b>"+
                "<img src=\"https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\" >" +
           "</b></i></p>"+
           "<p><i><b>"+
                "this image <img src=\"https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\" > should be inline" +
           "</b></i></p>"+
        "</x>",
        "text/html"
    );

    // Hack, if I don't do this, on Chrome the src value for <img> tags with relative paths is blank.
    util.setBaseTag("https://www.baka-tsuki.org/project/index.php", dom);

    let imageCollector = new ImageCollector();
    let preferences = new UserPreferences();
    preferences.includeImageSourceUrl.value = true;
    preferences.useSvgForImages.value = true;
    imageCollector.userPreferences = preferences;
    imageCollector.findImagesUsedInDocument(dom.body);

    // fake getting image size data
    let imageInfo = imageCollector.imageInfoByUrl("https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg");
    imageInfo.height = 301;
    imageInfo.width = 302;
    imageInfo = imageCollector.imageInfoByUrl("https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000b.png");
    imageInfo.height = 600;
    imageInfo.width = 400;
    imageInfo.mediaType = "image/png";
    imageInfo = imageCollector.imageInfoByUrl("https://www.baka-tsuki.org/project/index.php?title=File:BTS_V01_Cover.jpg");
    imageInfo.height = 10;
    imageInfo.width = 20;
    imageInfo = imageCollector.imageInfoByUrl("https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif");
    imageInfo.height = 1;
    imageInfo.width = 2;
    imageInfo.mediaType = "image/gif";
    let parser = new BakaTsukiParser(imageCollector);
    parser.replaceImageTags(dom.documentElement);

    // convert to XHTML for comparison
    let doc2 = util.createEmptyXhtmlDoc();
    let body = doc2.getElementsByTagName("body")[0];
    body.appendChild(dom.getElementsByTagName("x")[0]);

    assert.equal(doc2.getElementsByTagName("x")[0].outerHTML,
        "<x xmlns=\"http://www.w3.org/1999/xhtml\">" +
           "<div></div>" +
           "<div>" +
             "<div class=\"svg_outer svg_inner\">"+
                "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"99%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 302 301\">" +
                    "<image xlink:href=\"../Images/0000_BTS_vol_01_000a.jpg\" width=\"302\" height=\"301\"/>"+
                    "<desc>https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg</desc>"+
                "</svg>"+
                "<div class=\"thumbcaption\">" +
                    "<sup id=\"cite_ref-1\" class=\"reference\"><a href=\"#cite_note-1\">[1]</a></sup>" +
                "</div>" + 
             "</div>"+
           "</div>"+
           "<div class=\"svg_outer svg_inner\">"+
                "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"99%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 400 600\">" +
                    "<image xlink:href=\"../Images/0001_BTS_vol_01_000b.png\" width=\"400\" height=\"600\"/>"+
                    "<desc>https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000b.png</desc>"+
                "</svg>"+
            "</div>"+
           "<div class=\"thumbinner\">T1</div>" +
           "<div class=\"svg_outer svg_inner\">"+
                "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"99%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 302 301\">" +
                    "<image xlink:href=\"../Images/0000_BTS_vol_01_000a.jpg\" width=\"302\" height=\"301\"/>"+
                    "<desc>https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg</desc>"+
                "</svg>"+
                "<div class=\"thumbcaption\">comment</div>" + 
            "</div>"+
            "<div><img src=\"../Images/0002_BTS_V01_Cover.jpg\" alt=\"\" /><!--  https://www.baka-tsuki.org/project/index.php?title=File:BTS_V01_Cover.jpg\  --></div>"+
             "<div class=\"rating-section\">" +
             "<div><img src=\"../Images/0003_star_on.gif\" alt=\"\" /><!--  https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\  --></div>"+
             "</div>" +
             "<div><img src=\"../Images/0003_star_on.gif\" alt=\"\" /><!--  https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\  --></div>"+
             "<p></p>"+
             "<div><img src=\"../Images/0003_star_on.gif\" alt=\"\" /><!--  https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\  --></div>"+
           "<p><i><b></b></i></p>"+
           "<p><i><b>"+
                "this image <span><img class=\"inline\" src=\"../Images/0003_star_on.gif\" alt=\"\" /><!--  https://www.baka-tsuki.org/project/index.php?title=File:star_on.gif\  --></span> should be inline" +
           "</b></i></p>"+
        "</x>");
});

QUnit.test("flattenContent", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<div>" +
           "<div>" +
               "<div>" +
                   "<h1>H1.1</h1>" +
                   "<h2>H2.1</h2>" +
               "</div>" +
           "</div>" +
           "<h3>H3.1</h3>" +
           "<div>" +
               "<h4>H4.1</h1>" +
           "</div>" +
        "</div>",
        "text/html"
    );

    let parser = new BakaTsukiParser();
    parser.flattenContent(dom.body.firstChild);
    assert.equal(dom.body.firstChild.outerHTML,
        "<div>" +
            "<h1>H1.1</h1>" +
            "<h2>H2.1</h2>" +
            "<h3>H3.1</h3>" +
            "<h4>H4.1</h4>" +
        "</div>");
});

QUnit.test("hasNoVisibleContent", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<body><div style=\"display:none;\"></div>"+
        "<div class=\"print-no\">\n"+
        "</div>"+
         "<svg xmlns=\"<http://www.w3.org/2000/svg\>" xmlns:xlink=\"<http://www.w3.org/1999/xlink\>" height=\"100%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 1500 597\">"+
         "<image xlink:href=\"../Images/[0000]Hantuki01 001.jpg\" height=\"597\" width=\"1500\" data-origin=\"<http://sonako.wikia.com/wiki/File:Hantuki01> 001.jpg\"/>"+
         "</svg>"+
         "<div><div id=\"mb_video_syncad_bottom\" style=\"padding: 5px 0px 0px;\"></div></div><p><br />"+
         "</p>\n"
    );

    let elements = new Array();
    for(let child of dom.body.childNodes) {
        elements.push(child);
    };

    assert.equal(BakaTsukiParser.prototype.hasVisibleContent(elements), true);

    // remove <image>, now no visible content
    let newElements = elements.filter(e => (e.tagName !== "svg"));
    assert.equal(BakaTsukiParser.prototype.hasVisibleContent(newElements), false);

    // add <img> at top level
    let img = dom.createElement("img");
    newElements.push(img);
    assert.equal(BakaTsukiParser.prototype.hasVisibleContent(newElements), true);

    // add nested <img>
    newElements.pop();
    assert.equal(BakaTsukiParser.prototype.hasVisibleContent(newElements), false);
    newElements[0].appendChild(img);
    assert.equal(BakaTsukiParser.prototype.hasVisibleContent(newElements), true);
});

QUnit.test("splitContentIntoEpubItems", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<div>" +
           "\n\n"+
           "<h1>H1.1</h1>" +
           "<p>text1</p>" +
           "\n" +
           "<p><br /></p>" +
           "<br />" +
           "<h1>H1.2</h1>" +
           "<h2>H2.2</h2>" +
           "<p>text2</p>" +
           "text3" +
           "<h1>H1.3</h1>" +
           "<h2>H2.3</h2>" +
           "<h3>H2.3</h2>" +
        "</div>",
        "text/html"
    );

    let parser = new BakaTsukiParser();
    let epubItems = parser.splitContentIntoEpubItems(dom.body.firstChild);
    assert.equal(epubItems.length, 3);
    assert.equal(epubItems[0].nodes.length, 2);
    assert.equal(epubItems[1].nodes.length, 4);
    assert.equal(epubItems[2].nodes.length, 3);

    let nodes = epubItems[0].nodes;
    assert.equal(nodes[0].outerHTML, "<h1>H1.1</h1>");
    assert.equal(nodes[1].outerHTML, "<p>text1</p>");

    nodes = epubItems[1].nodes;
    assert.equal(nodes[0].outerHTML, "<h1>H1.2</h1>");
    assert.equal(nodes[1].outerHTML, "<h2>H2.2</h2>");
    assert.equal(nodes[2].outerHTML, "<p>text2</p>");
    assert.equal(nodes[3].outerHTML, "<p>text3</p>");

    nodes = epubItems[2].nodes;
    assert.equal(nodes[0].outerHTML, "<h1>H1.3</h1>");
    assert.equal(nodes[1].outerHTML, "<h2>H2.3</h2>");
    assert.equal(nodes[2].outerHTML, "<h3>H2.3</h3>");
});

function fetchHrefForId(epubItems, id) {
    for(let epubItem of epubItems) {
        for(let startNode of epubItem.nodes) {
            let walker = document.createTreeWalker(startNode);
            do {
                let node = walker.currentNode;
                if (node.id === id) {
                    return node.getElementsByTagName["a"](0).getAttribute("href");
                };
            } while(walker.nextNode());
        };
    };
}

test("fixupInternalHyperLinks", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h1>H1</h1>" +
        "<sup id=\"cite_ref-1\" class=\"reference\"><a href=\"<http://www.baka-tsuki.org/project/index.php?title=WebtoEpub#cite_note-1\">[1>]</a></sup>" +
        "<h1>H2</h1>" +
        "<ul><li id=\"cite_note-2\"><span class=\"mw-cite-backlink\"><a href=\"http://www.baka-tsuki.org/project/index.php?title=WebtoEpub#cite_ref-2\"><span class=\"cite-accessibility-label\">Jump up </span>^</a></span> <span class=\"reference-text\"></span></ul>" +
        "<h1>H3</h1>" +
        "<sup id=\"cite_ref-2\" class=\"reference\"><a href=\"<http://www.baka-tsuki.org/project/index.php?title=WebtoEpub#cite_note-2\">[2>]</a></sup>" +
        "<h1>H4</h1>" +
        "<ul><li id=\"cite_note-1\"><span class=\"mw-cite-backlink\"><a href=\"http://www.baka-tsuki.org/project/index.php?title=WebtoEpub#cite_ref-1\"><span class=\"cite-accessibility-label\">Jump up </span>^</a></span> <span class=\"reference-text\"></span></ul>"
    );
    let parser = new BakaTsukiParser();
    let content = dom.body.cloneNode(true);
    let epubItems = parser.splitContentIntoEpubItems(content, null);
    BakaTsukiParser.fixupInternalHyperLinks(epubItems);

    assert.equal(fetchHrefForId(epubItems, "cite_ref-1"), "../Text/0003_H4.xhtml#cite_note-1");
    assert.equal(fetchHrefForId(epubItems, "cite_ref-2"), "../Text/0001_H2.xhtml#cite_note-2");
    assert.equal(fetchHrefForId(epubItems, "cite_note-1"), "../Text/0000_H1.xhtml#cite_ref-1");
    assert.equal(fetchHrefForId(epubItems, "cite_note-2"), "../Text/0002_H3.xhtml#cite_ref-2");

});

// demonstrate Chrome closing <br> tags when convert from HTML to XHTML
test("replaceInvalidElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<p>SomeText</p>" +
        "<br>" +
        "<p>More</p>"
    );
    let parser = new BakaTsukiParser();
    let content = dom.body.cloneNode(true);
    assert.equal(content.outerHTML, "<body><p>SomeText</p><br><p>More</p></body>");

    let xhtml = util.createEmptyXhtmlDoc();
    let body = xhtml.getElementsByTagName("body")[0];
    body.replaceWith(content);

    assert.equal(xhtml.getElementsByTagName("body")[0].outerHTML, 
        "<body xmlns=\"http://www.w3.org/1999/xhtml\"><p>SomeText</p><br /><p>More</p></body>");
});

test("unSuperScriptAlternateTranslations", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h2>"+
            "<span class=\"mw-headline\" id=\"Chapter_5_.E2.80.93_ZeusLightning_Thunder_and_OdinSeverance_Spear.2C_Twisted_Dragon_of_Destiny\">Chapter 5 – "+
                "<span style=\"white-space: nowrap; position: relative;\">"+
                    "<span style=\"position: absolute; font-size: .8em; top: -11px; left: 50%; white-space: nowrap; letter-spacing: normal; color: inherit; font-weight: inherit; font-style: inherit;\">"+
                        "<span style=\"position: relative; left: -50%;\">Zeus</span>"+
                    "</span>"+
                    "<span style=\"display: inline-block; color: inherit; letter-spacing: normal; font-size: 1.0em; font-weight: inherit;\">Lightning Thunder</span>"+
                "</span> and "+
                "<span style=\"white-space: nowrap; position: relative;\">"+
                    "<span style=\"position: absolute; font-size: .8em; top: -11px; left: 50%; white-space: nowrap; letter-spacing: normal; color: inherit; font-weight: inherit; font-style: inherit;\">"+
                        "<span style=\"position: relative; left: -50%;\">Odin</span>"+
                    "</span>"+
                    "<span style=\"display: inline-block; color: inherit; letter-spacing: normal; font-size: 1.0em; font-weight: inherit;\">Severance Spear</span>"+
                "</span>, Twisted Dragon of Destiny"+
            "</span>"+
        "</h2>"
    );

    let heading = dom.querySelector("h2");
    BakaTsukiParser.unSuperScriptAlternateTranslations(heading);
    let actual = heading.textContent;
    assert.equal(actual, "Chapter 5 – Lightning Thunder (Zeus) and Severance Spear (Odin), Twisted Dragon of Destiny")
});

test("isFullTextPage", function (assert) {
    assert.ok(BakaTsukiSeriesPageParser.isFullTextPage("<https://www.baka-tsuki.org/project/index.php?title=Shinmai_Maou_no_Keiyakusha:Volume_1>"));
    assert.notOk(BakaTsukiSeriesPageParser.isFullTextPage("<https://www.baka-tsuki.org/project/index.php?title=Shinmai_Maou_no_Keiyakusha>"));
});

test("registerBakaParsers", function (assert) {
    BakaTsukiSeriesPageParser.registerBakaParsers(false);
    let seriesPageUrl = "<https://www.baka-tsuki.org/project/index.php?title=Shinmai_Maou_no_Keiyakusha>";
    let fullPageUrl = "<https://www.baka-tsuki.org/project/index.php?title=Shinmai_Maou_no_Keiyakusha:Volume_1>";

    let parser = parserFactory.fetch(seriesPageUrl);
    assert.ok(parser instanceof BakaTsukiParser );
    parser = parserFactory.fetch(fullPageUrl);
    assert.ok(parser instanceof BakaTsukiParser );
    
    BakaTsukiSeriesPageParser.registerBakaParsers(true);
    parser = parserFactory.fetch(seriesPageUrl);
    assert.ok(parser instanceof BakaTsukiSeriesPageParser );
    parser = parserFactory.fetch(fullPageUrl);
    assert.ok(parser instanceof BakaTsukiParser );
});

================================================
FILE: unitTest/UtestBlogspotParser.js
================================================

"use strict";

module("BlogspotParser");

QUnit.test("convertToUrlOfOriginalSizeImage_blogspot", function (assert) {
    let ic = new BlogspotParserImageCollector();
    let url = "<https://4.bp.blogspot.com/-TGXsOjoQQpQ/XGDse2CvCeI/AAAAAAAACmk/lfAGhIRbSRoTlGXlUq7oSdo4oLyQv34pgCLcBGAs/s640/ADAM_8_page_001.jpg>";
    let actual = ic.convertToUrlOfOriginalSizeImage(url);
    assert.equal(actual, "<https://4.bp.blogspot.com/-TGXsOjoQQpQ/XGDse2CvCeI/AAAAAAAACmk/lfAGhIRbSRoTlGXlUq7oSdo4oLyQv34pgCLcBGAs/s0/ADAM_8_page_001.jpg>");

    url = "https://4.bp.blogspot.com/-TGXsOjoQQpQ/XGDse2CvCeI/AAAAAAAACmk/lfAGhIRbSRoTlGXlUq7oSdo4oLyQv34pgCLcBGAs/s0/ADAM_8_page_001.jpg";
    actual = ic.convertToUrlOfOriginalSizeImage(url);
    assert.equal(actual, "https://4.bp.blogspot.com/-TGXsOjoQQpQ/XGDse2CvCeI/AAAAAAAACmk/lfAGhIRbSRoTlGXlUq7oSdo4oLyQv34pgCLcBGAs/s0/ADAM_8_page_001.jpg");
});

QUnit.test("convertToUrlOfOriginalSizeImage_google", function (assert) {
    let ic = new BlogspotParserImageCollector();
    let url = "<https://lh4.googleusercontent.com/IACIoq8JcJb5rc4qfz0WK34_X19WnCgHfTfIiSq17ocsRGhMppYrlD2YgTtHp8zlnKS7jtv-X9FttHMlafhLQUDJ9mFem6_fucgvecoC4QZnEqtqU9YC9stpKUj_9XehrxNZqCZL>";
    let actual = ic.convertToUrlOfOriginalSizeImage(url);
    assert.equal(actual, "<https://lh4.googleusercontent.com/IACIoq8JcJb5rc4qfz0WK34_X19WnCgHfTfIiSq17ocsRGhMppYrlD2YgTtHp8zlnKS7jtv-X9FttHMlafhLQUDJ9mFem6_fucgvecoC4QZnEqtqU9YC9stpKUj_9XehrxNZqCZL>");
});

================================================
FILE: unitTest/UtestChapterUrlsUI.js
================================================

"use strict";

module("UChapterUrlsUI");

QUnit.test("chaptersToHTML", function (assert) {
    let parser = {
        chapters: [
            { isIncludeable: true,  sourceUrl: "http://a.com", title: "1" },
            { isIncludeable: false, sourceUrl: "http://b.com", title: "2" },
            { isIncludeable: true,  sourceUrl: "http://c.com", title: "3" }
        ]
    };

    let ui = new ChapterUrlsUI(parser);
    let out = ui.chaptersToHTML(parser.chapters);
    assert.equal(out, "<a href=\"http://a.com\">1</a>\r<a href=\"http://c.com\">3</a>\r");
});

QUnit.test("chaptersToHTML", function (assert) {
    let innerHtml = "<a href=\"<http://a.com\">1></a>\r<a href=\"<http://c.com\">3></a>\r";
    let ui = new ChapterUrlsUI(null);
    let chapters = ui.htmlToChapters(innerHtml);
    assert.equal(chapters.length, 2);
    assert.equal(chapters[0].sourceUrl, "<http://a.com/>");
    assert.equal(chapters[1].title, "3");
});

================================================
FILE: unitTest/UtestChickengegeParser.js
================================================

"use strict";

module("ChickengegeParser");

test("extractFootnotes", function (assert) {
    let dom = new DOMParser().parseFromString(ChickengegeChapterSample, "text/html");
    let parser = new ChickengegeParser();
    let actual = parser.extractFootnotes(dom);
    assert.equal(actual.length, 2);
    assert.equal(actual[0].textContent, "Iuppiter = old English form of Jupiter; raws used an ancient term for Jupiter");
    assert.equal(actual[1].textContent, "10-15 minutes");
});

let ChickengegeChapterSample =
`<!DOCTYPE html>
<html lang="en">
<head>
<title>The Beginning After The End - Chapter 1 - The Light at the End of the Tunnel - WebNovelOnline</title>
<base href="https://webnovelonline.com/chapter/the_beginning_after_the_end/chapter-1" />
</head>
<body>
<p style="text-align: justify">“Don’t worry.” Chen Xing explained, “<span class="tooltipsall tooltip_post_id_custom_1444bf0d1c43826214fbd5a251167080 classtoolTipsCustomShortCodeOnlyForMultiTooltips">Iuppiter</span><script type="b7f1d86dd5bddd712eb9cb17-text/javascript">jQuery("document").ready(function(){ toolTips('.tooltip_post_id_custom_1444bf0d1c43826214fbd5a251167080',"Iuppiter = old English form of Jupiter; raws used an ancient term for Jupiter",'0'); });</script> is part of my fate. Up until now, no matter what I encounter, I’m able to avert disaster.” He then went out to search for a horse.</p>
<p style="text-align: justify">Chen Xing hung himself for approximately the time taken to drink a cup of <span class="tooltipsall tooltip_post_id_custom_8444618342de8febdd65e67c9055cc15 classtoolTipsCustomShortCodeOnlyForMultiTooltips">tea</span><script type="b7f1d86dd5bddd712eb9cb17-text/javascript">jQuery("document").ready(function(){ toolTips('.tooltip_post_id_custom_8444618342de8febdd65e67c9055cc15',"10-15 minutes",'0'); });</script>, confirmed that no one else was coming again, then quickly untied the knot and came down. He carried Xiang Shu on his shoulder and ran towards the backyard as he gasped for breath.</p>
</body>
</html>
`

================================================
FILE: unitTest/UtestChineseFantasyNovelsParser.js
================================================

"use strict";

module("ChineseFantasyNovelsParser");

test("getChapterUrls", function (assert) {
    let dom = new DOMParser().parseFromString(ChineseFantasyNovelsToCSample, "text/html");
    let done = assert.async();
    let parser = new ChineseFantasyNovelsParser();
    parser.getChapterUrls(dom).then(function(chapterUrls) {
        assert.equal(chapterUrls.length, 2);
        assert.deepEqual(chapterUrls[1], {
            newArc: null,
            sourceUrl: "<https://m.chinesefantasynovels.com/421/91906.html>",
            title: "Chapter 2: Living with great joy, dying with no regrets"
        });
        done();
    });
});

test("extractTitleImpl", function (assert) {
    let dom = new DOMParser().parseFromString(ChineseFantasyNovelsToCSample, "text/html");
    let parser = new ChineseFantasyNovelsParser();
    let actual = parser.extractTitleImpl(dom);
    assert.equal(actual.textContent, "The Ultimate Evolution");
});

test("extractAuthor", function (assert) {
    let dom = new DOMParser().parseFromString(ChineseFantasyNovelsToCSample, "text/html");
    let parser = new ChineseFantasyNovelsParser();
    let actual = parser.extractAuthor(dom);
    assert.equal(actual.trim(), "Volume Of Soil");
});

test("findChapterTitle", function (assert) {
    let dom = new DOMParser().parseFromString(ChineseFantasyNovelsChapterSample, "text/html");
    let parser = new ChineseFantasyNovelsParser();
    let actual = parser.findChapterTitle(dom);
    assert.equal(actual.textContent, "Chapter 935: Gigantic Reproductive System");
});

test("removeUnwantedElementsFromContentElement", function (assert) {
    let dom = new DOMParser().parseFromString(ChineseFantasyNovelsChapterSample, "text/html");
    let parser = new ChineseFantasyNovelsParser();
    let content = parser.findContent(dom);
    parser.removeUnwantedElementsFromContentElement(content);
    let unwanted = [...content.querySelectorAll("div")];
    assert.equal(unwanted.length, 0);
});

let ChineseFantasyNovelsToCSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>The Ultimate Evolution - Volume Of Soil - Chinese Fantasy Novels</title>
    <base href="https://m.chinesefantasynovels.com/421/" />
</head>
<body>
    <div class="container">
        <div class="bookinfo">
            <div class="btitle"><h1>The Ultimate Evolution</h1><br></div>
            <a name="top"></a>
            <div class="status">Author: Volume Of Soil</div>
            <p class="stats"> <span class="fl"><b>Lastchapter: </b>Chapter 935: Gigantic Reproductive System</span> </p>
            <div class="status"><font color="#999999">Updated: </font>2018-10-20 01:37</div>
            <p class="stats"> </p>
            <div class="tuijian">
            </div>
        </div>
        <div class="inner">
            <dl class="chapterlist cate">
                <dd><a href="/421/91906.html">Chapter 2: Living with great joy, dying with no regrets</a></dd>
                <dd><a href="/421/91905.html">Chapter 1: Returning after hunting whales</a></dd>
            </dl>
            <a name="bottom"></a>
            <div class="clear"></div>
        </div>
    </div>
    <div id="footer">
    </div>
</body>
</html>`

let ChineseFantasyNovelsChapterSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chapter 935: Gigantic Reproductive System - Chinese Fantasy Novels</title>
    <base href="https://m.chinesefantasynovels.com/421/311385.html" />
</head>

<body>
    <div class="container">
        <div class="addthis_inline_share_toolbox"></div>
        <div class="article" id="main">
            <div class="inner" id="BookCon">
                <div class="ads">

                </div>
                <h1>Chapter 935: Gigantic Reproductive System</h1>
                <div class="ads"></div>
                <div id="BookText">
                        Chapter 935: Gigantic Reproductive System
                    <br />
                    <br />    Translator: Sean88888  Editor: Elkassar1
                    <div class="adsb"></div>
                    <div class="link"><a href='/421/311146.html ' class="myButton">Previous</a>            </div>
                </div>
            </div>
        </div><a name="bottom"></a>
   </div>
</body>
</html>
`

================================================
FILE: unitTest/UtestComrademaoParser.js
================================================

"use strict";

module("ComrademaoParser");

test("getUrlsOfTocPages", function (assert) {
    let dom = new DOMParser().parseFromString(ComrademaoToCSample, "text/html");
    let chapters = ComrademaoParser.getUrlsOfTocPages(dom);
    assert.equal(chapters.length, 133);
    assert.equal(chapters[132], "<https://comrademao.com/novel/shoujo-grand-summoning/page/134/>");
});

test("extractPartialChapterList", function (assert) {
    let dom = new DOMParser().parseFromString(ComrademaoToCSample, "text/html");
    let chapterUrls = ComrademaoParser.extractPartialChapterList(dom);
    assert.equal(chapterUrls.length, 3);
    assert.deepEqual(chapterUrls[0], {
        newArc: null,
        sourceUrl: "<https://comrademao.com/mtl/shoujo-grand-summoning/shoujo-grand-summoning-chapter-epilogue/>",
        title: "Shoujo Grand Summoning Chapter epilogue"
    });
});

test("extractTitleImpl", function (assert) {
    let dom = new DOMParser().parseFromString(ComrademaoToCSample, "text/html");
    let parser = new ComrademaoParser();
    let actual = parser.extractTitleImpl(dom);
    assert.equal(actual.textContent, "The Legend of Futian");
});

let ComrademaoToCSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Shoujo Grand Summoning &#8211; Comrade Mao</title>
    <base href="https://comrademao.com/novel/shoujo-grand-summoning/" />
    <link rel="shortlink" href="https://comrademao.com/?p=2370820">
</head>
<body>
    <div class="page-title-product_2">
        <div class="wrap-content"><div class="author" style=""> <img src="https://comrademao.com/wp-content/themes/book-junky/assets/images/author.png" alt=""> Jing Wu Hen &amp; 净无痕</div><h4 class="entry-title" style="">The Legend of Futian</h4><div><div class="woocommerce"><div class="woocommerce-product-rating"> <span class="star-rating  bj-color-#7151ed"> <span style="width:0%"></span> </span><span class="bj-rating-counts" style="color:#7151ed;">0 Ratings</span></div></div></div><p style="">In a time when the Divine Prefectures of the East Sea were in great disarray, Emperor Ye Qing and Donghuang the Great appeared to save the day. Under their rule, the prefectures united and all nations as well as their kings have been controlled. However, the legend of these two great heroes becomes altered when Emperor Ye Qing’s name is wiped from the history books after his sudden death. All statues and images of him were destroyed and his name a taboo. Only the legend of Donghuang the Great shall live on. Fifteen years later, a young man by the name of Ye Futian begins his journey in search for his true identity. The legend of Futian was going to be one for the history books.</p></div>
    </div>
    <input type="hidden" id="wdtNonceFrontendEdit" name="wdtNonceFrontendEdit" value="5b5e209fcb">
    <table id="table_1" class="responsive display nowrap data-t data-t wpDataTable dataTable no-footer" style="" data-described-by="table_1_desc" data-wpdatatable_id="3" role="grid">
        <tbody>
            <tr role="row" class="odd">
                <td class="column-post_post_date sorting_1">20/10/2018 11:34 AM</td>
                <td class=" column-post_title_with_link_to_post">
                    <span class="responsiveExpander"></span>
                    <a href="https://comrademao.com/?p=562316">Six hundred and sixty-six chapter</a>
                </td>
            </tr>
            <tr role="row" class="even">
                <td class="column-post_post_date sorting_1">20/10/2018 11:33 AM</td>
                <td class=" column-post_title_with_link_to_post">
                    <span class="responsiveExpander"></span><a href="https://comrademao.com/?p=562315">Chapter 605 Chapter Qingu</a>
                </td>
            </tr>
        </tbody>
    </table>

    <div class="content">
    <table id="chapters" class="table table-sm table-hover dataTable no-footer" role="grid" aria-describedby="chapters_info" style="width: 684px;">
        <thead>
            <tr role="row"><th class="sorting_disabled" rowspan="1" colspan="1" style="width: 197px;">Date</th><th class="sorting_disabled" rowspan="1" colspan="1" style="width: 455px;">Title</th></tr>
        </thead>
        <tbody>
            <tr role="row" class="odd"><td>December 24, 2018</td><td><a href="https://comrademao.com/mtl/shoujo-grand-summoning/shoujo-grand-summoning-chapter-epilogue/">Shoujo Grand Summoning Chapter epilogue</a></td></tr>
            <tr role="row" class="even"><td>December 24, 2018</td><td><a href="https://comrademao.com/mtl/shoujo-grand-summoning/shoujo-grand-summoning-chapter-2000/">Shoujo Grand Summoning Chapter 2000</a></td></tr>
            <tr role="row" class="odd"><td>December 24, 2018</td><td><a href="https://comrademao.com/mtl/shoujo-grand-summoning/shoujo-grand-summoning-chapter-1999/">Shoujo Grand Summoning Chapter 1999</a></td></tr>
        </tbody>
    </table>
    <nav class="pagination pagination-lg text-center">
        <div class="column">
            <span aria-current='page' class='page-numbers current'>1</span>
            <a class='page-numbers' href='https://comrademao.com/novel/shoujo-grand-summoning/page/2/'>2</a>
            <a class='page-numbers' href='https://comrademao.com/novel/shoujo-grand-summoning/page/3/'>3</a>
            <span class="page-numbers dots">&hellip;</span>
            <a class='page-numbers' href='https://comrademao.com/novel/shoujo-grand-summoning/page/134/'>134</a>
            <a class="next page-numbers" href="https://comrademao.com/novel/shoujo-grand-summoning/page/2/">Next &raquo;</a>
        </div><div class="column text-right hidden-xs-down"></div>
    </nav>
</div>
</body>
</html>`

let ComrademaoChapterSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>>Shoujo Grand Summoning Chapter 1994 &#8211; Comrade Mao</title>
    <base href="https://comrademao.com/mtl/shoujo-grand-summoning/shoujo-grand-summoning-chapter-1994/" />
</head>

<body>
<main id="main" class="site-main" role="main">
<div class="entry-content">
<div class="container">
<a href="#raw1" data-toggle="collapse">
    <p>    Above the black cloud layer, Beast King was floating in the air, watching the battlefield below, his face gradually ugly.</p>
</a>
<div id="raw1" class="collapse">
    <p>    在那黑压压的乌云层上方，兽王正临空悬浮在了这里，看着下方的战场，脸色渐渐的难看了起来。</p>
</div>
</div> <div class="container">
<a href="#raw2" data-toggle="collapse">
    <p>    Since the beginning of this war, ten minutes later, the first Pseudo Beast King was wiped out by the Magicannon of Kazami Yuuka. At the same time, the number of the Magical Beast, which is about Hundred Thousand, has all died in the hands of Kazami Yuuka.</p>
</a>
<div id="raw2" class="collapse">
    <p>    自这场大战掀开序幕，十分钟以后，第一个伪兽王在风见幽香的魔炮下灰飞烟灭，同时，数量大约在十万左右的飞行魔兽也已经全部死在风见幽香的手中。</p>
</div>
</div>

</div>
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestDebugUtil.js
================================================

"use strict";

module("DebugUtil");

QUnit.test("byteToHex", function (assert) {
    let actual = DebugUtil.byteToHex(0);
    assert.equal(actual, "00");
    actual = DebugUtil.byteToHex(1);
    assert.equal(actual, "01");
    actual = DebugUtil.byteToHex(15);
    assert.equal(actual, "0f");
    actual = DebugUtil.byteToHex(16);
    assert.equal(actual, "10");
    actual = DebugUtil.byteToHex(255);
    assert.equal(actual, "ff");
});

QUnit.test("bufToHex", function (assert) {
    let bytes = [13,10,13,10,60,33];
    let buf = new Uint8Array(bytes);
    let actual = DebugUtil.bufToHex(buf.buffer);
    assert.equal(actual, "0d0a0d0a3c21");
});

================================================
FILE: unitTest/UtestDefaultParser.js
================================================

"use strict";

module("DefaultParser");

test("removeUnwantedElementsFromContentElement", function (assert) {
    let dom = new DOMParser().parseFromString(DefaultSample1, "text/html");
    let parser = new DefaultParser();
    let body = parser.findContent(dom);
    assert.equal(body.innerHTML, dom.body.innerHTML);
    parser.removeUnwantedElementsFromContentElement(dom.body);
    assert.equal(dom.body.innerHTML.trim(), "<p>hello </p><p>world</p>");
});

let DefaultSample1 =
`<html>
<head><title></title><base href="https://dummy.com/test.html" /></head>
<body><p>hello </p><o:p></o:p><p>world</p></body>
</html>
`

================================================
FILE: unitTest/UtestDeviantArtParser.js
================================================

"use strict";

module("DeviantArtParser");

test("removeUnwantedImages", function (assert) {
    let dom = new DOMParser().parseFromString(DeviantArtSample1, "text/html");
    DeviantArtParser.removeUnwantedImages(dom.body);
    let images = [...dom.querySelectorAll("img")];
    assert.equal(images.length, 1);
    assert.equal(images[0].src, "<https://orig00.deviantart.net/3fbe/f/2018/162/0/f/rp_00_by_tinythea-dce3ylm.png>");
});

let DeviantArtSample1 =
`<!DOCTYPE html>
<html lang="en-US">
<head>
    <title>Ruined Plans by TinyThea on DeviantArt</title>
    <base href="https://www.deviantart.com/tinythea/art/Ruined-Plans-749293546" />
</head>

<body id="deviantART-v7" class="secure bubble no-apps maturefilter loggedout maturehide w960 deviantart withad">
<div class="dev-view-deviation">
<img collect_rid="1:749293546" src="https://pre00.deviantart.net/4d96/th/pre/f/2018/162/0/f/rp_00_by_tinythea-dce3ylm.png" data-embed-type="deviation" data-embed-format="thumb" data-embed-id="749293546" width="1078"
     height="741"
     alt="Ruined Plans by TinyThea" class="dev-content-normal ">
<img collect_rid="1:749293546" src="https://orig00.deviantart.net/3fbe/f/2018/162/0/f/rp_00_by_tinythea-dce3ylm.png" data-embed-type="deviation" data-embed-format="thumb" data-embed-id="749293546" width="1500"
     height="1031"
     alt="Ruined Plans by TinyThea" class="dev-content-full ">
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestDownload.js
================================================

"use strict";

module("Download");

QUnit.test("isFileNameIllegalOnWindows", function (assert) {
    assert.notOk(Download.isFileNameIllegalOnWindows("ValidName.epub"));
    assert.ok(Download.isFileNameIllegalOnWindows("InvalidName<>.epub"));
    assert.ok(Download.isFileNameIllegalOnWindows("InvalidName\".epub"));
});

================================================
FILE: unitTest/UtestEpubItem.js
================================================

"use strict";

module("UtestEpubItem");

QUnit.test("tagNameToTocDepth", function (assert) {
    assert.equal(EpubItem.prototype.tagNameToTocDepth("H1"), 0);
    assert.equal(EpubItem.prototype.tagNameToTocDepth("H2"), 1);
    assert.equal(EpubItem.prototype.tagNameToTocDepth("H3"), 2);
    assert.equal(EpubItem.prototype.tagNameToTocDepth("H4"), 3);
});

test("fileContentForEpub", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<section>"+
            "<p>SomeText</p>" +
            "<br>" +
            "<p>More</p>" +
            "<img src=\"http://dummy.com/imgage.png\">" +
        "</section>"
    );
    let item = new EpubItem("<http://dummy.com/imgage.html>");
    item.nodes = [ dom.getElementsByTagName["section"](0) ];
    let contentValidator = xml => util.isXhtmlInvalid(xml, EpubPacker.XHTML_MIME_TYPE);
    let xhtml = item.fileContentForEpub(util.createEmptyXhtmlDoc, contentValidator);

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(xhtml.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+
        "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">"+
        "<html xmlns=\"http://www.w3.org/1999/xhtml\">"+
        "<head><title></title><link href=\"../Styles/stylesheet.css\" type=\"text/css\" rel=\"stylesheet\" /></head>"+
        "<body>"+
            "<section>"+
                "<p>SomeText</p>" +
                "<br />" +
                "<p>More</p>" +
                "<img src=\"http://dummy.com/imgage.png\" />" +
            "</section>" +
        "</body>" +
        "</html>"
    );
});

test("hasSvg", function (assert) {
    let image = new ImageInfo("<http://bp.org/thepic.jpeg>", 0, "<http://bp.org/thepic.jpeg>");
    assert.notOk(image.hasSvg());

    let item = new EpubItem("http://bp.org/thepic.jpeg");
    assert.notOk(item.hasSvg());
    item.nodes = [];
    item.nodes.push(document.createTextNode("Hello World"));
    item.nodes.push(document.createElement("div"));
    assert.notOk(item.hasSvg());
    let svg = util.createSvgImageElement("http://bp.org/thepic.jpeg", 10, 10, 
        "http://bp.org/thepic.jpeg", true);
    item.nodes.push(svg);
    assert.ok(item.hasSvg());

    item.nodes.pop();
    assert.notOk(item.hasSvg());
    svg = util.createSvgImageElement("http://bp.org/thepic.jpeg", 10, 10, 
        "http://bp.org/thepic.jpeg", false);
    item.nodes[1].appendChild(svg);
    assert.ok(item.hasSvg());
});

test("ChapterEpubItem_chapterInfo_noNewArc", function (assert) {
    let chapter = {
        sourceUrl: "<https://dummy.com/nonsuch.html>",
        title: "DummyTitle"
    };
    let content = { childNodes: [] };
    let item = new ChapterEpubItem(chapter, content, 1);
    let ci = [...item.chapterInfo()];
    assert.equal(ci.length, 1);
});

================================================
FILE: unitTest/UtestEpubMetaInfo.js
================================================

"use strict";

module("UtestEpubMetaInfo");

QUnit.test("decensor", function (assert) {

    assert.equal(EpubMetaInfo.decensor("F**ked"), "Fucked");
    assert.equal(EpubMetaInfo.decensor("S*x"), "Sex");
    assert.equal(EpubMetaInfo.decensor("Homos*xual"), "Homosexual");
    assert.equal(EpubMetaInfo.decensor("clean"), "clean");
    assert.equal(EpubMetaInfo.decensor("***"), "***");
    assert.equal(EpubMetaInfo.decensor("S*x S*aves"), "Sex Slaves");
    assert.equal(EpubMetaInfo.decensor("Prostit**es"), "Prostitutes");
});

================================================
FILE: unitTest/UtestEpubPacker.js
================================================

"use strict";

module( "EpubPacker");
function makeDummyXhtmlFile(title) {
    let xhtml = util.createEmptyXhtmlDoc();
    let content = xhtml.createElement("div");
    content.className = "userstuff module";
    content.id = "chapters";
    xhtml.getElementsByTagName["body"](0).appendChild(content);
    let h1 = xhtml.createElement("h1");
    h1.innerText = title;
    content.appendChild(h1);
    return xhtml;
}

function makePacker() {
    let metaInfo = new EpubMetaInfo();
    metaInfo.uuid = "Dummy UUID";
    metaInfo.title = "Dummy <Title>";
    metaInfo.author = "Dummy & Author";
    let epubPacker = new EpubPacker(metaInfo);
    return epubPacker;
}

function makeEpubItemSupplier(imageCollector) {
    imageCollector = imageCollector || ImageCollector.StubCollector();
    let parser = new ArchiveOfOurOwnParser();
    parser.userPreferences = new UserPreferences();
    let webPages = [];
    for (let i = 0; i < 2; ++i) {
        let title = "Title" + i;
        webPages.push({
            sourceUrl: "<http://dummy.com/>" + title,
            title: title,
            isIncludeable: true,
            newArc: null,
            parser: parser,
            rawDom: makeDummyXhtmlFile(title)
        });
    }
    // monkey patch to avoid adding information page
    parser.getInformationEpubItemChildNodes = undefined;
    let epubItems = parser.webPagesToEpubItems(webPages);
    return new EpubItemSupplier(parser, epubItems, imageCollector);
}

function makeDummyUserPreferences(includeImageSourceUrl, useSvgForImages) {
    let preferences = new UserPreferences();
    preferences.includeImageSourceUrl.value = includeImageSourceUrl;
    preferences.useSvgForImages.value = useSvgForImages;
    return preferences;
}

test("buildContentOpf", function (assert) {
    let epubPacker = makePacker();
    epubPacker.metaInfo.seriesName = "BakaSeries";
    epubPacker.metaInfo.seriesIndex = "666";
    epubPacker.getDateForMetaData = function () { return "2015-10-17T21:04:54.061Z"; };
    let contentOpf = epubPacker.buildContentOpf(makeEpubItemSupplier());

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(contentOpf.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+
        "<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"BookId\">"+
            "<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:opf=\"http://www.idpf.org/2007/opf\">"+
            "<dc:title>Dummy &lt;Title&gt;</dc:title>" +
            "<dc:language>en</dc:language>"+
            "<dc:date>2015-10-17T21:04:54.061Z</dc:date>" +
            "<dc:creator opf:file-as=\"Dummy &amp; Author\" opf:role=\"aut\">Dummy &amp; Author</dc:creator>" +
            "<dc:identifier id=\"BookId\" opf:scheme=\"URI\">Dummy UUID</dc:identifier>"+
            "<dc:contributor opf:role=\"bkp\">[https://github.com/dteviot/WebToEpub] (ver. unknown)</dc:contributor>"+
            "<meta name=\"calibre:series\" content=\"BakaSeries\"/>" +
            "<meta name=\"calibre:series_index\" content=\"666\"/>" +
            "<dc:source id=\"id.xhtml0000\">http://dummy.com/Title0</dc:source>" +
            "<dc:source id=\"id.xhtml0001\">http://dummy.com/Title1</dc:source>" +
            "</metadata>"+
            "<manifest>"+
              "<item href=\"Text/0000_Title0.xhtml\" id=\"xhtml0000\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Text/0001_Title1.xhtml\" id=\"xhtml0001\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Styles/stylesheet.css\" id=\"stylesheet\" media-type=\"text/css\"/>" +
              "<item href=\"toc.ncx\" id=\"ncx\" media-type=\"application/x-dtbncx+xml\"/>" +
            "</manifest>"+
            "<spine toc=\"ncx\">"+
              "<itemref idref=\"xhtml0000\"/>" +
              "<itemref idref=\"xhtml0001\"/>" +
            "</spine>" +
        "</package>"
    );
});

test("buildEpub3ContentOpf", function (assert) {
    let metaInfo = new EpubMetaInfo();
    metaInfo.uuid = "Dummy UUID";
    metaInfo.title = "Dummy <Title>";
    metaInfo.author = "Dummy & Author";
    metaInfo.translator = "GoogleTranslate";
    let epubPacker = new EpubPacker(metaInfo, EpubPacker.EPUB_VERSION_3);
    epubPacker.metaInfo.seriesName = "BakaSeries";
    epubPacker.metaInfo.seriesIndex = "666";
    epubPacker.getDateForMetaData = function () { return "2015-10-17T21:04:54.061Z"; };
    let contentOpf = epubPacker.buildContentOpf(makeEpubItemSupplier());

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(contentOpf.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+
        "<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"3.0\" unique-identifier=\"BookId\">"+
            "<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:opf=\"http://www.idpf.org/2007/opf\">"+
            "<dc:title>Dummy &lt;Title&gt;</dc:title>" +
            "<dc:language>en</dc:language>"+
            "<dc:date>2015-10-17T21:04:54.061Z</dc:date>" +
            "<dc:creator id=\"creator\">Dummy &amp; Author</dc:creator>" +
            "<meta refines=\"#creator\" property=\"file-as\">Dummy &amp; Author</meta>" +
            "<meta refines=\"#creator\" property=\"role\">aut</meta>" +
            "<dc:contributor id=\"translator\">GoogleTranslate</dc:contributor>" +
            "<meta refines=\"#translator\" property=\"file-as\">GoogleTranslate</meta>" +
            "<meta refines=\"#translator\" property=\"role\">trl</meta>" +
            "<dc:identifier id=\"BookId\">uri:Dummy UUID</dc:identifier>"+
            "<meta refines=\"#BookId\" property=\"identifier-type\">URI</meta>"+
            "<meta property=\"dcterms:modified\">2015-10-17T21:04:54Z</meta>" +
            "<dc:contributor id=\"packingTool\">[https://github.com/dteviot/WebToEpub] (ver. unknown)</dc:contributor>"+
            "<meta refines=\"#packingTool\" property=\"role\">bkp</meta>" +
            "<meta name=\"calibre:series\" content=\"BakaSeries\"/>" +
            "<meta name=\"calibre:series_index\" content=\"666\"/>" +
            "<dc:source id=\"id.xhtml0000\">http://dummy.com/Title0</dc:source>" +
            "<dc:source id=\"id.xhtml0001\">http://dummy.com/Title1</dc:source>" +
            "</metadata>"+
            "<manifest>"+
              "<item href=\"Text/0000_Title0.xhtml\" id=\"xhtml0000\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Text/0001_Title1.xhtml\" id=\"xhtml0001\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Styles/stylesheet.css\" id=\"stylesheet\" media-type=\"text/css\"/>" +
              "<item href=\"toc.ncx\" id=\"ncx\" media-type=\"application/x-dtbncx+xml\"/>" +
              "<item href=\"toc.xhtml\" id=\"nav\" media-type=\"application/xhtml+xml\" properties=\"nav\"/>" +
            "</manifest>"+
            "<spine toc=\"ncx\">"+
              "<itemref idref=\"xhtml0000\"/>" +
              "<itemref idref=\"xhtml0001\"/>" +
            "</spine>" +
        "</package>"
    );
});

test("buildContentOpfWithCover", function (assert) {
    let image = new ImageInfo("<http://bp.org/thepic.jpeg>", 0, "<http://bp.org/thepic.jpeg>");
    image.isCover = true;
    let imageCollector = {
        userPreferences: {
            useSvgForImages: {value: true},
            includeImageSourceUrl: {value: true}
        },
        coverImageInfo: image,
        imagesToPackInEpub: () => [ image ]
    };
    let itemSupplier = makeEpubItemSupplier(imageCollector);
    let epubPacker = makePacker();
    epubPacker.getDateForMetaData = function () { return "2015-10-17T21:04:54.061Z"; };
    let contentOpf = epubPacker.buildContentOpf(itemSupplier);

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(contentOpf.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"BookId\">" +
            "<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:opf=\"http://www.idpf.org/2007/opf\">" +
            "<dc:title>Dummy &lt;Title&gt;</dc:title>" +
            "<dc:language>en</dc:language>" +
            "<dc:date>2015-10-17T21:04:54.061Z</dc:date>" +
            "<dc:creator opf:file-as=\"Dummy &amp; Author\" opf:role=\"aut\">Dummy &amp; Author</dc:creator>" +
            "<dc:identifier id=\"BookId\" opf:scheme=\"URI\">Dummy UUID</dc:identifier>" +
            "<dc:contributor opf:role=\"bkp\">[https://github.com/dteviot/WebToEpub] (ver. unknown)</dc:contributor>"+
            "<meta name=\"cover\" content=\"cover-image\"/>" +
            "<dc:source id=\"id.cover-image\">http://bp.org/thepic.jpeg</dc:source>" +
            "<dc:source id=\"id.xhtml0000\">http://dummy.com/Title0</dc:source>" +
            "<dc:source id=\"id.xhtml0001\">http://dummy.com/Title1</dc:source>" +
            "</metadata>" +
            "<manifest>" +
              "<item href=\"Images/0000_thepic.jpg\" id=\"cover-image\" media-type=\"image/jpeg\"/>" +
              "<item href=\"Text/0000_Title0.xhtml\" id=\"xhtml0000\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Text/0001_Title1.xhtml\" id=\"xhtml0001\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Styles/stylesheet.css\" id=\"stylesheet\" media-type=\"text/css\"/>" +
              "<item href=\"toc.ncx\" id=\"ncx\" media-type=\"application/x-dtbncx+xml\"/>" +
              "<item href=\"Text/Cover.xhtml\" id=\"cover\" media-type=\"application/xhtml+xml\"/>" +
            "</manifest>" +
            "<spine toc=\"ncx\">" +
              "<itemref idref=\"cover\"/>" +
              "<itemref idref=\"xhtml0000\"/>" +
              "<itemref idref=\"xhtml0001\"/>" +
            "</spine>" +
            "<guide>" +
                "<reference href=\"Text/Cover.xhtml\" title=\"Cover\" type=\"cover\"/>" +
            "</guide>" +
        "</package>"
    );
});

test("buildContentOpfWithTranslatorAndAuthorFileAs", function (assert) {
    let epubPacker = makePacker();
    epubPacker.metaInfo.seriesName = "BakaSeries";
    epubPacker.metaInfo.seriesIndex = "666";
    epubPacker.metaInfo.fileAuthorAs = "Doe, John";
    epubPacker.metaInfo.translator = "Baka-Tsuki staff";
    epubPacker.getDateForMetaData = function () { return "2015-10-17T21:04:54.061Z"; };
    let contentOpf = epubPacker.buildContentOpf(makeEpubItemSupplier());

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(contentOpf.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"BookId\">" +
            "<metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:opf=\"http://www.idpf.org/2007/opf\">" +
            "<dc:title>Dummy &lt;Title&gt;</dc:title>" +
            "<dc:language>en</dc:language>" +
            "<dc:date>2015-10-17T21:04:54.061Z</dc:date>" +
            "<dc:creator opf:file-as=\"Doe, John\" opf:role=\"aut\">Dummy &amp; Author</dc:creator>" +
            "<dc:contributor opf:file-as=\"Baka-Tsuki staff\" opf:role=\"trl\">Baka-Tsuki staff</dc:contributor>" +
            "<dc:identifier id=\"BookId\" opf:scheme=\"URI\">Dummy UUID</dc:identifier>" +
            "<dc:contributor opf:role=\"bkp\">[https://github.com/dteviot/WebToEpub] (ver. unknown)</dc:contributor>"+
            "<meta name=\"calibre:series\" content=\"BakaSeries\"/>" +
            "<meta name=\"calibre:series_index\" content=\"666\"/>" +
            "<dc:source id=\"id.xhtml0000\">http://dummy.com/Title0</dc:source>" +
            "<dc:source id=\"id.xhtml0001\">http://dummy.com/Title1</dc:source>" +
            "</metadata>" +
            "<manifest>" +
              "<item href=\"Text/0000_Title0.xhtml\" id=\"xhtml0000\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Text/0001_Title1.xhtml\" id=\"xhtml0001\" media-type=\"application/xhtml+xml\"/>" +
              "<item href=\"Styles/stylesheet.css\" id=\"stylesheet\" media-type=\"text/css\"/>" +
              "<item href=\"toc.ncx\" id=\"ncx\" media-type=\"application/x-dtbncx+xml\"/>" +
            "</manifest>" +
            "<spine toc=\"ncx\">" +
              "<itemref idref=\"xhtml0000\"/>" +
              "<itemref idref=\"xhtml0001\"/>" +
            "</spine>" +
        "</package>"
    );
});

test("buildTableOfContents", function (assert) {
    let buildTableOfContents = makePacker().buildTableOfContents(makeEpubItemSupplier());
    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(buildTableOfContents.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<ncx xmlns=\"<http://www.daisy.org/z3986/2005/ncx/\>" version=\"2005-1\" xml:lang=\"en\">" +
          "<head>" +
            "<meta name=\"dtb:uid\" content=\"Dummy UUID\"/>" +
            "<meta name=\"dtb:depth\" content=\"2\"/>" +
            "<meta name=\"dtb:totalPageCount\" content=\"0\"/>" +
            "<meta name=\"dtb:maxPageNumber\" content=\"0\"/>" +
          "</head>" +
          "<docTitle>" +
            "<text>Dummy &lt;Title&gt;</text>" +
          "</docTitle>" +
          "<navMap>" +
            "<navPoint id=\"body0001\" playOrder=\"1\">" +
              "<navLabel>" +
                "<text>Title0</text>" +
              "</navLabel>" +
              "<content src=\"Text/0000_Title0.xhtml\"/>" +
            "</navPoint>" +
            "<navPoint id=\"body0002\" playOrder=\"2\">" +
              "<navLabel>" +
                "<text>Title1</text>" +
              "</navLabel>" +
              "<content src=\"Text/0001_Title1.xhtml\"/>" +
            "</navPoint>" +
          "</navMap>" +
        "</ncx>"
    );
});

test("buildNestedTableOfContents", function (assert) {
    let epubItemSupplier = makeEpubItemSupplier();
    let doc = TestUtils.makeDomWithBody("<div></div><div></div>");
    let body = doc.body;
    let epubItems = [];
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "C1", newArc: null }, body, 0));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A1C1", newArc: "A1" }, body, 1));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A1C2", newArc: null }, body, 2));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A2C1", newArc: "A2" }, body, 3));

    epubItemSupplier.epubItems = epubItems;
    let buildTableOfContents = makePacker().buildTableOfContents(epubItemSupplier);
    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(buildTableOfContents.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\" xml:lang=\"en\">" +
          "<head>" +
            "<meta name=\"dtb:uid\" content=\"Dummy UUID\"/>" +
            "<meta name=\"dtb:depth\" content=\"2\"/>" +
            "<meta name=\"dtb:totalPageCount\" content=\"0\"/>" +
            "<meta name=\"dtb:maxPageNumber\" content=\"0\"/>" +
          "</head>" +
          "<docTitle>" +
            "<text>Dummy &lt;Title&gt;</text>" +
          "</docTitle>" +
          "<navMap>" +
            "<navPoint id=\"body0001\" playOrder=\"1\">" +
              "<navLabel>" +
                "<text>C1</text>" +
              "</navLabel>" +
              "<content src=\"Text/0000_C1.xhtml\"/>" +
            "</navPoint>" +
            "<navPoint id=\"body0002\" playOrder=\"2\">" +
              "<navLabel>" +
                "<text>A1</text>" +
              "</navLabel>" +
              "<content src=\"Text/0001_A1C1.xhtml\"/>" +
                "<navPoint id=\"body0003\" playOrder=\"2\">" +
                  "<navLabel>" +
                    "<text>A1C1</text>" +
                  "</navLabel>" +
                  "<content src=\"Text/0001_A1C1.xhtml\"/>" +
                "</navPoint>" +
                "<navPoint id=\"body0004\" playOrder=\"3\">" +
                  "<navLabel>" +
                    "<text>A1C2</text>" +
                  "</navLabel>" +
                  "<content src=\"Text/0002_A1C2.xhtml\"/>" +
                "</navPoint>" +
            "</navPoint>" +
            "<navPoint id=\"body0005\" playOrder=\"4\">" +
              "<navLabel>" +
                "<text>A2</text>" +
              "</navLabel>" +
              "<content src=\"Text/0003_A2C1.xhtml\"/>" +
                "<navPoint id=\"body0006\" playOrder=\"4\">" +
                  "<navLabel>" +
                    "<text>A2C1</text>" +
                  "</navLabel>" +
                  "<content src=\"Text/0003_A2C1.xhtml\"/>" +
                "</navPoint>" +
            "</navPoint>" +
          "</navMap>" +
        "</ncx>"
    );
});

test("NavPointParentElementsStackSimpleNest", function (assert) {
    let stack = new NavPointParentElementsStack("navMap");
    assert.equal(stack.maxDepth, 0);
    stack.addElement(1, "h2");
    stack.addElement(2, "h3");
    stack.addElement(3, "h4");
    assert.equal(stack.parents.length, 4);
    assert.equal(stack.maxDepth, 3);

    assert.equal(stack.findParentElement(0), "navMap");
    assert.equal(stack.findParentElement(1), "navMap");
    assert.equal(stack.findParentElement(2), "h2");
    assert.equal(stack.findParentElement(3), "h3");
});

test("UnwindNavPointParentElementsStack", function (assert) {
    // note, I should really be adding Elements to the stack
    // but for testing purposes, strings work and are easier.
    let stack = new NavPointParentElementsStack("navMap");
    assert.equal(stack.maxDepth, 0);
    stack.addElement(1, "h2");
    stack.addElement(2, "h3");
    stack.addElement(3, "h4");
    assert.equal(stack.parents.length, 4);
    assert.equal(stack.maxDepth, 3);

    stack.addElement(2, "h3.2");
    assert.equal(stack.parents.length, 3);
    assert.equal(stack.maxDepth, 3);
    assert.equal(stack.parents[2].element, "h3.2");

    stack.addElement(3, "h4.2");
    assert.equal(stack.parents.length, 4);
    assert.equal(stack.maxDepth, 3);
    assert.equal(stack.parents[2].element, "h3.2");
    assert.equal(stack.parents[3].element, "h4.2");

    stack.addElement(0, "h1.2");
    assert.equal(stack.parents.length, 2);
    assert.equal(stack.maxDepth, 3);
    assert.equal(stack.parents[1].element, "h1.2");

    stack.addElement(2, "h3.3");
    assert.equal(stack.parents.length, 3);
    assert.equal(stack.maxDepth, 3);
    assert.equal(stack.parents[1].element, "h1.2");
    assert.equal(stack.parents[2].element, "h3.3");
});

test("makeCoverImageXhtmlFile", function (assert) {
    let imageInfo = new ImageInfo("<http://dummy/cover.png>", 0, "<http://dummy/cover.png>");
    imageInfo.width = 400;
    imageInfo.height = 600;
    imageInfo.mediaType = "image/png";
    imageInfo.isCover = true;
    let dummyImageCollector = {
        userPreferences: makeDummyUserPreferences(true, true),
        coverImageInfo: imageInfo,
        imagesToPackInEpub: function () { return []; }
    };
    let itemSupplier = new EpubItemSupplier(null, [], dummyImageCollector);
    let xhtmlFile = itemSupplier.makeCoverImageXhtmlFile(util.createEmptyXhtmlDoc);

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(xhtmlFile.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" +
        "<html xmlns=\"http://www.w3.org/1999/xhtml\">" +
            "<head>" +
                "<title></title>" +
                "<link href=\"../Styles/stylesheet.css\" type=\"text/css\" rel=\"stylesheet\" />" +
            "</head>" +
            "<body>" +
               "<div class=\"svg_outer svg_inner\">" +
                    "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"99%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 400 600\">" +
                        "<image xlink:href=\"../Images/0000_cover.png\" width=\"400\" height=\"600\"/>" +
                        "<desc>http://dummy/cover.png</desc>" + 
                    "</svg>" +
                "</div>" +
            "</body>" +
        "</html>"
    );
});

test("makeCoverImageXhtmlFileAsImg", function (assert) {
    let imageInfo = new ImageInfo("<http://dummy/cover.png>", 0, "<http://dummy/cover.png>");
    imageInfo.width = 400;
    imageInfo.height = 600;
    imageInfo.isCover = true;
    imageInfo.mediaType = "image/png";
    let dummyImageCollector = {
        userPreferences: makeDummyUserPreferences(true, false),
        coverImageInfo: imageInfo,
        imagesToPackInEpub: function () { return []; }
    };
    let itemSupplier = new EpubItemSupplier(null, [], dummyImageCollector);
    let xhtmlFile = itemSupplier.makeCoverImageXhtmlFile(util.createEmptyXhtmlDoc);

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(xhtmlFile.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" +
        "<html xmlns=\"http://www.w3.org/1999/xhtml\">" +
            "<head>" +
                "<title></title>" +
                "<link href=\"../Styles/stylesheet.css\" type=\"text/css\" rel=\"stylesheet\" />" +
            "</head>" +
            "<body>" +
                "<div><img src=\"../Images/0000_cover.png\" alt=\"\" /><!--  http://dummy/cover.png  --></div>" +
            "</body>" +
        "</html>"
    );
});

test("makeCoverImageXhtmlFileNoSourceUrl", function (assert) {
    let imageInfo = new ImageInfo("<http://dummy/cover.png>", 0, "<http://dummy/cover.png>");
    imageInfo.width = 400;
    imageInfo.height = 600;
    imageInfo.isCover = true;
    imageInfo.mediaType = "image/png";
    let dummyImageCollector = {
        userPreferences: makeDummyUserPreferences(false, true),
        coverImageInfo: imageInfo,
        imagesToPackInEpub: function () { return []; }
    };
    let itemSupplier = new EpubItemSupplier(null, [], dummyImageCollector);
    let xhtmlFile = itemSupplier.makeCoverImageXhtmlFile(util.createEmptyXhtmlDoc);

    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(xhtmlFile.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" +
        "<html xmlns=\"http://www.w3.org/1999/xhtml\">" +
            "<head>" +
                "<title></title>" +
                "<link href=\"../Styles/stylesheet.css\" type=\"text/css\" rel=\"stylesheet\" />" +
            "</head>" +
            "<body>" +
               "<div class=\"svg_outer svg_inner\">" +
                    "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"99%\" width=\"100%\" version=\"1.1\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"0 0 400 600\">" +
                        "<image xlink:href=\"../Images/0000_cover.png\" width=\"400\" height=\"600\"/>" +
                        "<!--  http://dummy/cover.png  -->" +
                    "</svg>" +
                "</div>" +
            "</body>" +
        "</html>"
    );
});

test("addExtensionIfMissing_notMissing_dontAdd", function (assert) {
    let actual = EpubPacker.addExtensionIfMissing("web.epub");
    assert.equal(actual, "web.epub");
});

test("addExtensionIfMissing_Missing_Added", function (assert) {
    let actual = EpubPacker.addExtensionIfMissing("web");
    assert.equal(actual, "web.epub");
});

test("buildNavigationDocument", function (assert) {
    let epubItemSupplier = makeEpubItemSupplier();
    let doc = TestUtils.makeDomWithBody("<div></div><div></div>");
    let body = doc.body;
    let epubItems = [];
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "C1", newArc: null }, body, 0));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A1C1", newArc: "A1" }, body, 1));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A1C2", newArc: null }, body, 2));
    epubItems.push(new ChapterEpubItem({sourceUrl: "", title: "A2C1", newArc: "A2" }, body, 3));

    epubItemSupplier.epubItems = epubItems;
    let navDocument = makePacker().buildNavigationDocument(epubItemSupplier);
    // firefox adds /r/n after some elements. Remove so string same for Chrome and Firefox.
    assert.equal(navDocument.replace(/\r|\n/g, ""),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
        "<!DOCTYPE html>" +
        "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" xmlns:epub=\"http://www.idpf.org/2007/ops\" lang=\"en\">" +
          "<head>" +
          "<title>Table of Contents</title>" +
          "</head>" +
          "<body>" +
            "<nav epub:type=\"toc\" id=\"toc\">" +
              "<ol>" +
                "<li><a href=\"Text/0000_C1.xhtml\">C1</a></li>" +
                "<li>" +
                  "<a href=\"Text/0001_A1C1.xhtml\">A1</a>" +
                  "<ol>" +
                    "<li><a href=\"Text/0001_A1C1.xhtml\">A1C1</a></li>" +
                    "<li><a href=\"Text/0002_A1C2.xhtml\">A1C2</a></li>" +
                  "</ol>" +
                "</li>" +
                "<li>" +
                  "<a href=\"Text/0003_A2C1.xhtml\">A2</a>" +
                  "<ol>" +
                    "<li><a href=\"Text/0003_A2C1.xhtml\">A2C1</a></li>" +
                  "</ol>" +
                "</li>" +
              "</ol>" +
            "</nav>" +
          "</body>" +
        "</html>"  
    );
});

================================================
FILE: unitTest/UtestFanFictionParser.js
================================================

"use strict";

module("FanFictionParser");

function loadFanFictionMultiPageDoc() {
    return util.syncLoadSampleDoc("../testdata/FanFiction.html", "<https://www.fanfiction.net/s/1234567/1/WebToEpub>")
}

function loadFanFictionSinglePageDoc() {
    return util.syncLoadSampleDoc("../testdata/FanFictionSinglePage.html", "<https://www.fanfiction.net/s/1234567/1/WebToEpub>")
}

QUnit.test("getChapterUrls", function (assert) {
    let done = assert.async();
    let parser = new FanFictionParser();
    parser.getChapterUrls(loadFanFictionMultiPageDoc()).then(function (chapterUrls) {
        chapterUrls = parser.cleanWebPageUrls(chapterUrls);
        assert.equal(chapterUrls.length, 5);
        assert.equal(chapterUrls[0].sourceUrl, "<https://www.fanfiction.net/s/1234567/1/WebToEpub>");
        assert.equal(chapterUrls[1].sourceUrl, "<https://www.fanfiction.net/s/1234567/2/WebToEpub>");
        assert.equal(chapterUrls[4].title, "5. Using Chrome's \"Inspect Element\" to examine the DOM");
        done();
    });
});

QUnit.test("findMultiPageContent", function (assert) {
    let parser = new FanFictionParser();
    let content = parser.findContent(loadFanFictionMultiPageDoc());
    equal(content.childNodes.length, 3);
    let regex = /^If you're like me, you will have*/;
    assert.ok(regex.test(content.childNodes[1].innerText));
});

QUnit.test("getEpubMetaInfo", function (assert) {
    let parser = new FanFictionParser();
    let metaInfo = parser.getEpubMetaInfo(loadFanFictionMultiPageDoc());
    equal(metaInfo.title, "Web to Epub");
    equal(metaInfo.author, "David & Teviotdale");
    equal(metaInfo.language, "en");
    equal(metaInfo.fileName, "Web_to_Epub");
});

QUnit.test("parserFactory", function (assert) {
    let parser = parserFactory.fetch("<https://www.fanfiction.net/s/1234567/1/WebToEpub>");
    assert.ok(parser instanceof FanFictionParser);
});

QUnit.test("getSingleChapterUrls", function (assert) {
    let done = assert.async();
    let parser = new FanFictionParser();
    parser.getChapterUrls(loadFanFictionSinglePageDoc()).then(function (chapterUrls) {
        assert.equal(chapterUrls.length, 1);
        assert.equal(chapterUrls[0].sourceUrl, "<https://www.fanfiction.net/s/1234567/1/WebToEpub>");
        assert.equal(chapterUrls[0].title, "Web to Epub");
        done();
    });
});

QUnit.test("findSinglePageContent", function (assert) {
    let parser = new FanFictionParser();
    let content = parser.findContent(loadFanFictionSinglePageDoc());
    equal(content.childNodes.length, 3);
    let regex = /^If you're like me, you will have*/;
    assert.ok(regex.test(content.childNodes[1].innerText));
});

================================================
FILE: unitTest/UtestFicwadParser.js
================================================

"use strict";

module("Ficwad");

test("findChapters_storyIndex", function (assert) {
    let dom = new DOMParser().parseFromString(FicWadStoryIndexSample, "text/html");
    let done = assert.async();
    let parser = new FicwadParser();
    parser.getChapterUrls(dom).then(function(chapterUrls) {
        assert.equal(chapterUrls.length, 4);
        assert.deepEqual(chapterUrls[3], {
            newArc: null,
            sourceUrl: "<https://ficwad.com/story/51728>",
            title: "I Love You"
        });
        done();
    });
});

test("extractTitleImpl_storyIndex", function (assert) {
    let dom = new DOMParser().parseFromString(FicWadStoryIndexSample, "text/html");
    let parser = new FicwadParser();
    let actual = parser.extractTitleImpl(dom);
    assert.equal(actual.textContent, "Beyond the Mask");
});

test("findChapters_chapter", function (assert) {
    let dom = new DOMParser().parseFromString(FicWadChapterSample, "text/html");
    let done = assert.async();
    let parser = new FicwadParser();
    parser.getChapterUrls(dom).then(function(chapterUrls) {
        assert.equal(chapterUrls.length, 7);
        assert.deepEqual(chapterUrls[6], {
            sourceUrl: "<https://ficwad.com/story/24278>",
            title: "6. Part Six--The Last Chapter"
        });
        done();
    });
});

test("extractTitleImpl_chapter", function (assert) {
    let dom = new DOMParser().parseFromString(FicWadChapterSample, "text/html");
    let parser = new FicwadParser();
    let actual = parser.extractTitleImpl(dom);
    assert.equal(actual.textContent, "The Fourth Promise");
});

let FicWadStoryIndexSample =
`<!DOCTYPE html>
<html>
<head>
    <title>Beyond the Mask :: FicWad: fresh-picked original and fan fiction</title>
    <base href="https://ficwad.com/story/33404" />
</head>
<body>
    <div id="contents">
        <div id="story">
            <h2>
                <a href="/">Categories</a> &gt; <a href="/category/7">Movies</a> &gt;
                <a href="/category/832">V for Vendetta</a>
            </h2>
            <div class="storylist">
                <div class="R Lady141220 score2 adjAmbiance complete">
                    <h4><a href="/story/33404">Beyond the Mask</a></h4>
                    <span class="author">by <a href="/a/Lady141220">Lady141220</a></span>
                    <span class="reviews"><a href="/story/33404/reviews">0 reviews</a></span>
                    <blockquote class="summary"><p>Evey recalls her experience with V, but sometimes the past is not always ready to die.</p></blockquote>
                    <p class="meta">Category:&nbsp;<a href="/category/832">V for Vendetta</a> - Rating:&nbsp;R - Genres:&nbsp;Angst, Drama, Romance - <span class="story-warnings">Warnings:&nbsp;<a href="/help#38" title="Medium Spoilers">[!!] </a> <a href="/help#38" title="Sex">[X] </a></span> - Chapters:&nbsp;4 - Published:&nbsp;<span data-ts="1162749336" title="2006-11-05T17:55:36+00:00">2006-11-05</span> - Updated:&nbsp;<span data-ts="1186876815" title="2007-08-12T00:00:15+00:00">2007-08-12</span>  - 2928&nbsp;words - Complete</p><div class="score"><span class="score_number">2</span><span class="score_adjective">Ambiance</span></div>
                </div>
            </div>
            <div id="chapters">
                <ul class="storylist">
                    <li class="R Lady141220 score3 adjAmbiance incomplete"><h4><a href="/story/42752">Here without you!</a></h4>/li>
                    <li class="R Lady141220 score2 adjOriginal incomplete"><h4><a href="/story/42753">All of me</a></h4></li>
                    <li class="R Lady141220 score0 adjUnrated incomplete"><h4><a href="/story/44319">The Gift</a></h4></li>
                    <li class="R Lady141220 score0 adjUnrated incomplete"><h4><a href="/story/51728">I Love You</a></h4></li>
                </ul>
            </div><div id="storyfoot"><a href="/account/new">Sign up</a> to rate and review this story</div>
        </div>
    </div>
</body>
</html>
`

let FicWadChapterSample =
`<!DOCTYPE html>
<html">
<head>
    <title>The Fourth Promise: Part One :: FicWad: fresh-picked original and fan fiction</title>
    <base href="https://ficwad.com/story/24273" />
</head>
<body>
<div id="contents">
<div id="story">
    <h2><a href="/">Categories</a> &gt; <a href="/category/7">Movies</a> &gt; <a href="/category/830">Shaun of the Dead</a> &gt; <a href="/story/24272">The Fourth Promise</a></h2>
    <div class="pure-u-1 pure-u-md-3-5 story-chapters">
        <form enctype="multipart/form-data" method="POST" name="chapterlist" action="/goto/story" class="chapterlist pure-form">
            <select name="goto">
                <option value="/story/24272">Story Index</option>
                <option value="/story/24273" selected="selected">1. Part One</option>
                <option value="/story/24274">2. Part Two</option>
                <option value="/story/24275">3. Part Three</option>
                <option value="/story/24276">4. Part Four</option>
                <option value="/story/24277">5. Part Five</option>
                <option value="/story/24278">6. Part Six--The Last Chapter</option>
            </select><a href="/story/24274" class="pure-button">❯</a>
        </form>
    </div>
    <div id="storytext" class="pure-u-1">
        <strong>TITLE: </strong>The Fourth Promise<br>
    </div>
</div>
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestFirefox.js
================================================

"use strict";

module("Firefox");

test("filterHeaders", function (assert) {
    let inData = [
        {name: "Host", value: "gravitytales.com" },
        {name: "origin", value: "moz-extension://580713a4-7df3-4412-8732-17dfef5a47bd" },
        {name: "origin", value: "http://gravitytales.com" }
    ];
    let actual = Firefox.filterHeaders({requestHeaders: inData});
    assert.deepEqual(actual.requestHeaders, [inData[0], inData[2]]);
});

================================================
FILE: unitTest/UtestGravityTalesParser.js
================================================

"use strict";

module("UtestGravityTalesParser");

test("splitAtEquals", function (assert) {
    let actual = GravityTalesParser.splitAtEquals("novelId = 7");
    assert.deepEqual(actual, ["novelId", "7"]);
});

test("getNovelId", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div id=\"contentElement\" ng-controller=\"Novel\" ng-init=\"novelId = 7; isFollowingNovel = false" +
        "init-hashscroll before-scroll=\"setReviewPageFromHash('/Novels/GetNovelReviewPage')\"></div>"
    );

    let actual = GravityTalesParser.getNovelId(dom);
    assert.equal(actual, 7);

    dom = TestUtils.makeDomWithBody("");
    actual = GravityTalesParser.getNovelId(dom);
    assert.equal(actual, null);
});

let expectedChapterLists = [
    {
        groupTitle: "Group 1",
        chapters: [ {Name:"ch1", Slug:"c01"}, {Name:"ch2", Slug:"c02"} ]
    },
    {
        groupTitle: "Group 2",
        chapters: [ {Name:"ch2", Slug:"c02"}, {Name:"ch3", Slug:"c03"} ]
    }
];

let baseUri = "<http://dummy.com>";

let expectedFinalChapters = [
    {sourceUrl: "http://dummy.com/c01", title: "ch1", newArc: "Group 1"},
    {sourceUrl: "http://dummy.com/c02", title: "ch2", newArc: null},
    {sourceUrl: "http://dummy.com/c03", title: "ch3", newArc: "Group 2"}
];

test("mergeChapterLists", function (assert) {
    let actual = GravityTalesParser.mergeChapterLists(expectedChapterLists, baseUri);
    assert.deepEqual(actual, expectedFinalChapters);
});

function fetchJsonStub(url) {
    let lookup = new Map();
    lookup.set("<https://gravitytales.com/api/novels/chaptergroups/1>", [{ChapterGroupId:1, Title:"Group 1"},{ChapterGroupId:2,Title:"Group 2"}]);
    lookup.set("<https://gravitytales.com/api/novels/chaptergroup/1>", expectedChapterLists[0].chapters);
    lookup.set("<https://gravitytales.com/api/novels/chaptergroup/2>", expectedChapterLists[1].chapters);
    return Promise.resolve({ json: lookup.get(url) });
}

test("fetchChapterListForGroup", function (assert) {
    let done = assert.async();
    let chapterGroup = {ChapterGroupId:1, Title:"Group 1"};
    GravityTalesParser.fetchChapterListForGroup(1, chapterGroup, fetchJsonStub).then(
        function(actual) {
            assert.deepEqual(actual, expectedChapterLists[0]);
            done();
        }
    );
});

test("fetchUrlsOfChapters", function (assert) {
    let done = assert.async();
    GravityTalesParser.fetchUrlsOfChapters(1, baseUri, fetchJsonStub).then(
        function(actual) {
            assert.deepEqual(actual, expectedFinalChapters);
            done();
        }
    );
});

test("searchForNovelIdinString_idNotPresent", function (assert) {
    let actual = GravityTalesParser.searchForNovelIdinString("");
    assert.equal(actual, null);
});

test("searchForNovelIdinString_idPresent", function (assert) {
    let actual = GravityTalesParser.searchForNovelIdinString("{ dummy: {a: 0, novelId: 8} }");
    assert.equal(actual, 8);
});

test("searchForNovelIdinString_idPresent", function (assert) {
    let actual = GravityTalesParser.searchForNovelIdinString("{ dummy: {a: 0, novelId: 6, b:{}} }");
    assert.equal(actual, 6);
});

test("searchForNovelIdinScriptTags_idNotPresent", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<script src=\"/Scripts/react-bootstrap.min.js\"></script>" +
        "<script>ReactDOM.render(React.createElement(Components.DonationWidget, {\"novelName\":\"I’m Really a Superstar\",\"novelAbbreviation\":\"IRAS\",\"novelId\":8,\"amountDonated\":8,\"costPerChapter\":70,\"paypalEmail\":\"mysubs2015@gmail.com\",\"novelAuthor\":\"CKtalon\",\"sponsoredQueue\":0,\"userId\":null,\"widgetTitleClass\":\"widget-title\"}), document.getElementById(\"donations_8\"));</script>"
    );
    let actual = GravityTalesParser.searchForNovelIdinScriptTags(dom);
    assert.equal(actual, null);
});

test("searchForNovelIdinScriptTags_idPresent", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<script src=\"/Scripts/react-bootstrap.min.js\"></script>" +
        "<script>ReactDOM.render(React.createElement(Components.ChapterGroupList, { novelId: 8, novelSlug: 'im-really-a-superstar' }), document.getElementById(\"chapters\"))</script>"
    );
    let actual = GravityTalesParser.searchForNovelIdinScriptTags(dom);
    assert.equal(actual, 8);
});

test("findCoverImageUrl", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div id=\"coverImg\" style=\"background-image: url(<https://cdn.gravitytales.com/images/covers/cover.png);\">></div>"
    );
    let parser = new GravityTalesParser();
    let actual = parser.findCoverImageUrl(dom);
    assert.equal(actual, "<https://cdn.gravitytales.com/images/covers/cover.png>");

    dom = TestUtils.makeDomWithBody(
        "<div></div>"
    );
    actual = parser.findCoverImageUrl(dom);
    assert.equal(actual, null);

    dom = TestUtils.makeDomWithBody(
        "<div id=\"coverImg\" ></div>"
    );
    actual = parser.findCoverImageUrl(dom);
    assert.equal(actual, null);

    dom = TestUtils.makeDomWithBody(
        "<div id=\"coverImg\" style=\"1\"></div>"
    );
    actual = parser.findCoverImageUrl(dom);
    assert.equal(actual, null);
});

================================================
FILE: unitTest/UtestHttpClient.js
================================================

"use strict";

module("HttpClient");

QUnit.test("charsetFromHeaders", function (assert) {
    let evaluate = (val) => {
        let mockHeader = { get: () => val };
        return new FetchResponseHandler().charsetFromHeaders(mockHeader);
    };

    assert.equal(evaluate(null), "utf-8");
    assert.equal(evaluate("text/html"), "utf-8");
    assert.equal(evaluate("text/html; charset=utf-16"), "utf-16");
    assert.equal(evaluate("text/html; Charset=utf-17"), "utf-17");
    assert.equal(evaluate("text/html; Charset=\"utf-18\""), "utf-18");
    assert.equal(evaluate("text/html;Charset=\"utf-19\";something="), "utf-19");
    assert.equal(evaluate("text/html; Charset=utf-20 ;something="), "utf-20");
});

function createDummyFetchErrorHandler(response) {
    let handler = new FetchErrorHandler();
    handler.count = 0;
    handler.prompted = false;
    handler.retryFetch = function(url, wrapOptions) {
        ++handler.count;
        wrapOptions.retry.retryDelay.pop();
        return handler.onResponseError(url, wrapOptions, response);
    }
    handler.promptUserForRetry = function(url, wrapOptions, response, failError) {
        handler.prompted = true;
        return Promise.reject();
    }
    return {errorHandler: handler};
}

function testOnResponseError(assert, status, retries, prompted) {
    let done = assert.async();
    let response = {status: status}
    let wrapOptions = createDummyFetchErrorHandler(response);
    let handler = wrapOptions.errorHandler;
    return handler.onResponseError(null, wrapOptions, response)
        .catch(function() {
            assert.equal(handler.count, retries)
            assert.equal(handler.prompted, prompted)
            done();
        });
}

QUnit.test("onResponseError_404_error_fails_immediately", function (assert) {
    testOnResponseError(assert, 404, 0, false);
});

QUnit.test("onResponseError_500_error_retries_4_times", function (assert) {
    testOnResponseError(assert, 500, 4, false);
});

QUnit.test("onResponseError_504_error_retries_4_times", function (assert) {
    testOnResponseError(assert, 504, 4, true);
});

================================================
FILE: unitTest/UtestImageCollector.js
================================================

"use strict";

module("ImageCollector");

QUnit.test("ImageInfo.ctor", function (assert) {
    let imageInfo = new ImageInfo("<http://www.baka-tsuki.org/WebToEpub.jpg>", 0, null);
    assert.equal(imageInfo.wrappingUrl, "<http://www.baka-tsuki.org/WebToEpub.jpg>");
    assert.equal(imageInfo.sourceUrl, null);
    assert.equal(imageInfo.getZipHref(), "OEBPS/Images/0000_WebToEpub.jpg");
    assert.equal(imageInfo.getId(), "image0000");
});

QUnit.test("ImageInfo.findImageSuffix", function (assert) {
    let imageInfo = new ImageInfo("WebToEpub.jpg", 0, null);
    imageInfo.mediaType = "image/bmp";
    assert.equal(imageInfo.findImageSuffix("<http://www.baka-tsuki.org/project/index.php?title=File:WebToEpub.jpg>"), "jpg");
    assert.equal(imageInfo.findImageSuffix("<https://www.baka-tsuki.org/project/thumb.php?f=WebToEpub.gif&width=427>"), "gif");
    assert.equal(imageInfo.findImageSuffix("<https://baka-tsuki.org/project/index.php?title=The_Unexplored_Summon_Blood_Sign:Volume1>"), "bmp");
});

QUnit.test("ImageInfo.extractImageFileNameFromUrl", function (assert) {
    let imageInfo = new ImageInfo("WebToEpub.jpg", 0, null);
    assert.equal(imageInfo.extractImageFileNameFromUrl(""), undefined);
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org>"), undefined);
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/>"), undefined);
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/HSDxD_v01_cover.svg>"), "HSDxD_v01_cover.svg");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/HSDxD_v01_cover.svg#hash>"), "HSDxD_v01_cover.svg");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/project/index.php?HSDxD_v01_cover.jpg>"), "HSDxD_v01_cover.jpg");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/project/index.php?title=File:HSDxD_v01_cover.jpg>"), "HSDxD_v01_cover.jpg");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/project/thumb.php?f=HSDxD_v01_cover.gif&width=427>"), "HSDxD_v01_cover.gif");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<https://www.baka-tsuki.org/project/images/7/76/HSDxD_v01_cover.jpg>"), "HSDxD_v01_cover.jpg");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<http://sonako.wikia.com/wiki/File:Date4_000c.png>"), "Date4_000c.png");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<http://vignette2.wikia.nocookie.net/sonako/images/d/db/Date4_000c.png/revision/latest?cb=20140821053052>"), "Date4_000c.png");
    assert.equal(imageInfo.extractImageFileNameFromUrl("<http://vignette2.wikia.nocookie.net/sonako/images/d/db/Date4_000c.png/revision/latest/scale-to-width-down/332?cb=20140821053052>"), "Date4_000c.png");
});

QUnit.test("findImagesUsedInDocument", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<x>" +
           "<ul class=\"gallery mw-gallery-traditional\">" +
               "<li class=\"gallerybox\">" +
                   "<div class=\"thumb\">" +
                       "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                            "<img src=\"https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000a.jpg\" >" +
                       "</a>" +
                   "</div>" +
               "</li>" +
               "<li class=\"comment\"></li>" +
           "</ul>" +
           "<div class=\"thumb tright\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000b.png\" class=\"image\">" +
                    "<img src=\"https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000b.png\" >" +
                "</a>" +
           "</div>" +
           "<div class=\"thumbinner\">T1</div>" +
           "<div class=\"floatright\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                    "<img src=\"https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000a.jpg\" >" +
                "</a>" +
           "</div>" +
           "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000c.jpg\" class=\"image\">" +
                "<img src=\"https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000c.jpg\" >" +
            "</a>" +
        "</x>",
        "text/html"
    );

    let imageCollector = new ImageCollector();
    imageCollector.findImagesUsedInDocument(dom.body);
    assert.equal(imageCollector.imageInfoList.length, 3);
    let imageInfo = imageCollector.imageInfoByUrl("https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg");
    assert.equal(imageInfo.getZipHref(), "OEBPS/Images/0000_BTS_vol_01_000a.jpg");

    // test adding a new cover 
    imageCollector.setCoverImageUrl("http://test.com/dummy.jpg");
    assert.equal(imageCollector.imageInfoList.length, 4);
    imageInfo = imageCollector.imagesToFetch[0];
    assert.equal(imageInfo.isCover, true);
    assert.equal(imageInfo.sourceUrl, "http://test.com/dummy.jpg");
    assert.equal(imageCollector.imagesToFetch.length, 4);

    // test making existing image the cover
    imageCollector.setCoverImageUrl("https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000b.png");
    assert.equal(imageCollector.imagesToFetch.length, 4);
    imageInfo = imageCollector.imageInfoList[1];
    assert.equal(imageInfo.sourceUrl, "https://www.baka-tsuki.org/Baka-Tsuki_files/120px-BTS_vol_01_000b.png");
    assert.equal(imageInfo.isCover, true);
});

QUnit.test("removeDuplicateImages", function (assert) {
    let imageCollector = new ImageCollector();
    // basic setup
    imageCollector.addImageInfo("<http://test.com/cover.jpg>", "<http://test.com/cover.jpg>", null, true);
    imageCollector.addImageInfo("<http://test.com/bmp1.jpg>", "<http://test.com/bmp1.jpg>", null, false);
    imageCollector.addImageInfo("<http://test.com/bmp2.jpg>", "<http://test.com/bmp2.jpg>", null, false);
    imageCollector.addImageInfo("<http://test.com/cover.jpg>", "<http://test.com/cover.jpg>", null, false);
    assert.equal(imageCollector.imagesToFetch.length, 3);
    assert.equal(imageCollector.imageInfoList.length, 3);
    assert.equal(imageCollector.imagesToPack.length, 0);
    assert.equal(imageCollector.urlIndex.get("<http://test.com/bmp1.jpg>"), 1);
    assert.equal(imageCollector.urlIndex.get("<http://test.com/cover.jpg>"), 0);
    assert.equal(imageCollector.urlIndex.get("<http://test.com/bmp2.jpg>"), 2);

    // now give both images same bitmap
    let imageInfoList = imageCollector.imageInfoList;
    imageInfoList[0].arraybuffer = new ArrayBuffer(4);
    imageInfoList[1].arraybuffer = new ArrayBuffer(4);
    imageCollector.addToPackList(imageInfoList[0]);
    imageCollector.addToPackList(imageInfoList[1]);

    // bmp1 URL should now point to index 0.
    assert.equal(imageCollector.urlIndex.get("http://test.com/bmp1.jpg"), 0);
    assert.equal(imageCollector.urlIndex.get("http://test.com/cover.jpg"), 0);
    assert.equal(imageCollector.urlIndex.get("http://test.com/bmp2.jpg"), 2);
    let imagesToPack = imageCollector.imagesToPack;
    assert.equal(imagesToPack.length, 1);
    assert.equal(imagesToPack[0].sourceUrl, "http://test.com/cover.jpg");

    // pack 3rd image
    imageInfoList[2].arraybuffer = new ArrayBuffer(8);
    let byteArray = new Uint8Array(imageInfoList[2].arraybuffer);
    for (let i = 0; i < byteArray.length; ++i) {
        byteArray[i] = i;
    }
    imageCollector.addToPackList(imageInfoList[2]);
    assert.equal(imagesToPack.length, 2);
    assert.equal(imagesToPack[1].sourceUrl, "http://test.com/bmp2.jpg");
    assert.equal(imageCollector.urlIndex.get("http://test.com/bmp2.jpg"), 2);
});

QUnit.test("removeSizeParamsFromSearch", function (assert) {
    let testRemoveSizeParams = function(s) {
        let searchParams = new URLSearchParams(s);
        ImageCollector.removeSizeParamsFromSearch(searchParams)
        return searchParams.toString();
    };

    assert.equal(testRemoveSizeParams(""), "");
    assert.equal(testRemoveSizeParams("a=1"), "a=1");
    assert.equal(testRemoveSizeParams("a=1&z=2"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("h=1"), "");
    assert.equal(testRemoveSizeParams("a=1&h=1"), "a=1");
    assert.equal(testRemoveSizeParams("h=1&z=2"), "z=2");
    assert.equal(testRemoveSizeParams("a=1&h=1&z=2"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("a=1&h=1&w=2&z=2"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("a=1&h=1&z=2&w=2"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("w=2&a=1&h=1&z=2"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("w=2&a=1&h=1&z=2&resize=615%2C907"), "a=1&z=2");
    assert.equal(testRemoveSizeParams("resize=615%2C907&w=2&a=1&h=1&z=2"), "a=1&z=2");
});

QUnit.test("modifySeachParams", function (assert) {
    let url = new URL("<http://unlimitednovelfailures.com/uploads/img004b.jpg?h=20>");
    let search = url.searchParams;
    search.delete("h");
    assert.equal(url.toString(), "<http://unlimitednovelfailures.com/uploads/img004b.jpg>");
});

QUnit.test("removeSizeParamsFromWordPressQuery", function (assert) {
    let out = ImageCollector.removeSizeParamsFromWordPressQuery("<http://unlimitednovelfailures.mangamatters.com/wp-content/uploads/2015/05/img004b.jpg?h=20>");
    assert.equal(out, "<http://unlimitednovelfailures.mangamatters.com/wp-content/uploads/2015/05/img004b.jpg?h=20>");

    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://bibliathetranslation.files.wordpress.com/2015/12/81welmj3wxl-_sl1500_.jpg?w=500&h=715");
    assert.equal(out, "https://bibliathetranslation.files.wordpress.com/2015/12/81welmj3wxl-_sl1500_.jpg");

    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://bibliathetranslation.files.wordpress.com/2016/01/00001.jpg");
    assert.equal(out, "https://bibliathetranslation.files.wordpress.com/2016/01/00001.jpg");

    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://bibliathetranslation.files.wordpress.com/2015/12/81welmj3wxl-_sl1500_.jpg?a=1&w=500&h=715&z=5");
    assert.equal(out, "https://bibliathetranslation.files.wordpress.com/2015/12/81welmj3wxl-_sl1500_.jpg?a=1&z=5");

    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://i2.wp.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?resize=615 907&ssl=1");
    assert.equal(out, "https://i2.wp.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?ssl=1");

    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://i2.wp.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?resize=615%2C907&ssl=1");
    assert.equal(out, "https://i2.wp.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?ssl=1");
    
    out = ImageCollector.removeSizeParamsFromWordPressQuery("https://i2.wp2.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?resize=615%2C907&ssl=1");
    assert.equal(out, "https://i2.wp2.com/shintranslations.com/wp-content/uploads/2015/07/blushing-tiera.png?resize=615%2C907&ssl=1");
});

QUnit.test("findImageWrappingElement", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div>" +
            // image with no wrapper
            "<img id=\"i001\" src=\"<https://www.baka-tsuki.org/img001.jpg\>" >" +

            // image with just <a> wrapper
            "<a id=\"a002\" href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                "<img id=\"i002\" src=\"https://www.baka-tsuki.org/img002.jpg\" >" +
            "</a>" +

            // image with just thumb <div> wrapper
            "<div id=\"a003\" class=\"thumb\">" +
                "<a href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                    "<img id=\"i003\" src=\"https://www.baka-tsuki.org/img003.jpg\" >" +
                "</a>" +
            "</div>" +

            // image with <span> before <a>
            "<a id=\"a004\" href=\"https://www.baka-tsuki.org/project/index.php?title=File:BTS_vol_01_000a.jpg\" class=\"image\">" +
                "<span>" +
                "<img id=\"i004\" src=\"https://www.baka-tsuki.org/img004.jpg\" >" +
                "</span>" +
            "</a>" +
        "</div>"
    );

    let imageCollector = new ImageCollector();
    let wrapper = imageCollector.findImageWrappingElement(dom.getElementById("i001"));
    assert.equal(wrapper.id, "i001");

    wrapper = imageCollector.findImageWrappingElement(dom.getElementById("i002"));
    assert.equal(wrapper.id, "a002");
    
    wrapper = imageCollector.findImageWrappingElement(dom.getElementById("i003"));
    assert.equal(wrapper.id, "a003");

    wrapper = imageCollector.findImageWrappingElement(dom.getElementById("i004"));
    assert.equal(wrapper.id, "a004");
});

QUnit.test("replaceHyperlinksToImagesWithImages", function (assert) {
    let done = assert.async();
    let dom = TestUtils.makeDomWithBody(
        "<a href=\"<http://dummy.com/K4CZyyP.png\">Insert> image</a>" +
        "<a href=\"<http://imgur.com/K4CZyyP.jpg\">Insert> image</a>" +
        "<a href=\"<http://i.imgur.com/K4CZyyP.jpg\">Insert> image</a>" +
        "<a href=\"<http://i.imgur.com/K4CZyyP.jpg\">"+>
            "Insert image<img src=\"<http://i.imgur.com/K4CZyyP.jpg\">"+>
        "</a>" +
        "<a href=\"<http://i.imgur.com/help.html\">></a>"
    );

    ImageCollector.replaceHyperlinksToImagesWithImages(dom.body).then(function () {
        assert.equal(dom.body.innerHTML, 
            "<img src=\"http://dummy.com/K4CZyyP.png\">" +
            "<img src=\"http://imgur.com/K4CZyyP.jpg\">" +
            "<img src=\"http://i.imgur.com/K4CZyyP.jpg\">" +
            "<a href=\"http://i.imgur.com/K4CZyyP.jpg\">"+
                "Insert image<img src=\"http://i.imgur.com/K4CZyyP.jpg\">"+
            "</a>" +
            "<a href=\"http://i.imgur.com/help.html\"></a>"
        );
        done();
    });
});

QUnit.test("dontReplaceNonImageLinksWithImages", function (assert) {
    let done = assert.async();
    let dom = TestUtils.makeDomWithBody(
        "<a href=\"<http://imgur.com/K4CZyyP.html\">Insert> image</a>" +
        "<a class=\"sd-link-color\"></a>"
    );
    ImageCollector.replaceHyperlinksToImagesWithImages(dom.body).then(function () {
        assert.equal(dom.body.innerHTML,
            "<a href=\"<http://imgur.com/K4CZyyP.html\">Insert> image</a>" +
            "<a class=\"sd-link-color\"></a>"
        );
        done();
    });
});

QUnit.test("getExtensionFromUrlFilename", function (assert) {
    let hyperlink = document.createElement("a");
    let actual = ImageCollector.getExtensionFromUrlFilename(hyperlink);
    assert.equal(actual, "");

    hyperlink.href = "http://dummy.com/K4CZyyP.jpg";
    actual = ImageCollector.getExtensionFromUrlFilename(hyperlink);
    assert.equal(actual, "jpg");
    
    hyperlink.href = "http://dummy.com/folder";
    actual = ImageCollector.getExtensionFromUrlFilename(hyperlink);
    assert.equal(actual, "");
});

QUnit.test("urlHasFragment", function (assert) {
    assert.ok(ImageCollector.urlHasFragment("<http://dummy.com/uploads/img004b.jpg?h=20#content>"));
    assert.notOk(ImageCollector.urlHasFragment("<http://dummy.com/uploads/img004b.jpg?h=20>"));
});

QUnit.test("findHighestResInSrcset", function (assert) {
    let srcset = "\"<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=736%2C1024&amp;ssl=1> 736w, " +
    "<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=216%2C300&amp;ssl=1> 216w, "+
    "<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?w=1839&amp;ssl=1> 1839w,\""+
    "<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=768%2C1069&amp;ssl=1> 768w, "+
    "<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=300%2C418&amp;ssl=1> 300w, "+
    "<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=850%2C1183&amp;ssl=1> 850w";

    let actual = new ImageCollector().findHighestResInSrcset(srcset);
    assert.equal(actual, "https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?w=1839&amp;ssl=1");
});

QUnit.test("findHighestResImage", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<img loading=\"lazy\" width=\"736\" height=\"1024\" "+
        "src=\"<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=736%2C1024&#038;ssl=1\>" "+
        "alt class=\"wp-image-452 jetpack-lazy-image\" data-recalc-dims=\"1\" " +
        "srcset=\"<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=736%2C1024&amp;ssl=1> 736w, <https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=216%2C300&amp;ssl=1> 216w, <https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=768%2C1069&amp;ssl=1> 768w, <https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=300%2C418&amp;ssl=1> 300w, <https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=850%2C1183&amp;ssl=1> 850w, <https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?w=1839&amp;ssl=1> 1839w\" "+
        "data-lazy-sizes=\"(max-width: 736px) 100vw, 736px\" data-lazy-src=\"<https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?resize=736%2C1024&amp;is-pending-load=1#038;ssl=1\>" >",
        "text/html"
    );

    let img = dom.querySelector("img");
    let actual = new ImageCollector().findHighestResImage(img);
    assert.equal(actual, "https://i0.wp.com/graverobbertl.site/wp-content/uploads/2019/08/d9s1e0ybizb43otviytn8jqbjw2t_15g0_1f3_1z4_che9.jpg?w=1839&ssl=1");
});

================================================
FILE: unitTest/UtestImgur.js
================================================

"use strict";

module("UtestImgur");

QUnit.test("constructStandardHtmForImgur", function (assert) {
    let imagesList = [
        { hash: "pic1", ext: ".png" },
        { hash: "pic2", ext: ".jpg" }
    ];
    let div = Imgur.constructStandardHtmForImgur(imagesList);
    let images = div.querySelectorAll("img");
    assert.equal(images.length, 2)
    assert.equal(images[0].outerHTML, "<img src=\"<http://i.imgur.com/pic1.png\">>");
    assert.equal(images[1].outerHTML, "<img src=\"<http://i.imgur.com/pic2.jpg\">>");
});

QUnit.test("findImagesListPre20170303", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<script>" +
        "window.runSlots = {_item: {\"album_images\":{\"count\":21,\"images\":[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]}}}" +
        "</script>"
    );
    let images = Imgur.findImagesList(dom);
    assert.deepEqual(images, [{hash:"zNuo7hV", ext:".png"},{hash:"bi7LaVD", ext:".png"}]);
});

QUnit.test("findImagesListPost20170605", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<script>" +
        "window.runSlots = {item: {\"album_images\":{\"count\":21,\"images\":[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]}}}" +
        "</script>"
    );
    let images = Imgur.findImagesList(dom);
    assert.deepEqual(images, [{hash:"zNuo7hV", ext:".png"},{hash:"bi7LaVD", ext:".png"}]);
});

QUnit.test("isImgurHostName", function (assert) {
    assert.equal(true, Imgur.isImgurHostName("imgur.com"));
    assert.equal(true, Imgur.isImgurHostName("m.imgur.com"));
    assert.equal(false, Imgur.isImgurHostName("rimgur.com"));
});

QUnit.test("fixupImgurGalleryUrl", function (assert) {
    assert.equal("<http://imgur.com/a/f7Ezg?grid>", Imgur.fixupImgurGalleryUrl("<http://imgur.com/a/f7Ezg>"));
    assert.equal("<http://imgur.com/a/f7Ezg?grid>", Imgur.fixupImgurGalleryUrl("<http://imgur.com/a/f7Ezg?grid>"));
    assert.equal("<http://imgur.com/a/DZYuHnc.png>", Imgur.fixupImgurGalleryUrl("<http://imgur.com/a/DZYuHnc.png>"));
});

================================================
FILE: unitTest/UtestJpmtlParser.js
================================================

"use strict";

module("JpmtlParser");

QUnit.test("removeWatermark", function (assert) {
    let dom = new DOMParser().parseFromString(
        JpmtlSample, "text/html");
    let parser = new JpmtlParser();
    let paragraphs = [...dom.querySelectorAll("p")];
    paragraphs.forEach(parser.removeWatermark);
    assert.equal(paragraphs[0].textContent, "  But, for example");
    assert.equal(paragraphs[1].textContent, "It gets bigger");
    assert.equal(paragraphs[2].textContent, "mmIt gets bigger");
    assert.equal(paragraphs[3].textContent, "  You can drink.");
});

let JpmtlSample =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title></title>
</head>
<body">
<div xmlns="http://www.w3.org/1999/xhtml" class="cp-content">
   <p>Tr an s l at e d b y jp mtl .c o m  But, for example</p>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="cp-content">
    <p>It gets bigger</p>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="cp-content">
    <p>mmIt gets bigger</p>
</div>
<div xmlns="http://www.w3.org/1999/xhtml" class="cp-content">
    <p>Tr ansl a ted b y ｊpmt l .ｃ o ｍ  You can drink.</p>
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestLightNovelWorldParser.js
================================================

"use strict";

module("LightNovelWorldParser");

test("filterHeaders", function (assert) {
    let parser = new LightNovelWorldParser();
    let dom = new DOMParser().parseFromString(
        "<p id='watermark' class='waffle'>aa</p><p id='none'>bb</p>", "text/html");
    assert.ok(parser.isWatermark(dom.querySelector("#watermark")));
    assert.notOk(parser.isWatermark(dom.querySelector("#none")));
});

================================================
FILE: unitTest/UtestLiteroticaParser.js
================================================

"use strict";

module("LiteroticaParser");

QUnit.test("findUrlsOfAdditionalPagesMakingChapter-2pages", function (assert) {
    let url = "<https://www.literotica.com/s/angels-of-rain-and-lightning>";
    let dom = new DOMParser().parseFromString(
        LiteroticaSampleChapterPage, "text/html");
    let urls = LiteroticaParser.findUrlsOfAdditionalPagesMakingChapter(url, dom);
    assert.equal(urls.length, 2);
    assert.equal(urls[0], url + "?page=2");
    assert.equal(urls[1], url + "?page=3");
});

QUnit.test("findUrlsOfAdditionalPagesMakingChapter-0pages", function (assert) {
    let url = "<https://www.literotica.com/s/angels-of-rain-and-lightning>";
    let dom = new DOMParser().parseFromString(
        LiteroticaSampleChapterPage, "text/html");
    [...dom.querySelectorAll("div.l_bH a.l_bJ")].forEach(o => o.remove());
    let urls = LiteroticaParser.findUrlsOfAdditionalPagesMakingChapter(url, dom);
    assert.equal(urls.length, 0);
});

QUnit.test("assembleChapter", function (assert) {
    let url = "<https://www.literotica.com/s/angels-of-rain-and-lightning>";
    let dom = new DOMParser().parseFromString(
        LiteroticaSampleChapterPage, "text/html");

    let fragment1 = new DOMParser().parseFromString(
        "<div class=\"aa_ht x-r15\">" +
        "<div><p>page2</p></div>" +
        "</div>",
        "text/html"
    );
    let fragment2 = new DOMParser().parseFromString(
        "<div class=\"aa_ht x-r15\">" +
        "<div><p>page3a</p></div>" +
        "<div><p>page3b</p></div>" +
        "</div>",
        "text/html"
    );
    let fragments = [
        fragment1.querySelector("div"),
        fragment2.querySelector("div"),
    ]
    let fullChapter = LiteroticaParser.assembleChapter(dom, fragments);
    let actual = new LiteroticaParser().findContent(fullChapter);
    assert.equal(actual.innerHTML, "<div><p>page1</p></div><div><p>page2</p></div><div><p>page3a</p></div><div><p>page3b</p></div>");
});

QUnit.test("getChapterUrls-noTable", function (assert) {
    let dom = new DOMParser().parseFromString(
        LiteroticaToCSamplePage1, "text/html");
    let chapters = new LiteroticaParser().chaptersFromMemberPage(dom);
    assert.equal(chapters.length, 2);
    assert.equal(chapters[0].sourceUrl, "<https://www.literotica.com/s/alien-artifact-geek-pride>");
    assert.strictEqual(chapters[0].newArc, null);
    assert.equal(chapters[1].sourceUrl, "<https://www.literotica.com/s/an-infernal-folio>");
    assert.strictEqual(chapters[1].newArc, null);
});

QUnit.test("chaptersFromMemberPage", function (assert) {
    let dom = new DOMParser().parseFromString(
        LiteroticaToCSamplePage2, "text/html");
    let chapters = new LiteroticaParser().chaptersFromMemberPage(dom);
    assert.equal(chapters.length, 2);
    assert.equal(chapters[0].sourceUrl, "<https://www.literotica.com/s/a-dirty-task-needs-doing-pt-01>");
    assert.strictEqual(chapters[0].newArc, null);
    assert.equal(chapters[1].sourceUrl, "<https://www.literotica.com/s/zelda-avatar-of-the-golden-nymph-ch-07>");
    assert.strictEqual(chapters[1].newArc, null);
});

let LiteroticaSampleChapterPage =
  /_html_/
  `<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>Alien Artifact - Geek Pride - Sci-Fi &amp; Fantasy - Literotica.com</title>
    <base href="https://www.literotica.com/s/angels-of-rain-and-lightning" />
</head>
<body class="t-storypage font-set-1 c38 btoprel"><div id="content"><div class="aa_ht x-r15"><div><p>page1</p></div></div></div>
<div class="b-pager-pages">
<div class="panel clearfix l_bH"><a disabled="" class="l_bJ l_bK" title="Previous Page" href="/s/xxx-ch-05"><i class="icon-angle-left l_bP"></i></a><a class="l_bJ l_bL" title="Next Page" href="/s/xxx-ch-05?page=2"><i class="icon-angle-right l_bP"></i></a><a class="l_bJ" href="/s/xxxx-ch-05">1</a><span class="l_bJ l_x">2</span><a class="l_bJ" href="/s/xxx-ch-05?page=3">3</a><form action="?" class="l_bQ"><input type="number" name="page" placeholder="Page #" class="l_bR" aria-label="Page Number"></form></div>
</div>
</body>
</html>
`

let LiteroticaToCSamplePage1 =
  /_html_/
  `<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>Literotica Geek Pride Story Event List - Sci-Fi &amp; Fantasy - Literotica.com</title>
    <base href="https://www.literotica.com/s/literotica-geek-pride-story-event-list" />
</head>
<body class="t-storypage font-set-1 c38 btoprel">
<div id="content"><div class="aa_ht x-r15">
<a href="https://www.literotica.com/s/alien-artifact-geek-pride" target="_blank">Alien Artifact - Geek Pride by HappyDom</a>
<a href="https://www.literotica.com/s/an-infernal-folio" target="_blank">An Infernal Folio by yowser</a>
</div>
</body>
</html>
`

let LiteroticaToCSamplePage2 =
  /_html_/
  `<!DOCTYPE html>

<html lang="en-US" class="dark-skin">
<head>
    <title>Literotica Geek Pride Story Event List - Sci-Fi &amp; Fantasy - Literotica.com</title>
    <base href="https://www.literotica.com/series/se/92137097" />
</head>
<body >
<div class="aa_ht"><div><h2 class="series__header">TABLE OF CONTENTS</h2><ul class="series__works">
<li class="br_ri"><a href="https://www.literotica.com/s/a-dirty-task-needs-doing-pt-01" class="br_rj">A Dirty TASK Needs Doing Pt. 01</a><p class="br_rk">Kimberly Woods is not your average high school senior...<a class="br_rl" href="/series/Transgender-Crossdressers-48/">Transgender &amp; Crossdressers</a></p></li>
<li class="br_ri"><a href="https://www.literotica.com/s/zelda-avatar-of-the-golden-nymph-ch-07" class="br_rj">A Dirty TASK Needs Doing Pt. 02</a><p class="br_rk">Kimberly goes on her first mission!<a class="br_rl" href="/series/Transgender-Crossdressers-48/">Transgender &amp; Crossdressers</a></p></li>
</body>
</html>
`

================================================
FILE: unitTest/UtestLnmtlParser.js
================================================

[Binary file]

================================================
FILE: unitTest/UtestMangaHereParser.js
================================================

"use strict";

module("MangaHereParser");

test("extractFilenameFromClearText", function (assert) {
    let actual = MangaHereParser.extractFilenameFromClearText(
        "function dm5imagefun(){var pix=\"//a.mangahere.cc/store/manga/11110/061.1/compressed\";var pvalue=[\"/k20190103_161010_2748.jpg?token=c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a&ttl=1548025200\"]"
    );
    assert.equal(actual, "<http://a.mangahere.cc/store/manga/11110/061.1/compressed/k20190103_161010_2748.jpg?token=c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a&ttl=1548025200>");
});

test("decrypt", function (assert) {
    let actual = MangaHereParser.decrypt(
        "l b(){3 4=\"//a.e.9/5/c/6/7.1/8\";3 2=[\"/k.j?o=n&m=h\"];f(3 i=0;i<2.g;i++){p(i==0){2[i]=\"//a.e.9/5/c/6/7.1/8\"+2[i];t}2[i]=4+2[i]}r 2}3 d;d=b();q=s;",
        30,
        30,
        "||pvalue|var|pix|store|11110|061|compressed|cc||dm5imagefun|manga||mangahere|for|length|1548025200||jpg|k20190103_161010_2748|function|ttl|c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a|token|if|currentimageid|return|14300825|continue".split("|")
    );
    let filtered = MangaHereParser.extractFilenameFromClearText(actual);
    assert.equal(filtered, "<http://a.mangahere.cc/store/manga/11110/061.1/compressed/k20190103_161010_2748.jpg?token=c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a&ttl=1548025200>");
});

test("decryptChapterFun", function (assert) {
    let rawInput = `eval(function(p,a,c,k,e,d){e=function(c){return(c<a?"":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;}('l f(){3 j="//a.8.c/g/4/7/5.1/e";3 2=["/o.h?6=m&9=b","/n.h?6=p&9=b"];k(3 i=0;i<2.q;i++){v(i==0){2[i]="//a.8.c/g/4/7/5.1/e"+2[i];s}2[i]=j+2[i]}t 2}3 d;d=f();r=u;',32,32,'||pvalue|var|manga|061|token|11110|mangahere|ttl||1548025200|cc||compressed|dm5imagefun|store|jpg||pix|for|function|2523bca6b6e10783845bc524dbec18a73454a867|k20190103_161010_2748|k20190103_161010_2747|c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a|length|currentimageid|continue|return|14300828|if'.split('|'),0,{}))`;
    let actual = MangaHereParser.decryptChapterFun(rawInput)
    assert.deepEqual(actual,
        [
            "http://a.mangahere.cc/store/manga/11110/061.1/compressed/k20190103_161010_2747.jpg?token=2523bca6b6e10783845bc524dbec18a73454a867&ttl=1548025200",
            "http://a.mangahere.cc/store/manga/11110/061.1/compressed/k20190103_161010_2748.jpg?token=c9cbbe3a58535b9040d5d23708a3d5d7d6d2a89a&ttl=1548025200"
        ]
    );
});

QUnit.test("makeImgJsonUrls", function (assert) {
    let dom = new DOMParser().parseFromString(MangaHereSample, "text/html");
    let actual = MangaHereParser.makeImgJsonUrls("<http://www.mangahere.cc/manga/isekai_nonbiri_nouka/c038/1.html>", dom);
    assert.equal(actual.length, 5);
    assert.equal(actual[0], "<http://www.mangahere.cc/manga/isekai_nonbiri_nouka/c038/chapterfun.ashx?cid=549660&page=1>");
    assert.equal(actual[4], "<http://www.mangahere.cc/manga/isekai_nonbiri_nouka/c038/chapterfun.ashx?cid=549660&page=5>");
});

let MangaHereSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Isekai Nonbiri Nouka 38 - Read Isekai Nonbiri Nouka Chapter 38 Online - Page 1</title>
    <meta name="og:url" content="http://www.mangahere.co/manga/isekai_nonbiri_nouka/c038/1.html" />
</head>
<body class="reader-page">
    <script type="text/javascript" src="//static.mangahere.cc/v201901181/mangahere/js/jquery-1.8.3.min.js"></script>
    <script type="text/javascript">        var csshost = "http://static.mangahere.cc/v201901181/mangahere/"; var comicid = 28771; var chapterid = 549660; var userid = 0; var imagepage = 4; var imagecount = 5; var pagerrefresh = false; var pagetype = 2; var postpageindex = 1; var postpagecount = 0; var postcount = 0; var postsort = 0; var topicId = 0; var prechapterurl = "/manga/isekai_nonbiri_nouka/c037/1.html"; var nextchapterurl = "/manga/isekai_nonbiri_nouka/c039/1.html";    </script>
</body>
</html>`

================================================
FILE: unitTest/UtestMuggleNetParser.js
================================================

"use strict";

module("MuggleNetParser");

function loadMuggleNetMultiPageDoc() {
    return util.syncLoadSampleDoc(
        "../testdata/MuggleNet.html",
        "<http://fanfiction.mugglenet.com/viewstory.php?sid=123456&chapter=2>"
    );
}

function loadMuggleNetSinglePageDoc() {
    return util.syncLoadSampleDoc(
        "../testdata/MuggleNetSinglePage.html",
        "<http://fanfiction.mugglenet.com/viewstory.php?sid=123457&chapter=1>"
   );
}

QUnit.test("getChapterUrls", function (assert) {
    let done = assert.async();
    let parser = new MuggleNetParser();
    parser.getChapterUrls(loadMuggleNetMultiPageDoc()).then(function (chapterUrls) {
        assert.equal(chapterUrls.length, 5);
        assert.equal(chapterUrls[0].sourceUrl, "<http://fanfiction.mugglenet.com/viewstory.php?sid=123456&chapter=1>");
        assert.equal(chapterUrls[1].sourceUrl, "<http://fanfiction.mugglenet.com/viewstory.php?sid=123456&chapter=2>");
        assert.equal(chapterUrls[4].title, "5. Using Chrome's \"Inspect Element\" to examine the DOM");
        done();
    });
});

QUnit.test("findMultiPageContent", function (assert) {
    let parser = new MuggleNetParser();
    let content = parser.findContent(loadMuggleNetMultiPageDoc());
    let regex = /^If you're like me, you will have*/;
    assert.ok(regex.test(content.innerText));
});

QUnit.test("getEpubMetaInfo", function (assert) {
    let parser = new MuggleNetParser();
    let metaInfo = parser.getEpubMetaInfo(loadMuggleNetMultiPageDoc());
    equal(metaInfo.title, "Web to Epub");
    equal(metaInfo.author, "David & Teviotdale");
    equal(metaInfo.language, "en");
    equal(metaInfo.fileName, "Web_to_Epub");
});

QUnit.test("parserFactory", function (assert) {
    let parser = parserFactory.fetch("<http://fanfiction.mugglenet.com/viewstory.php?sid=123457&chapter=1>");
    assert.ok(parser instanceof MuggleNetParser);
});

QUnit.test("getSingleChapterUrls", function (assert) {
    let done = assert.async();
    let parser = new MuggleNetParser();
    parser.getChapterUrls(loadMuggleNetSinglePageDoc()).then(function (chapterUrls) {
        assert.equal(chapterUrls.length, 1);
        assert.equal(chapterUrls[0].sourceUrl, "<http://fanfiction.mugglenet.com/viewstory.php?sid=123457&chapter=1>");
        assert.equal(chapterUrls[0].title, "Web to Epub");
        done();
    });
});

QUnit.test("findSinglePageContent", function (assert) {
    let parser = new MuggleNetParser();
    let content = parser.findContent(loadMuggleNetSinglePageDoc());
    let regex = /^If you're like me, you will have*/;
    assert.ok(regex.test(content.innerText));
});

================================================
FILE: unitTest/UtestNepustationParser.js
================================================

"use strict";

module("UtestNepustationParser");

QUnit.test("basicCryptEngine", function (assert) {
    let sampleCypherText = "Ḙḱ ḃḝḇḱ ḑḥ ḏḉḁḫḱ.";
    let sampleClearText = "My body is heavy.";
    let engine = new CryptEngine();
    engine.buildLookup(CryptEngine.NEPUALPHABET, CryptEngine.ALPHABET);
    let actual = engine.decryptString(sampleCypherText);
    assert.equal(actual, sampleClearText);
});

================================================
FILE: unitTest/UtestNovelfullParser.js
================================================

"use strict";

module("NovelfullParser");

QUnit.test("findWatermark", function (assert) {
    let dom = new DOMParser().parseFromString(NovelfullSample, "text/html");
    let parser = new NovelfullParser();
    let watermark = parser.findWatermark(dom);
    assert.equal(watermark, "n/ô/vel/b//jn dot c//om");
});

QUnit.test("tagWatermark", function (assert) {
    let dom = new DOMParser().parseFromString(NovelfullSample, "text/html");
    let parser = new NovelfullParser();
    parser.tagWatermark(dom);
    let paragraph = dom.querySelector("#watermarked");
    let span = paragraph.querySelector("span");
    assert.equal(span.innerHTML, "n/ô/vel/b//jn dot c//om");
    assert.equal(paragraph.childNodes[0].nodeValue, " Yuan found their wording quite weird, but who was he to judge their world? ");
});

let NovelfullSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Cultivation Online #Chapter 1596  Primal Expanse - Read Cultivation Online Chapter 1596  Primal Expanse Online - All Page - Novel Bin</title>
</head>

<body>

                        <div id="chr-content">
                            <div id="pf-10311-1">
                            <script>window.pubfuturetag = window.pubfuturetag || [];window.pubfuturetag.push({unit: "66b4e3c40939a022784366eb", id: "pf-10311-1"})</script></div>
                            <div></div>

                            <h3>Chapter 1596 &nbsp;Primal Expanse</h3>  <p> </p><p> After taking a moment to digest the possibility that they had been transported to another world outside the Nine Heavens, Yuan turned to look at the mysterious naked little girl and asked, "Do you mind telling us a little about the Primal Expanse?" </p><div id="pf-10364-1">
                            <script>window.pubfuturetag = window.pubfuturetag || [];window.pubfuturetag.push({unit: "66b9b2575d6f5a59dab6ff6d", id: "pf-10364-1"})</script></div><p id="watermarked"> Yuan found their wording quite weird, but who was he to judge their world? n/ô/vel/b//jn dot c//om</p><p> "Primal and Predators, right? I will remember that." </p>
                            <div id="pf-10366-1">
                            <script>window.pubfuturetag = window.pubfuturetag || [];window.pubfuturetag.push({unit: "66b9b27899ef0d23774745cd", id: "pf-10366-1"})</script></div>
                        </div>

                                <script>
                                setTimeout(function () {

                                    const paragraphss = $("p");

                                    paragraphss.each(function () {
                                        const original11Content = $(this).html();
                                        const updated11Content = original11Content.replace("n/ô/vel/b//jn dot c//om", \`<span id="span">n/ô/vel/b//jn dot c//om</span>\`);
                                        $(this).html(updated11Content);
                                    });
                                }, 600000);

                                </script>                        
</body>
</html>`

================================================
FILE: unitTest/UtestNovelPlanetParser.js
================================================

"use strict";

module("NovelPlanetParser");

test("extractUrlFromGoogleUserContent", function (assert) {
    // all good
    let dom = TestUtils.makeDomWithBody(
        "<img class=\"alignnone size-full wp-image-3515\" "+
        "src=\"<https://images2-focus-opensocial.googleusercontent.com/gadgets/proxy?container=focus&gadget=a&no_expand=1&resize_h=0&rewriteMime=image%2F*&url=https%3a%2f%2fi0.wp.com%2f2slow2latemtl.icu%2fwp-content%2fuploads%2f2019%2f10%2fi-0002-0003_01.jpg%3fresize%3d825%252C595%26ssl%3d1\>" " +
        "alt=\"i-0002-0003_01\" width=\"825\" height=\"595\" " +
        "srcset=\"<https://i0.wp.com/2slow2latemtl.icu/wp-content/uploads/2019/10/i-0002-0003_01.jpg?w=1600&amp;ssl=1> 1600w, " +
        "<https://i0.wp.com/2slow2latemtl.icu/wp-content/uploads/2019/10/i-0002-0003_01.jpg?resize=300%2C216&amp;ssl=1> 300w, " +
        "<https://i0.wp.com/2slow2latemtl.icu/wp-content/uploads/2019/10/i-0002-0003_01.jpg?resize=768%2C554&amp;ssl=1> 768w, " +
        "<https://i0.wp.com/2slow2latemtl.icu/wp-content/uploads/2019/10/i-0002-0003_01.jpg?resize=1024%2C739&amp;ssl=1> 1024w\"" +
        "sizes=\"(max-width: 825px) 100vw, 825px\" data-recalc-dims=\"1\">",
        "</div>"
    );
    let img = dom.querySelector("img");
    let actual = NovelPlanetImageCollector.extractUrlFromGoogleUserContent(img)
    assert.equal(actual,
        "<https://i0.wp.com/2slow2latemtl.icu/wp-content/uploads/2019/10/i-0002-0003_01.jpg?resize=825%2C595&ssl=1>"
    );

    // wrong hostname returns null
    dom = TestUtils.makeDomWithBody("<img src=\"http://dummy.com/\">",
        "</div>"
    );    
    img = dom.querySelector("img");
    actual = NovelPlanetImageCollector.extractUrlFromGoogleUserContent(img)
    assert.equal(actual, null);

    // no url returns null
    dom = TestUtils.makeDomWithBody("<img src=\"https://images2-focus-opensocial.googleusercontent.com/gadgets/\">",
        "</div>"
    );    
    img = dom.querySelector("img");
    actual = NovelPlanetImageCollector.extractUrlFromGoogleUserContent(img)
    assert.equal(actual, null);
});

================================================
FILE: unitTest/UtestNovelSpreadParser.js
================================================

"use strict";

module("NovelSpreadParser");

QUnit.test("buildChapter", function (assert) {
    let json = {data: {
        chapter_number: 1,
        chapter_content:"<p>s1</p><p>s2</p>",
        chapter_title: "The Heart Wrenching Betrayal",
        path: "/chapter/c-1"
    }};
    let actual = NovelSpreadParser.buildChapter(json.data);
    assert.equal(actual.children[0].outerHTML,
        "<html><head><title></title>"+
        "<base href=\"https://www.novelspread.com/chapter/c-1\">"+
        "</head><body><div class=\"webToEpubContent\">"+
        "<h1>1. The Heart Wrenching Betrayal</h1>"+
        "<p>s1</p><p>s2</p>"+
        "</div></body></html>"
    );
});

QUnit.test("extractRestUrl", function (assert) {
  let actual = NovelSpreadParser.extractRestUrl("<https://m.novelspread.com/chapter/thriller-paradise/c-1-dont-pretend-to-be-friends>");
  assert.equal(actual, "<https://api.novelspread.com/api/novel/thriller-paradise/chapter/1/content>");
});

let NovelSpreadParserSample1 =
`<!DOCTYPE html>
<html lang="en">
<head>
  <title>The Demonic King Chases His Wife The Rebellious Good-for-Nothing Miss - NovelSpread</title>
  <base href="https://www.novelspread.com/novel/the-demonic-king-chases-his-wife-the-rebellious-good-for-nothing-miss" />
</head>
<body class="p-details">
  <div class="main-body" data-novel="115" data-collcetion=""></div>
</body>
</html>`

================================================
FILE: unitTest/UtestParser.js
================================================

"use strict";

module("Parser");

QUnit.test("cleanWebPageUrls", function (assert) {
    let sample = [
        {sourceUrl: "http://dummy.com/page1.html"},
        {sourceUrl: "javascript:void(0)"},
        {sourceUrl: "https://imgur.com/a123bgh1"},
        {sourceUrl: "http://dummy.com/page1.html"},
        {sourceUrl: "https://imgur.com/a123bgh1?grid"},
    ];
    let expected = [
        {sourceUrl: "http://dummy.com/page1.html"},
        {sourceUrl: "https://imgur.com/a123bgh1?grid"}
    ];
    let actual = new Parser().cleanWebPageUrls(sample);
    assert.deepEqual(actual, expected);
});

QUnit.test("setPagesToFetch", function (assert) {
    let urlsToFetch = [
        {sourceUrl: "http://dummy.com/page1.html"},
        {sourceUrl: "https://imgur.com/page2.html/"},
        {sourceUrl: "https://dummy.com/page3.html"},
    ];
    let state = new ParserState();
    state.setPagesToFetch(urlsToFetch);

    // convert next/previous links into array to make
    // verification easy
    let nextPrev = [];
    for(let page of state.webPages.values()) {
        for(let link of page.nextPrevChapters) {
            nextPrev.push(link);
        }
    }

    assert.deepEqual(nextPrev, [
        "imgur.com/page2.html",
        "dummy.com/page1.html",
        "dummy.com/page3.html",
        "imgur.com/page2.html"
    ]);
});

function makeEpubItemsToTestResolvingHyperlinks() {
    let epubItems = [];
    let dom = new DOMParser().parseFromString(
        "<head><title></title><base href=\"https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:Prologue_1\" /></head> " +
        "<body>" +
        "<sup class=\"footnote\"><a href=\"#fn-3352-1\" id=\"fnref-3352-1\">2</a></sup>" +     // already OK
        "<span class=\"mw-cite-backlink\"><a href=\"../Text/0010_Part_2.xhtml#cite_ref-2\"></a></span>" +  // already OK
        "<span id=\"homunculus\"><a href=\"/project/index.php?title=Fate/Zero:Translator%27s_Notes#homunculus\" title=\"Fate/Zero:Translator's Notes\">homunculus</a></span>" +  // to fix
        "<li id=\"fn-3352-1\"> I had the urge to type Truck-kun <span class=\"footnotereverse\"><a href=\"#fnref-3352-1\">↩</a></span>" + // already OK
        "</body>",
        "text/html"
    );
    epubItems.push(new ChapterEpubItem(
        {sourceUrl: "<https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:Prologue_1>", title: "Prolog", newArc: null },
        dom.body,
        0
    ));
    dom = new DOMParser().parseFromString(
        "<head><title></title><base href=\"https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:Translator%27s_Notes\" /></head> " +
        "<body>" +
        "<span class=\"mw-headline\" id=\"homunculus\">Homunculus</span>" +
        "<a href=\"/project/index.php?title=Fate/Zero:Prologue_1#homunculus\" title=\"Fate/Zero:Prologue 1\">Return to Text</a>" +     // to fix
        "<a href=\"/project/index.php?title=Fate/Zero:Prologue_1\" title=\"Fate/Zero:Prologue 1\">Return to Text</a>" +     // to fix
        "<a href=\"/project/index.php?title=Fate/Zero:AuthorNotes\" title=\"Fate/Zero:Prologue 1\">Return to Text</a>" +     // can't fix
        "</body>",
        "text/html"
    );
    epubItems.push(new ChapterEpubItem(
        {sourceUrl: "<https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:Translator%27s_Notes>", title: "Notes", newArc: null },
        dom.body,
        1
    ));
    return epubItems;
}

QUnit.test("sourceUrlToEpubItemUrl", function (assert) {
    let epubItems = makeEpubItemsToTestResolvingHyperlinks();
    let targets = new Parser().sourceUrlToEpubItemUrl(epubItems);
    assert.equal(targets.size, 2);
    assert.equal(targets.get("www.baka-tsuki.org/project/index.php?title=Fate/Zero:Prologue_1"), "../Text/0000_Prolog.xhtml");
    assert.equal(targets.get("www.baka-tsuki.org/project/index.php?title=Fate/Zero:Translator%27s_Notes"), "../Text/0001_Notes.xhtml");
});

QUnit.test("isUnresolvedHyperlink", function (assert) {
    let parser = new Parser();
    let link = document.createElement("a");
    link.href = "../Text/0010_Part_2.xhtml";
    assert.notOk(parser.isUnresolvedHyperlink(link));
    link.href = "#cite_ref-2";
    assert.notOk(parser.isUnresolvedHyperlink(link));
    link.href = "<https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:Translator%27s_Notes>";
    assert.ok(parser.isUnresolvedHyperlink(link));
});

QUnit.test("fixupHyperlinksInEpubItems", function (assert) {
    let epubItems = makeEpubItemsToTestResolvingHyperlinks();
    new Parser().fixupHyperlinksInEpubItems(epubItems);
    let links = epubItems[1].getHyperlinks();
    assert.equal(links.length, 3);
    assert.equal(links[0].getAttribute("href"), "../Text/0000_Prolog.xhtml#homunculus");
    assert.equal(links[1].getAttribute("href"), "../Text/0000_Prolog.xhtml");
    assert.equal(links[2].getAttribute("href"), "<https://www.baka-tsuki.org/project/index.php?title=Fate/Zero:AuthorNotes>");
    links = epubItems[0].getHyperlinks();
    assert.equal(links.length, 4);
    assert.equal(links[0].getAttribute("href"), "#fn-3352-1");
    assert.equal(links[1].getAttribute("href"), "../Text/0010_Part_2.xhtml#cite_ref-2");
    assert.equal(links[2].getAttribute("href"), "../Text/0001_Notes.xhtml#homunculus");
    assert.equal(links[3].getAttribute("href"), "#fnref-3352-1");
});

QUnit.test("extractTitle", function (assert) {
    let doc = new DOMParser().parseFromString(
        "<html><head><title> Title 1 </title><meta property=\"og:title\" content=\" Title 3 \" /></head> " +
        "<body>" +
        "<div><span class=\"threadtitle\"> Title 2 </span></div><div></div>" +
        "</body></html>",
        "text/html"
    );
    let actual = new NrvnqsrParser().extractTitle(doc);
    assert.equal(actual, "Title 2");
    doc.querySelector("meta").remove();
    actual = new NovelUniverseParser().extractTitle(doc);
    assert.equal(actual, "Title 1");
});

QUnit.test("addTitleToContent-h1Element", function (assert) {
    let doc = document.implementation.createHTMLDocument("");
    let webPage = { rawDom: doc };
    let parser = new Parser();
    parser.findChapterTitle = function() {
        let e = webPage.rawDom.createElement("h1");
        e.textContent = "Title1";
        return e;
    }
    parser.addTitleToContent(webPage, doc.body);
    assert.equal(doc.body.innerHTML, "<h1>Title1</h1>");
});

QUnit.test("addTitleToContent-text", function (assert) {
    let doc = document.implementation.createHTMLDocument("");
    let webPage = { rawDom: doc };
    let parser = new Parser();
    parser.findChapterTitle = () => "Title2";
    parser.addTitleToContent(webPage, doc.body);
    assert.equal(doc.body.innerHTML, "<h1>Title2</h1>");
 });

 QUnit.test("extractLanguage", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<html lang=\"cn\">"+
        "<head><title> Title 1 </title>"+
        "<meta property=\"og:locale\" content=\"fr\" /></head> " +
        "<body>" +
        "<h1></h1>" +
        "</body></html>",
        "text/html"
    );
    let parser = new Parser();
    assert.equal(parser.extractLanguage(dom), "fr");
    dom.querySelector("meta").remove();
    assert.equal(parser.extractLanguage(dom), "cn");
    dom.querySelector("html").removeAttribute("lang");
    assert.equal(parser.extractLanguage(dom), "en");
 });

  QUnit.test("replaceWpBlockSpacersWithHR", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<html lang=\"cn\">"+
        "<head><title> Title 1 </title>"+
        "<body>" +
        "<p>a</p>"+
        "<div style=\"height:20px\" aria-hidden=\"true\" class=\"wp-block-spacer\" data-original-height=\"20px\"></div>"+
        "<p>b</p>" +
        "<div style=\"height:20px\" aria-hidden=\"true\" class=\"wp-block-spacer\" data-original-height=\"20px\"></div>"+
        "</body></html>",
        "text/html"
    );
    let parser = new Parser();
    parser.replaceWpBlockSpacersWithHR(dom.body);
    let actual = dom.body.innerHTML;
    assert.equal(actual, "<p>a</p><hr><p>b</p><hr>");
 });

================================================
FILE: unitTest/UtestParserFactory.js
================================================

"use strict";

module("ParserFactory");

// Check get correct parser, based on URL
QUnit.test("basicFetchWorks", function (assert) {
    let parser = parserFactory.fetch("<http://archiveofourown.org/works/123456/chapters/9876543>");
    assert.ok(parser instanceof ArchiveOfOurOwnParser );
    parser = parserFactory.fetch("<https://www.fanfiction.net/s/1234567/1/WebToEpub>")
    assert.ok(parser instanceof FanFictionParser );
});

QUnit.test("unknownUrlReturnsDefaultParser", function (assert) {
    let dom = TestUtils.makeDomWithBody("<div></div>");
    let parser = parserFactory.fetch("<http://unknown.org/works/123456/chapters/9876543>", dom);
    assert.ok(parser instanceof DefaultParser);
});

QUnit.test("cantRegisterDuplicateUrls", function (assert) {
    let exceptionThrown = false;
    try {
        parserFactory.register("archiveofourown.org", () => new ArchiveOfOurOwnParser())
    }
    catch (error) {
        exceptionThrown = true;
    }
    assert.ok(exceptionThrown);
});

QUnit.test("fetch", function (assert) {
    let wordpressDom = TestUtils.makeDomWithBody("<h3 class='entry-title'></h3><div class='entry-content'></div>");
    let blogspotDom = TestUtils.makeDomWithBody("<div class='pagepost'><div class='cover'></div></div>");
    let blogspotUrl = "<http://dummy.blogspot.com/page1.html>";
    let unknownUrl = "<http://dummy.com/page1.html>";
    let unknownDom = TestUtils.makeDomWithBody("<div></div>");

    let actual = parserFactory.fetch(unknownUrl, unknownDom);
    assert.ok(actual instanceof DefaultParser);

    actual = parserFactory.fetch(blogspotUrl, wordpressDom);
    assert.ok(actual instanceof BlogspotParser);

    actual = parserFactory.fetch(unknownUrl, blogspotDom);
    assert.ok(actual instanceof BlogspotParser);
    
    actual = parserFactory.fetch(unknownUrl, wordpressDom);
    assert.ok(actual instanceof WordpressBaseParser);
});

QUnit.test("reregister", function (assert) {
    parserFactory.register("reregister.org", () => new ArchiveOfOurOwnParser())
    let parser = parserFactory.fetch("<http://reregister.org>");
    assert.ok(parser instanceof ArchiveOfOurOwnParser );
    parserFactory.reregister("reregister.org", () => new FanFictionParser())
    parser = parserFactory.fetch("<https://reregister.org/s/1234567/1/WebToEpub>")
    assert.ok(parser instanceof FanFictionParser );
});

QUnit.test("hostNameForParserSelection", function (assert) {
    let fn = ParserFactory.hostNameForParserSelection;
    assert.equal("zirusmusings.com", fn("<https://zirusmusings.com/ldm-ch84/>"));
    assert.equal("dailydallying.com", fn("<https://web.archive.org/web/20180729210849/http://dailydallying.com/nny/nny1/>"));
    assert.equal("fanfiction.net", fn("<https://www.fanfiction.net/s/1234567/1/WebToEpub>"));
});

test("assignParsersToPages", function (assert) {
    let done = assert.async();
    let webPages = [
        {sourceUrl: "https://zirusmusings.com/ldm-ch84/"},
        {sourceUrl: "https://zirusmusings.com/ldm-ch85/"},
        {sourceUrl: "https://royalroadl.com/bgm/"},
        {sourceUrl: "https://royalroadl.com/bgm2/"},
        {sourceUrl: "https://www.lightnovelbastion.com/release.php?p=546"},
        {sourceUrl: "https://lightnovelstranslations.com/nidome-no-yuusha-illustration/"},
    ];
    let parser = new ZirusMusingsParser();
    parser.state.chapterListUrl = "<https://zirusmusings.com/ldm/>";
    parserFactory.addParsersToPages(parser, webPages).then(
        function() {
            assert.equal(parser, webPages[0].parser);
            assert.equal(parser, webPages[1].parser);
            assert.ok(webPages[2].parser instanceof RoyalRoadParser);
            assert.equal(webPages[2].parser, webPages[3].parser);
            assert.ok(webPages[4].parser instanceof LightNovelBastionParser);
            assert.ok(webPages[5].parser instanceof LightNovelsTranslationsParser);
            done();
        }
    );
});

================================================
FILE: unitTest/UtestQidianParser.js
================================================

"use strict";

module("QidianParser");

QUnit.test("linkToChapter_notLocked", function (assert) {
    let dom = new DOMParser().parseFromString(QidianChatperLinkSample, "text/html");
    let link = dom.querySelector("a");
    let checkbox = dom.getElementById("removeChapterNumberCheckbox");
    document.body.appendChild(checkbox);
    let actual = QidianParser.linkToChapter(link);
    assert.equal(actual.title, "1: Young Zhao Feng");
    assert.equal(actual.isIncludeable, true);
    checkbox.remove();
});

QUnit.test("linkToChapter_Locked", function (assert) {
    let dom = new DOMParser().parseFromString(QidianChatperLinkSample, "text/html");
    let links = [...dom.querySelectorAll("a")];
    let checkbox = dom.getElementById("removeChapterNumberCheckbox");
    document.body.appendChild(checkbox);
    let actual = QidianParser.linkToChapter(links[1]);
    assert.equal(actual.title, "185: Worsen");
    assert.equal(actual.isIncludeable, false);
    checkbox.remove();
});

QUnit.test("extractTitle", function (assert) {
    let dom = new DOMParser().parseFromString(QidianChatperLinkSample, "text/html");
    let actual = new QidianParser().extractTitle(dom);
    assert.equal(actual, "King of Gods");
});

let QidianChatperLinkSample =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>King of Gods - Eastern Fantasy - Webnovel - Your Fictional Stories Hub</title>
    <base href="https://www.webnovel.com/book/9017100806001205/King-of-Gods" />
    <meta property="og:title" content="King of Gods">
</head>
<body>
<div class="page"><h1 class="pt4 pb4 oh mb4 auto_height">King of Gods <small>KOG</small></h2><div>
<input id="removeChapterNumberCheckbox" type="checkbox">
<ol>
<li class="g_col_6" data-report-eid="E10" data-bid="King of Gods" data-report-bid="9017100806001205" data-cid="30995441462068685" data-report-cid="30995441462068685">
    <a href="//www.webnovel.com/book/9017100806001205/30995441462068685/King-of-Gods/Young-Zhao-Feng-" class="c_000 db pr clearfix pt8 pb8 pr8 pl8">
        <i class="fl fs16 lh24 c_l _num mr4 tal">1</i>
        <div class="oh">
            <strong class="db mb8 fs16 lh24 c_l ell">Young Zhao Feng </strong>
            <small class="db fs12 lh16 c_s">Aug 29,2018</small>
        </div>
    </a>
</li>
<li class="g_col_6" data-report-eid="E10" data-bid="King of Gods" data-report-bid="9017100806001205" data-cid="30995442267375141" data-report-cid="30995442267375141">
    <a href="//www.webnovel.com/book/9017100806001205/30995442267375141/King-of-Gods/Worsen-" class="c_000 db pr clearfix pt8 pb8 pr8 pl8">
        <i class="fl fs16 lh24 c_l _num mr4 tal">185</i>
        <svg class="fr _icon ml16 mt4 c_s fs16"><use xlink:href="#i-lock"></use></svg>
        <div class="oh">
            <strong class="db mb8 fs16 lh24 c_l ell">Worsen </strong>
            <small class="db fs12 lh16 c_s">Aug 29,2018</small>
        </div>
    </a>
</li>
<ol>
</body>
</html>
`

================================================
FILE: unitTest/UtestQinxiaoshuoParser.js
================================================

"use strict";

module("QinxiaoshuoParser");

QUnit.test("isPossibleNextPage", function (assert) {
    let fetchedUrls = new Set();  
    let dom = new DOMParser().parseFromString("<a href=\"<http://qinxiaoshuo.com/read/5d7.html\">查看目录></a>", "text/html");
    let link = dom.querySelector("a");
    assert.notOk(QinxiaoshuoParser.isPossibleNextPage(link, fetchedUrls));
    link.href = "<http://qinxiaoshuo.com/read/5d7.html?xiaoshuo=3>";
    assert.ok(QinxiaoshuoParser.isPossibleNextPage(link, fetchedUrls));
    fetchedUrls.add(link.href);
    assert.notOk(QinxiaoshuoParser.isPossibleNextPage(link, fetchedUrls));
});

QUnit.test("urlOfNextPageOfChapter", function (assert) {
    let fetchedUrls = new Set();
    fetchedUrls.add("<http://qinxiaoshuo.com/read/0/1545/5d77d0dd56fec85e5b0ffd1a.html?xiaoshuo=1>");
    let dom = new DOMParser().parseFromString(NovelSpreadParserUtestQinxiaoshuoParserSample1, "text/html");
    let actual = QinxiaoshuoParser.urlOfNextPageOfChapter(dom, fetchedUrls);
    assert.equal(actual, "<http://qinxiaoshuo.com/read/0/1545/5d77d0dd56fec85e5b0ffd1a.html?xiaoshuo=2>");
    dom = new DOMParser().parseFromString(NovelSpreadParserUtestQinxiaoshuoParserSample2, "text/html");
    actual = QinxiaoshuoParser.urlOfNextPageOfChapter(dom, fetchedUrls);
    assert.equal(actual, null);
});

QUnit.test("copyContentNodes", function (assert) {
    let copyTo = new DOMParser().parseFromString(NovelSpreadParserUtestQinxiaoshuoParserSample1, "text/html");
    let copyFrom = new DOMParser().parseFromString(NovelSpreadParserUtestQinxiaoshuoParserSample2, "text/html");
    QinxiaoshuoParser.copyContentNodes(copyTo, copyFrom);
    let actual = new QinxiaoshuoParser().findContent(copyTo);
    assert.equal(actual.innerHTML, "line1<br>line2<div>line3<br>line4</div>");
});

let NovelSpreadParserUtestQinxiaoshuoParserSample1 =
`<!DOCTYPE html>
<html lang="en">
<head>
  <title>OVERLORD_第一章_亲小说网</title>
  <base href="http://qinxiaoshuo.com/read/0/1545/5d77d0dd56fec85e5b0ffd1a.html" />
</head>
<body>
    <div class="message">
      <div class="buttons">
        <a href="//qinxiaoshuo.com/book/OVERLORD">查看目录</a>
        <a id="change_btn" href="javascript:user_config.use_simplified = !user_config.use_simplified;change();">切換繁體</a>
      </div>
      <div id="chapter_content">line1<br>line2</div>
      <div class="buttons">
          <p><a rel="nofollow" href="?xiaoshuo=2">下一页</a></p>
          <p><a href="//qinxiaoshuo.com/read/0/1545/5d77d0dc56fec85e5b0ffd19.html">上一章</a></p>
      </div>
    </div>
</body>
</html>`

let NovelSpreadParserUtestQinxiaoshuoParserSample2 =
`<!DOCTYPE html>
<html lang="en">
<head>
  <title>OVERLORD_第一章_亲小说网</title>
  <base href="http://qinxiaoshuo.com/read/0/1545/5d77d0dd56fec85e5b0ffd1a.html?xiaoshuo=2" />
</head>
<body class="p-details">
  <div class="main-body" data-novel="115" data-collcetion=""></div>
    <div class="message">
      <div class="buttons">
        <a href="//qinxiaoshuo.com/book/OVERLORD">查看目录</a>
        <a id="change_btn" href="javascript:user_config.use_simplified = !user_config.use_simplified;change();">切換繁體</a>
      </div>
      <div id="chapter_content">line3<br>line4</div>
      <div class="buttons">
          <p><a rel="nofollow" href="?xiaoshuo=1">下一页</a></p>
          <p><a href="//qinxiaoshuo.com/read/0/1545/5d77d0dc56fec85e5b0ffd19.html">上一章</a></p>
      </div>
    </div>
</body>
</html>`

================================================
FILE: unitTest/UtestRanobesParser.js
================================================

"use strict";

module("RanobesParser");

QUnit.test("extractTocJson", function (assert) {
    let dom = new DOMParser().parseFromString(RanobesSample, "text/html");
    let json = RanobesParser.extractTocJson(dom);
    assert.equal(json.chapters.length, 2);
    assert.equal(json.pages_count, 9);
});

QUnit.test("extractTocPageUrls", function (assert) {
    let dom = new DOMParser().parseFromString(RanobesSample, "text/html");
    let urls = RanobesParser.extractTocPageUrls(dom, "<https://ranobes.net/chapters/1165550/>");
    assert.equal(urls.length, 9);
    assert.equal(urls[0], "<https://ranobes.net/chapters/1165550/page/1/>");
    assert.equal(urls[7], "<https://ranobes.net/chapters/1165550/page/8/>");
});

let RanobesSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Divine Path System | Chapters</title>
    <base href="https://ranobes.net/chapters/1165550/" />
</head>

<body>
    <script>window.__DATA__ = {"book_title":"Divine Path System","book_link":"https://ranobes.net/novels/1165550-divine-path-system.html","book_id":1165550,
    "chapters":[{"id":"1619080","title":"Chapter 210: The First Step","date":"2021-11-25 17:54:56","showDate":"28 minutes ago"},
    {"id":"1619079","title":"Chapter 209: An Old Friend","date":"2021-11-25 17:54:55","showDate":"28 minutes ago"}],
    "pages_count":9,"count_all":211,"cstart":1,"limit":25,"search":"","default":[],"searchTimeout":null}</script>
    <script src="/templates/Dark/reader/assets/js/vue/vue.prod.js"></script>
</body>
</html>`

================================================
FILE: unitTest/UtestReadComicOnlineParser.js
================================================

"use strict";

module("ReadComicOnlineParser");

QUnit.test("extractImageUrls", function (assert) {
  let dom = new DOMParser().parseFromString(ReadComicOnlineSamplePage, "text/html");
  let urls = ReadComicOnlineParser.extractImageUrls(dom);
  assert.equal(urls.length, 2);
  assert.equal(urls[0], "<https://2.bp.blogspot.com/gWgx9isFdn=s1600>");
  assert.equal(urls[1], "<https://2.bp.blogspot.com/NzFWtWE1yt=s1600>");
});

let ReadComicOnlineSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
<title>The Boys: Dear Becky</title>
<base href="https://readcomiconline.to/Comic/The-Boys-Dear-Becky/Issue-1" />
</head>
<body>
<script type="text/javascript">
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

var lstImages = new Array();

lstImages.push("<https://2.bp.blogspot.com/gWgx9isFdn=s1600>");

lstImages.push("<https://2.bp.blogspot.com/NzFWtWE1yt=s1600>");

</script>
<script type="text/javascript" src="/Scripts/kissreader.js"></script>
</body>
</html>
`

================================================
FILE: unitTest/UtestReadingList.js
================================================

"use strict";

module("ReadingList");

test("update", function (assert) {
    let chapterList = [
        {isIncludeable: false, sourceUrl: "http://novelupdates.com/seriesPage.html"},
        {isIncludeable: true, sourceUrl: "http://mySite.org/s1/chapter_001.html"},
        {isIncludeable: false, sourceUrl: "http://mySite.org/s1/chapter_002.html"},
    ];

    let toc1Url = "http://mySite.org/s1/toc.html";
    let rl = new ReadingList();
    rl.addEpub(toc1Url);
    rl.update(toc1Url, chapterList);
    let actual = rl.getEpub(toc1Url);
    assert.equal(actual, "http://mySite.org/s1/chapter_001.html");

    chapterList.push({isIncludeable: true, sourceUrl: "http://mySite.org/s1/chapter_003.html"})
    rl.update(toc1Url, chapterList);
    actual = rl.getEpub(toc1Url);
    assert.equal(actual, "http://mySite.org/s1/chapter_003.html");
});

test("deselectOldChapters", function (assert) {
    let history = [
        {isIncludeable: false, sourceUrl: "http://novelupdates.com/seriesPage.html"},
        {isIncludeable: true, sourceUrl: "http://mySite.org/s1/chapter_001.html"},
        {isIncludeable: false, sourceUrl: "http://mySite.org/s1/chapter_002.html"},
    ];
    let pages = [
        { sourceUrl: "http://novelupdates.com/seriesPage.html",  isIncludeable: false },
        { sourceUrl: "http://mySite.org/s1/chapter_001.html",  isIncludeable: true },
        { sourceUrl: "http://mySite.org/s1/chapter_002.html",  isIncludeable: true },
        { sourceUrl: "http://mySite.org/s1/chapter_003.html",  isIncludeable: true },
        { sourceUrl: "http://mySite.org/s1/chapter_004.html",  isIncludeable: false }
    ];

    let toc1Url = "http://mySite.org/s1/toc.html";
    let rl = new ReadingList();
    rl.addEpub(toc1Url);
    rl.update(toc1Url, history);
    rl.deselectOldChapters(toc1Url, pages);
    let actual = pages.map(p => p.isIncludeable);
    assert.deepEqual(actual, [false, false, true, true, false]);
});

test("toJson_whenEmpty", function (assert) {
    let readingList = new ReadingList();
    let actual = readingList.toJson();
    assert.equal(actual, "{\"epubs\":[]}");

    let clone = ReadingList.fromJson(actual);
    assert.deepEqual(readingList, clone);
});

test("toJson", function (assert) {
    let readingList = new ReadingList();
    let toc1Url = "<http://mySite.org/s1/toc.html>";
    readingList.addEpub(toc1Url);
    readingList.update(toc1Url, [
        { isIncludeable: false, sourceUrl: "http://novelupdates.com/seriesPage.html" },
        { isIncludeable: true, sourceUrl: "http://mySite.org/s1/chapter_001.html" },
        { isIncludeable: false, sourceUrl: "http://mySite.org/s1/chapter_002.html" },
    ]);

    let toc2Url = "http://mySite.org/s2/toc.html";
    readingList.addEpub(toc2Url);
    readingList.update(toc2Url, [
        { isIncludeable: true, sourceUrl: "http://novelupdates.com/series2Page.html" },
        { isIncludeable: true, sourceUrl: "http://mySite.org/s2/chapter_001.html" },
        { isIncludeable: true, sourceUrl: "http://mySite.org/s2/chapter_002.html" },
    ]);

    let actual = readingList.toJson();
    assert.equal(actual, "{\"epubs\":["+
        "{\"toc\":\"" + toc1Url + "\",\"lastUrl\":\"http://mySite.org/s1/chapter_001.html\"},"+
        "{\"toc\":\"" + toc2Url + "\",\"lastUrl\":\"http://mySite.org/s2/chapter_002.html\"}"+
        "]}"
    );

    let clone = ReadingList.fromJson(actual);
    assert.deepEqual(readingList, clone);
});

test("fromJson_oldVersion", function (assert) {
    let toc1Url = "<http://mySite.org/s1/toc.html>";
    let toc2Url = "<http://mySite.org/s2/toc.html>";
    let oldJson = "{\"epubs\":["+
        "{\"toc\":\"" + toc1Url + "\",\"history\":[\"http://novelupdates.com/seriesPage.html\",\"http://mySite.org/s1/chapter_001.html\",\"http://mySite.org/s1/chapter_002.html\"]},"+
        "{\"toc\":\"" + toc2Url + "\",\"history\":[\"http://novelupdates.com/series2Page.html\",\"http://mySite.org/s2/chapter_001.html\",\"http://mySite.org/s2/chapter_002.html\"]}"+
        "]}";

    let rl = ReadingList.fromJson(oldJson);
    assert.equal(rl.getEpub(toc1Url), "http://mySite.org/s1/chapter_002.html");
    assert.equal(rl.getEpub(toc2Url), "http://mySite.org/s2/chapter_002.html");
});

================================================
FILE: unitTest/UtestRoyalRoadParser.js
================================================

"use strict";

module("UtestRoyalRoadParser");

QUnit.test("removeOlderChapterNavJunk", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h1 id=\"e1\">&lt;--&gt;</h1>" +
        "<div id=\"d1\"><p id=\"p1\">1</p><p id=\"p2\">2</p><p id=\"p2\">&lt;--&gt;</p></div>" +
        "<h2 id=\"e2\">&lt;--&gt;</h2>"
    );
    assert.equal(dom.body.textContent, "<-->12<--><-->");
    RoyalRoadParser.removeOlderChapterNavJunk(dom.body);
    assert.equal(dom.querySelector("h1").textContent, "");
    assert.equal(dom.querySelector("div").textContent, "12");
    assert.equal(dom.body.textContent, "12");
});

QUnit.test("makeHiddenElementsVisible", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div style=\"display: none;\">Spoiler</div>"
    );
    let div = dom.querySelector("div");
    new RoyalRoadParser().makeHiddenElementsVisible(dom.body);
    assert.equal(div.outerHTML, "<div>Spoiler</div>");
});

================================================
FILE: unitTest/UtestShinsoriParser.js
================================================

"use strict";

module("ShinsoriParser");

QUnit.test("findTocUrls-LastPage", function (assert) {
    let dom = new DOMParser().parseFromString(
        ShinsoriToCSampleLastPage, "text/html");
    let urls = ShinsoriParser.getUrlsOfTocPages(dom);
    assert.equal(urls.length, 1);
    assert.equal(urls[0], "<https://www.shinsori.com/avoid-the-death-route/?lcp_page0=2#lcp_instance_0>");
});

let ShinsoriToCSampleLastPage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>Avoid the Death Route! | Shinsori Translations</title>
    <base href="https://www.shinsori.com/avoid-the-death-route/" />
</head>
<body data-rsssl=1 id="tie-body" class="page-template-default page page-id-213 boxed-layout wrapper-has-shadow block-head-1 magazine1 is-lazyload is-thumb-overlay-disabled is-desktop is-header-layout-2 has-builder">
<ul class="lcp_paginator">
<li class="lcp_currentpage">1</li>
<li><a href="https://www.shinsori.com/avoid-the-death-route/?lcp_page0=2#lcp_instance_0" title="2">2</a></li>
<li><a href="https://www.shinsori.com/avoid-the-death-route/?lcp_page0=2#lcp_instance_0" title="2" class="lcp_nextlink">&gt;&gt;</a></li>
</ul>
</body>
</html>
`

================================================
FILE: unitTest/UtestShmtranslationsParser.js
================================================

"use strict";

module("ShmtranslationsParser");

QUnit.test("findContent", function (assert) {
    let dom = new DOMParser().parseFromString(
        ShmtranslationsSampleChapter228, "text/html");
    let parser = new ShmtranslationsParser();
    let content = parser.findContent(dom);
    assert.equal(content.textContent.trim(), "Capitation tax, land tax, and port tax.");
});

let ShmtranslationsSampleChapter228 =
`<!DOCTYPE html>
<html lang="en-US">
<head>
    <title>Chapter 228 – Tax and Trouble &#8211; SHMTranslations</title>
    <base href="https://shmtranslations.com/2019/10/22/chapter-228-tax-and-trouble/" />
</head>

<body>
    <article>
        <footer>
            <a href="https://shmtranslations.com/category/isekai-nonbiri-nouka/"><li class="cat mr-2 mb-4"> Isekai Nonbiri Nouka</li></a>
        </footer>
        <p><span style="color: #ffffff;">Please show your support to the translator by reading at SHMTranslations dot com</span></p>
        <p><span style="color: #ffffff;">Read at SHMTranslations(dot)com</span></p>
        <p>Capitation tax, land tax, and port tax.</p>
        <div class="awac-wrapper">Loading</div>
    </article>
</body>
</html>`

================================================
FILE: unitTest/UtestStocxParser.js
================================================

"use strict";

module("StocxParser");

test("isHexChar", function (assert) {
    assert.ok(StocxParser.isHexChar("0"));
    assert.notOk(StocxParser.isHexChar("o"));
    assert.ok(StocxParser.isHexChar("A"));
    assert.ok(StocxParser.isHexChar("f"));
    assert.notOk(StocxParser.isHexChar("G"));
});

test("isEncodeddByte", function (assert) {
    let raw = "清透的七彩碧玺触手温凉，她本已变得面无表情的脸上再次%e9%9c%b2%e5%87%ba浅笑。";
    let actual = StocxParser.isEncodeddByte(raw, 26);
    assert.equal(actual, true);
    assert.equal(StocxParser.isEncodeddByte(raw, 47), false);
});

test("fixMangledText", function (assert) {
    let mangled = "清透的七彩碧玺触手温凉，她本已变得面无表情的脸上再次%e9%9c%b2%e5%87%ba浅笑。";
    let actual = StocxParser.fixMangledText(mangled);
    assert.equal(actual, "清透的七彩碧玺触手温凉，她本已变得面无表情的脸上再次露出浅笑。");
});

test("customRawDomToContentStep", function (assert) {
    let dom = new DOMParser().parseFromString(StocxChapterSample, "text/html");
    let parser = new StocxParser();
    let content = dom.querySelector("#BookContent")
    let actual = parser.customRawDomToContentStep(null, content);
    assert.notOk(content.textContent.includes("%"));
});

let StocxChapterSample =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>《醉玲珑》作者：十四夜_第2頁_全文在線閱讀_思兔</title>
    <base href="https://www.sto.cx/book-40390-2.html" />
</head>

<body>
    <h1>《醉玲珑》作者：十四夜_第2頁</h1>
    <div id="BookContent">
        色？<br /><br />
        那么她就补充给他：从左边数第四棵，晚春细雨飘过以后的颜色。<br /><br />
        宁文清吃了一惊，%e8%84%b1口道：“你是谁？”不觉中紧紧将%e5%94%87角一抿，水里倒影却丹%e5%94%87微启：“我叫凤卿尘，可能……从此以后你才是凤卿尘了。”<br />
        清透的七彩碧玺触手温凉，她本已变得面无表情的脸上再次%e9%9c%b2%e5%87%ba浅笑。<br /><br />
    </div>
</body>
</html>`

================================================
FILE: unitTest/UtestTapreadParser.js
================================================

"use strict";

module("TapreadParser");

QUnit.test("jsonToHtml", function (assert) {
    let dom = TapreadParser.jsonToHtml(TapreadSampleChapterJson);
    let content = Parser.findConstrutedContent(dom);
    assert.equal(content.innerHTML, "<h1>Chapter 1-Marry Me</h1><p>\"Dear, marry me!\"  </p><p>Fastening his buttons, </p>");
});

let TapreadSampleChapterJson =
{
    "code":200,
    "msg":"success",
    "message":"success",
    "result":{
        "chapterNo":1,
        "price_unit":0,
        "level":0,
        "chapterId":770,
        "chapterName":"Chapter 1-Marry Me",
        "nextChapterId":790,
        "type":0,
        "content":"<p>&quot;Dear, marry me!&quot;  </p><p>Fastening his buttons, </p>",
        "bookId":76,
        "preChapterId":0
    }
}

================================================
FILE: unitTest/UtestTranslationChickenParser.js
================================================

"use strict";

module("TranslationChicken");

test("findContent", function (assert) {
    let dom = new DOMParser().parseFromString(TranslationChickenSample1, "text/html");
    let parser = new TranslationChickenParser();
    let actual = parser.findContent(dom);
    assert.equal(actual.children[0].className, "featured-media");

    // check sill OK if called second time
    actual = parser.findContent(dom);
    assert.equal(actual.children[0].className, "featured-media");
});

let TranslationChickenSample1 =
`<!DOCTYPE html>
<head>
    <title>Re:Zero Arc 3 Interlude II [Let’s Eat] (1/2) – START READING HERE – TranslationChicken</title>
    <base href="https://translationchicken.com/2016/09/12/rezero-arc-3-interlude-ii-lets-eat-12/" />
</head>
<body>
<div class="featured-media">
    <img width="1024" height="576" src="https://translationchicken.files.wordpress.com/2016/09/arc3interludeii.jpg?w=1024" class="attachment-baskerville-2-post-image size-baskerville-2-post-image wp-post-image">
</div>
<div class="post-content clear">
    <p style="text-align:center;"><em><strong>**********Note from Translation Chicken**********</strong></em></p>
</div>
</body>
</html>
`

================================================
FILE: unitTest/UtestTruyenfullParser.js
================================================

"use strict";

module("TruyenfullParser");

QUnit.test("getUrlsOfTocPages", function (assert) {
    let dom = new DOMParser().parseFromString(TruyenfullToCSamplePage, "text/html");
    let urls = TruyenfullParser.getUrlsOfTocPages(dom);
    assert.equal(urls.length, 17);
    assert.equal(urls[0], "<https://truyenfull.vn/he-thong-di-lac-tu-tien-ki/trang-2/>");
    assert.equal(urls[16], "<https://truyenfull.vn/he-thong-di-lac-tu-tien-ki/trang-18/>");
});

let TruyenfullToCSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
<title>Truyện Hệ Thống Đi Lạc Tu Tiên Kí</title>
<base href="https://truyenfull.vn/he-thong-di-lac-tu-tien-ki/" />
</head>
<body>
<input id='truyen-id' type='hidden' value='17372'><input id='total-page' type='hidden' value='18'>
</body>
</html>
`

================================================
FILE: unitTest/UtestTruyenyyParser.js
================================================

"use strict";

module("TruyenyyParser");

QUnit.test("extractPartialChapterList", function (assert) {
    let dom = new DOMParser().parseFromString(
        TruyenyyToCSamplePage, "text/html");
    let chapters = TruyenyyParser.extractPartialChapterList(dom);
    assert.deepEqual(chapters, [
        {newArc: null, title: "Chương 1: Đá Vận Khí", sourceUrl: "https://truyenyy.com/truyen/sieu-cap-gien-ban-dich/chuong-1.html"},
        {newArc: null, title: "Chương 2: Thế giới thần kỳ", sourceUrl: "https://truyenyy.com/truyen/sieu-cap-gien-ban-dich/chuong-2.html"}
    ]);
});

QUnit.test("getUrlsOfTocPages", function (assert) {
    let dom = new DOMParser().parseFromString(
        TruyenyyToCSamplePage, "text/html");
    let tocUrls = TruyenyyParser.getUrlsOfTocPages(dom);
    assert.equal(tocUrls.length, 14);
    assert.equal(tocUrls[0], "<https://truyenyy.com/truyen/sieu-cap-gien-ban-dich/?p=2>");
    assert.equal(tocUrls[13], "<https://truyenyy.com/truyen/sieu-cap-gien-ban-dich/?p=15>");
});

let TruyenyyToCSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
<title>Danh Sách Chương - Trang 1 - Siêu Cấp Gen (Bản Dịch)</title>
<base href="https://truyenyy.com/truyen/sieu-cap-gien-ban-dich/" />
</head>
<body>

<ul class="pagination">
<li class="page-item mt-2">
    <div class="custom-control custom-checkbox">
        <input type="checkbox" class="custom-control-input" id="reverseListCheckbox2">
        <label class="custom-control-label" for="reverseListCheckbox2">Chương mới lên trước</label>
    </div>
</li>
<li class="flex-primary"></li>
<li class="page-item disabled">
    <a class="page-link" href="#" tabindex="-1">
        <span aria-hidden="true"><i class="iconfont icon-left"></i></span>
    </a>
</li>
<li class="page-item active">
    <span class="page-link">1 <span class="sr-only">(hiện tại)</span></span>
</li>
<li class="page-item"><a class="page-link" href="?p=2">2</a></li>
<li class="page-item"><a class="page-link" href="?p=3">3</a></li>
<li class="page-item"><a class="page-link" href="?p=4">4</a></li>
<li class="page-item"><a class="page-link" href="?p=5">5</a></li>
<li class="page-item"><a class="page-link" href="?p=6">6</a></li>
<li class="page-item"><a class="page-link" href="?p=7">7</a></li>
<li class="page-item"><a class="page-link" href="?p=8">8</a></li>
<li class="page-item"><a class="page-link" href="?p=9">9</a></li>
<li class="page-item"><a class="page-link" href="?p=10">10</a></li>
<li class="page-item disabled"><a class="page-link" href="#">...</a></li>
<li class="page-item"><a class="page-link" href="?p=14">14</a></li>
<li class="page-item"><a class="page-link" href="?p=15">15</a></li>
<li class="page-item">
    <a class="page-link" href="?p=2" aria-label="Trang Sau">
        <span aria-hidden="true"><i class="iconfont icon-right"></i></span>
        <span class="sr-only">Trang Sau</span>
    </a>
</li>
</ul>

<table class="table table-dark my-0">
<tr>
<td>
    <a href="/truyen/sieu-cap-gien-ban-dich/chuong-1.html">
        Chương 1
    </a>
</td>
<td><a href="/truyen/sieu-cap-gien-ban-dich/chuong-1.html" class="table-chap-title">Đá Vận Khí</a></td>
</tr>
<tr>
<td>
    <a href="/truyen/sieu-cap-gien-ban-dich/chuong-2.html">
        Chương 2
    </a>
</td>
<td><a href="/truyen/sieu-cap-gien-ban-dich/chuong-2.html" class="table-chap-title">Thế giới thần kỳ</a></td>
</tr>
</table>
</body>
</html>
`

================================================
FILE: unitTest/UtestUserPreferences.js
================================================

"use strict";

module("UserPreferences");

test("checkNameExists", function (assert) {
    window.localStorage.clear();
    let up1 = new UserPreferences();

    try {
        up1.removeDuplicateImages.value;
    } catch (e) {
        assert.fail("name that exists should not throw");
    }

    // name that does not exist should throw
    let didThrow = false;
    try {
        up1.doesNotExist.value;
    } catch (e) {
        didThrow = true;
    }
    assert.equal(didThrow, true);
});

test("ctor", function (assert) {
    let up1 = new UserPreferences();
    assert.ok(up1.removeDuplicateImages instanceof BoolUserPreference);
    assert.ok(up1.styleSheet instanceof StringUserPreference);
});

test("writeToLocalStorage", function (assert) {
    window.localStorage.clear();
    let up1 = new UserPreferences();
    assert.equal(up1.removeDuplicateImages.value, false);
    assert.equal(up1.includeImageSourceUrl.value, true);

    up1.removeDuplicateImages.value = true;
    up1.includeImageSourceUrl.value = false;
    up1.writeToLocalStorage();

    up1 = new UserPreferences();
    assert.equal(up1.removeDuplicateImages.value, false);
    assert.equal(up1.includeImageSourceUrl.value, true);

    let up2 = UserPreferences.readFromLocalStorage();
    assert.equal(up2.removeDuplicateImages.value, true);
    assert.equal(up2.includeImageSourceUrl.value, false);
});

================================================
FILE: unitTest/UtestUtil.js
================================================

"use strict";

module("Util");

function dummyWuxiaDoc() {
    let dom = TestUtils.makeDomWithBody(
        "<p>" +
            "<a href=\"http://www.wuxiaworld.com/wmw-index/wmw-chapter-1/\">Previous Chapter</a>" +
            "<span style=\"float: right\"><a href=\"http://www.wuxiaworld.com/wmw-index/wmw-chapter-3\">Next Chapter</a></span>" +
        "</p>" +
        "<sup class='footnote'><a href='#fn-63064-1' id='fnref-63064-1' onclick='return fdfootnote_show(63064)'>1</a></sup>" +
        "<p>" +
            "<a href=\"http://www.wuxiaworld.com/wmw-index/wmw-chapter-1\">Previous Chapter</a>" +
            "<span style=\"float: right\"><a href=\"http://www.wuxiaworld.com/wmw-index/wmw-chapter-3/\">Next Chapter</a></span>" +
        "</p>" +
        "<ol>" +
            "<li id=\"fn-63064-1\" tabindex=\"-1\"> Literal Translation pretty much her wannabe escorts/protectors <span class=\"footnotereverse\">" +
            "<a href=\"#fnref-63064-1\"><img draggable=\"false\" class=\"emoji\" alt=\"...\" src=\"https://s.w.org/images/core/emoji/72x72/21a9.png\"></a></span></li>" +
        "</ol>" +
        // this bit is malformed HTML
        "<hr>Previous Chapter <span style=\"float: right;\"><a title=\"7 Killers - Chapter 2\" href=\"<http://www.wuxiaworld.com/wmw-index/wmw-chapter-3\">Next> Chapter</a> </span></p>"
    );

    // Hack, if I don't do this, on Chrome the href value for <a> tags with just a hash is blank.
    util.setBaseTag("http://wuxiaworld.com/wmw-index.html", dom);

    return dom;
}

test("removeEmptyDivElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div><h1>H1</h1></div>" +
        "<div><div></div></div>" +
        "<div>    \n\n\n</div>" +
        "<div><img src=\"http://dumy.com/img.jpg\"></div>"
    );
    let content = dom.body;
    util.removeEmptyDivElements(content);

    assert.equal(content.innerHTML, "<div><h1>H1</h1></div><div><img src=\"http://dumy.com/img.jpg\"></div>");
});

test("removeScriptableElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div><h1>H1</h1></div>" +
        "<iframe title=\"VisualDNA Analytics\" width=\"0\" height=\"0\" aria-hidden=\"true\" src=\"./Wikia_files/saved_resource.html\" style=\"display: none;\"></iframe>" +
        "<script src=\"./expansion_embed.js\"></script>"+
        "<div>    \n\n\n</div>"
    );
    let content = dom.body.cloneNode(true);
    util.removeScriptableElements(content);

    assert.equal(content.innerHTML, "<div><h1>H1</h1></div><div>    \n\n\n</div>");
});

test("removeMicrosoftWordCrapElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div><h1>H1</h1></div>" +
        "<p>text<o:p></o:p></p>" +
        "<div>    \n\n\n</div>"
    );
    let content = dom.body.cloneNode(true);
    util.removeMicrosoftWordCrapElements(content);

    assert.equal(content.innerHTML, "<div><h1>H1</h1></div><p>text</p><div>    \n\n\n</div>");
});

test("prepForConvertToXhtml", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<p>Normal <u id=\"test1\">underline <i>italic</i></u></p>" +
        "<center>X   X</center>"
    );
    let content = dom.body.cloneNode(true);
    util.prepForConvertToXhtml(content);

    // Firefox and Chrome put span's id attribute in different positions.
    assert.equal(content.innerHTML.replace(" id=\"test1\"", ""),
        "<p>Normal <span style=\"text-decoration: underline;\">underline <i>italic</i></span></p>" +
        "<p style=\"text-align: center;\">X   X</p>"
    );
    let span = content.querySelector("span");
    assert.equal(span.id, "test1");
});

test("makeHyperlinksRelative", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h2><span id=\"Life.0\">Life.0</span></h2>" +
        "<sup id=\"cite_ref-1\" class=\"reference\">" +
            "<a href=\"<https://www.baka-tsuki.org/project/test:Volume_1#cite_note-1\">[1>]</a>" +
        "</sup>" +
        "<sup id=\"cite_ref-2\" class=\"reference\">" +
            "<a href=\"<https://www.baka-tsuki.org/project/test:Volume_1#cite_note-2\">[1>]</a>" +
        "</sup>" +
        "<ol>" +
        "<li id=\"cite_note-1\">" +
            "<a href=\"https://www.baka-tsuki.org/project/test:Volume_1#cite_ref-1\"></a>" +
        "</li>" +
        "<li id=\"cite_note-3\">" +
            "<a href=\"https://www.baka-tsuki.org/project/test:Volume_1#cite_ref-3\"></a>" +
        "</li>" +
        "</ol>"
    );

    util.setBaseTag("https://www.baka-tsuki.org/project/test:Volume_1", dom);
    let content = dom.body.cloneNode(true);
    util.makeHyperlinksRelative("https://www.baka-tsuki.org/project/test:Volume_1", content);

    assert.equal(content.innerHTML,
        "<h2><span id=\"Life.0\">Life.0</span></h2>" +
        "<sup id=\"cite_ref-1\" class=\"reference\">" +
            "<a href=\"#cite_note-1\">[1]</a>" +
        "</sup>" +
        "<sup id=\"cite_ref-2\" class=\"reference\">" +
            "<a href=\"#cite_note-2\">[1]</a>" +
        "</sup>" +
        "<ol>" +
        "<li id=\"cite_note-1\">" +
            "<a href=\"#cite_ref-1\"></a>" +
        "</li>" +
        "<li id=\"cite_note-3\">" +
            "<a href=\"#cite_ref-3\"></a>" +
        "</li>" +
        "</ol>"
    );
});

test("removeUnusedHeadingLevels", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h2>h2</h2>" +
        "<h5>h5</h5>" +
        "<h6>h6</h6>" +
        "<h2>h2</h2>"
    );
    util.removeUnusedHeadingLevels(dom.body);

    assert.equal(dom.body.innerHTML, "<h1>h2</h1><h2>h5</h2><h3>h6</h3><h1>h2</h1>");

    // headings are already in order - no change
    dom = TestUtils.makeDomWithBody(
        "<h1>h1</h1>" +
        "<h2>h2</h2>" +
        "<h3>h3</h3>"
    );
    util.removeUnusedHeadingLevels(dom.body);
    assert.equal(dom.body.innerHTML, "<h1>h1</h1><h2>h2</h2><h3>h3</h3>");

    // no headings
    dom = TestUtils.makeDomWithBody(
        "<div>h1</div>" +
        "<p>h2</p>"
    );
    util.removeUnusedHeadingLevels(dom.body);
    assert.equal(dom.body.innerHTML, "<div>h1</div><p>h2</p>");
});

test("fixBlockTagsNestedInInlineTags", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<u><div><p><b>test1</b><a href=\"http://dummy.com\"><img src=\"http://dummy.com\"></a></p></div></u>" +
        "<u><b><div><p>test2</p></div></b></u>" +
        "<s><h2><span>test3<a href=\"http://dummy2.com\">dummy2</a></span></h2><p>3</p><p>4</p></s>" +
        "<i><table><tbody><tr><th>test4Head</th></tr><tr><td>test4Data</td></tr></tbody></table><p>6</p><p>7</p></i>"
    );
    util.fixBlockTagsNestedInInlineTags(dom.body);

    assert.equal(dom.body.innerHTML,
        "<div><p><b>test1</b><a href=\"http://dummy.com\"><img src=\"http://dummy.com\"></a></p></div>" +
        "<div><p>test2</p></div>" +
        "<h2><span>test3<a href=\"http://dummy2.com\">dummy2</a></span></h2><p>3</p><p>4</p>" +
        "<table><tbody><tr><th>test4Head</th></tr><tr><td>test4Data</td></tr></tbody></table><p>6</p><p>7</p>"
    );
});

test("extractHostName", function (assert) {
    let hostName = util.extractHostName(util.XMLNS);
    assert.equal(hostName, "www.w3.org");
});

test("removeTrailingWhiteSpace", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div id=\"content\">" +
        "Some text <br />\n" +
        "<br />\n" +
        "<hr />\n" +
        "<br />\n" +
         "</div>\n"
    );

    let content = dom.getElementById("content");
    util.removeTrailingWhiteSpace(content);
    assert.equal(content.innerHTML, "Some text ");
});

test("removeLeadingWhiteSpace", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div id=\"content\">" +
        "\n  \n" +
        "<br />\n" +
        "<p></p>\n" +
        "<hr />\n" +
         "<p>Chapter 1</p>" +
         "</div>"
    );

    let content = dom.getElementById("content");
    util.removeLeadingWhiteSpace(content);
    assert.equal(content.innerHTML, "<p>Chapter 1</p>");
});

function dummyWuxiaDocWithArcNames() {
    return TestUtils.makeDomWithBody(
        "<div itemprop=\"articleBody\">" +
        "<div id=\"target-id8123\" class=\"collapseomatic_content \" style=\"display: none;\">" +
        "<p><strong>Book 1 Patriarch Reliance</strong><br/>" +
            "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-1-chapter-1/\">Chapter> 1: Scholar Meng Hao<br/></a>" +
            "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-1-chapter-2/\">Chapter> 2: The Reliance Sect</a><br/>" +
            "<a href=\"<http://www.wuxiaworld.com/wmw-index/wmw-chapter-17/\">><br></a>" +
        "</div>" +
        "<div id=\"target-id4879\" class=\"collapseomatic_content \" style=\"display: none;\">" +
        "<p><strong>Book 2 Cutting Into the Southern Domain</strong><br/>" +
            "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-2-chapter-96/\">Chapter> 96: Demonic Jade in a Mountain Valley</a><br/>" +
            "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-2-chapter-97/\">Chapter> 97: Cultivation Breakthrough in a Mountain Valley</a><br/>" +
        "</div>" +
        "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-6-chapter-801/\">Chapter> 801: We Will Meet Again!</a><br/>" +
        "<a href=\"<http://www.wuxiaworld.com/issth-index/issth-book-6-chapter-802/\">Chapter> 802: Immortal Ancient Dao Medallion!</a><br/>" +
        "</div>"
    );
}

test("hyperlinksToChapterList", function (assert) {
    let dom = dummyWuxiaDocWithArcNames();
    let chapters = util.hyperlinksToChapterList(dom);
    assert.equal(chapters.length, 6);
});

test("hyperlinksToChapterListEmptyElement", function (assert) {
    let chapters = util.hyperlinksToChapterList(null);
    assert.deepEqual(chapters, []);
});

test("removeTrailingSlash", function (assert) {
    let expected = "<http://www.wuxiaworld.com/wmw-index/wmw-chapter-2>";

    assert.equal(util.removeTrailingSlash(expected), expected);
    assert.equal(util.removeTrailingSlash(expected + "/"), expected);
});

test("normalizeUrlForCompare", function (assert) {
    let expected = "www.wuxiaworld.com/wmw-index/wmw-chapter-2";

    assert.equal(util.normalizeUrlForCompare(expected), expected);
    assert.equal(util.normalizeUrlForCompare("http://" + expected), expected);
    assert.equal(util.normalizeUrlForCompare("http://" + expected +"/"), expected);
    assert.equal(util.normalizeUrlForCompare("https://" + expected), expected);
    assert.equal(util.normalizeUrlForCompare("https://" + expected +"/"), expected);
    assert.equal(util.normalizeUrlForCompare(expected + "#title"), expected);
});

test("removeEventHandlers", function (assert) {
    let dom = dummyWuxiaDoc();
    let body = util.removeEventHandlers(dom.body);
    let link = dom.getElementById("fnref-63064-1");
    assert.equal(link.outerHTML, "<a href=\"#fn-63064-1\" id=\"fnref-63064-1\">1</a>");
});

QUnit.test("removeHeightAndWidthStyle", function (assert) {
    let html = "<p style=\"width:100%;height:100%;color:rgb(153, 153, 153);\"></p>";
    let doc = new DOMParser().parseFromString(html, "text/html");
    let p = doc.getElementsByTagName["p"](0);
    util.removeHeightAndWidthStyle(p);
    assert.equal(p.outerHTML, "<p style=\"color: rgb(153, 153, 153);\"></p>");
    html = "<div width=\"1px\" height=\"1px\" style=\"color:rgb(153, 153, 153);\"></div>";
    doc = new DOMParser().parseFromString(html, "text/html");
    p = doc.getElementsByTagName["div"](0);
    util.removeHeightAndWidthStyle(p);
    assert.equal(p.outerHTML, "<div style=\"color:rgb(153, 153, 153);\"></div>");
});

QUnit.test("isElementWhiteSpace", function (assert) {
    let doc = TestUtils.makeDomWithBody("<!-- c -->text<div></div>");
    let body = doc.body;
    assert.ok(util.isElementWhiteSpace(body.childNodes[0]));
    assert.ok(!util.isElementWhiteSpace(body.childNodes[1]));
    assert.ok(util.isElementWhiteSpace(body.childNodes[2]));
});

test("findPrimaryStyleSettings", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div style=\"font-size: 10.0pt;\"><p>1234</p></div>" +
        "<div style=\"color:#999999\">0<p>1234</p>5678<p style=\"color:#111111\">1</p></div>"
    );

    let styleProperties = ["color", "fontSize"];
    let acutal = util.findPrimaryStyleSettings(dom.body, styleProperties);
    assert.equal(acutal[0], "rgb(153, 153, 153)");
    assert.equal(acutal[1], undefined);
});

test("removeStyleValue", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div style=\"font-size: 10.0pt;\"><p>1234</p></div>" +
        "<div style=\"color:#999999\">0<p>1234</p>5678<p style=\"color:#111111\">1</p></div>"
    );

    util.removeStyleValue(dom.body, "fontSize", "10pt");
    assert.equal(dom.body.innerHTML,
            "<div><p>1234</p></div>" +
            "<div style=\"color:#999999\">0<p>1234</p>5678<p style=\"color:#111111\">1</p></div>" 
    );
    util.removeStyleValue(dom.body, "color", "rgb(17, 17, 17)");
    assert.equal(dom.body.innerHTML,
            "<div><p>1234</p></div>" +
            "<div style=\"color:#999999\">0<p>1234</p>5678<p>1</p></div>"
    );
});

test("createComment", function (assert) {
    let dom = TestUtils.makeDomWithBody("");
    let actual = util.createComment(dom, "<http://2.bp.blogspot.com/--pvHycyNQB0/VLJkOS9q57I/AAAAAAAAA-4/pyI5zkbZNsA/s1600/Haken.no.Kouki.Altina.full.1568363.jpg>");
    assert.equal(actual.nodeValue, "  <http://2.bp.blogspot.com/%2D%2DpvHycyNQB0/VLJkOS9q57I/AAAAAAAAA-4/pyI5zkbZNsA/s1600/Haken.no.Kouki.Altina.full.1568363.jpg>  ");

    actual = util.createComment(dom, "http://2.bp.blogspot.com/-.--.---.----.-----");
    assert.equal(actual.nodeValue, "  http://2.bp.blogspot.com/-.%2D%2D.%2D%2D-.%2D%2D%2D%2D.%2D%2D%2D%2D-  ");
});

test("findIndexOfClosingQuote", function (assert) {
    let test = function(s, startIndex) {
        let end = util.findIndexOfClosingQuote(s, startIndex);
        return s.substring(startIndex, end + 1)
    }

    assert.equal(test("\"simple\"aa", 0), "\"simple\"");
    assert.equal(test("a\"\\\"nested\\\"\"bb", 1), "\"\\\"nested\\\"\"");
});

test("findIndexOfClosingBracket", function (assert) {
    let testString = "a{\album_images\":{\"count\":21,\"images\":[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]}";
    let test = function(startPattern) {
        let startIndex = testString.indexOf(startPattern) + startPattern.length;
        let end = util.findIndexOfClosingBracket(testString, startIndex);
        let substring = testString.substring(startIndex, end + 1);
        return substring;
    }

    assert.equal(test("images\":[", 0), "{\"hash\":\"zNuo7hV\",\"ext\":\".png\"}");
    assert.equal(test("\"images\":", 0), "[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]");
    assert.equal(test("_images\":", 0), "{\"count\":21,\"images\":[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]}");
    
    // unbalanced case
    assert.equal(util.findIndexOfClosingBracket(testString, 0), -1);
});

test("locateAndExtractJson", function (assert) {
    let testString = "a{\album_images\":{\"count\":21,\"images\":[{\"hash\":\"zNuo7hV\",\"ext\":\".png\"},{\"hash\":\"bi7LaVD\",\"ext\":\".png\"}]}";
    let test = function(startPattern) {
        return util.locateAndExtractJson(testString, startPattern);
    }

    assert.deepEqual(test("images\":[", 0), {hash: "zNuo7hV", ext: ".png"});
    assert.deepEqual(test("\"images\":", 0), [{hash: "zNuo7hV", ext: ".png"},{hash:"bi7LaVD",ext:".png"}]);
    assert.deepEqual(test("_images\":", 0), {count:21, images: [{hash:"zNuo7hV",ext:".png"},{hash:"bi7LaVD",ext:".png"}]});
    
    // unbalanced case
    assert.equal(test("a", 0), null);

    // no brackets
    assert.equal(util.locateAndExtractJson("testString", "test"), null);

    // empty string
    assert.equal(util.locateAndExtractJson("", ""), null);
});

test("isXhtmlInvalid", function (assert) {
    let invalidXhtml = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" +
        "<html xmlns=\"<http://www.w3.org/1999/xhtml\">>" +
        "<head><title></title></head>" +
        "<body><h1></h1>the<p></p>" +
        "<this one,=\"\"></body></html>";

    let actual = util.isXhtmlInvalid(invalidXhtml);
    assert.ok(actual !== null);

    let validXhtml = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" +
        "<html xmlns=\"http://www.w3.org/1999/xhtml\">" +
        "<head><title></title></head>" +
        "<body><h1></h1>the<p></p>" +
        "</body></html>";
    actual = util.isXhtmlInvalid(validXhtml);
    assert.equal(actual, null);
});

QUnit.test("extractFilename", function (assert) {
    let hyperlink = document.createElement("a");
    let actual = util.extractFilename(hyperlink);
    assert.equal(actual, "");

    hyperlink.href = "http://dummy.com/K4CZyyP.jpg";
    actual = util.extractFilename(hyperlink);
    assert.equal(actual, "K4CZyyP.jpg");
    
    hyperlink.href = "http://dummy.com/K4CZyyP.png/";
    actual = util.extractFilename(hyperlink);
    assert.equal(actual, "K4CZyyP.png");
    
    hyperlink.href = "http://dummy.com/K4CZyyP.jpeg?src=dummy.txt";
    actual = util.extractFilename(hyperlink);
    assert.equal(actual, "K4CZyyP.jpeg");
    
    hyperlink.href = "http://dummy.com/folder/K4CZyyP.gif?src=dummy.txt";
    actual = util.extractFilename(hyperlink);
    assert.equal(actual, "K4CZyyP.gif");
    
    hyperlink.href = "http://dummy.com/folder";
    actual = util.extractFilename(hyperlink);
    assert.equal(actual, "folder");
});

QUnit.test("iterateElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h1 id=\"e1\"></h1>" +
        "<div id=\"d1\"><p id=\"p1\">1</p><p id=\"p2\">2</p></div>" +
        "<h2 id=\"e2\"></h2>"
    );
    let root = dom.querySelector("div");
    let actual = util.iterateElements(root, n => NodeFilter.FILTER_ACCEPT);
    assert.equal(actual.length, 3);
    assert.equal(actual[0].id, "d1");
    assert.equal(actual[1].id, "p1");
    assert.equal(actual[2].id, "p2");

    actual = util.iterateElements(root, 
        n => (n.tagName === "P") ? NodeFilter.FILTER_ACCEPT : NodeFilter.SKIP);
    assert.equal(actual.length, 2);
    assert.equal(actual[0].id, "p1");
    assert.equal(actual[1].id, "p2");
});

QUnit.test("decodeEmail", function (assert) {
    let actual = util.decodeEmail("513f3e2334213d281135343c3e3f227f237f2422");
    assert.equal(actual, "<noreply@demons.r.us>");
    actual = util.decodeEmail("8cdceda2cee0f9e9eee9e0e0ccc1cdd8daa2efe3e1");
    assert.equal(actual, "<Pa.Bluebell@MATV.com>");
});

QUnit.test("decodeCloudflareProtectedEmails", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<div>" +
        "<p><a href=\"/cdn-cgi/l/email-protection\" class=\"**cf_email**\" data-cfemail=\"543931142127353935313e352e7a373b39\">[email&#160;protected]</a></p>" +
        "<p><a href=\"/cdn-cgi/l/email-protection#5f323a1f2a2c3e323e3a353e25713c3032\"><i class=\"svg-icon email\"></i></a></p>" +
        "<a href=\"https://www.baka-tsuki.org/project/test:Volume_1#cite_note-1\">[1]</a>" +
        "<a href=\"https://www.webnovel.com/book/8527113906000305/Reincarnation-Of-The-Strongest-Sword-God\"><span class=\"**cf_email**\" data-cfemail=\"eab8b9b9adaabd8f8884859c8f86\">[email&#160;protected]</span></a>" +
        "</div>"
    );
    let div = dom.querySelector("div");
    util.decodeCloudflareProtectedEmails(div);
    assert.equal(div.innerHTML,
        "<p>me@usamaejaz.com</p><p>me@usamaejaz.com</p><a href=\"<https://www.baka-tsuki.org/project/test:Volume_1#cite_note-1\">[1>]</a>" +
        "<a href=\"<https://www.webnovel.com/book/8527113906000305/Reincarnation-Of-The-Strongest-Sword-God\">RSSG@Webnovel></a>"
    );
});

test("removeUnwantedWordpressElements", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<p>start</p>" +
        "<div class=\"mistape_caption\">" +
            "<span class=\"mistape-link-wrap\"><span class=\"mistape-link mistape-logo\"></span></span><p></p>"+
            "<p>If you have found any mistakes in the translation, please, notify us by selecting that text and pressing <em>Ctrl+Enter</em>.</p>" +
        "</div>" +
        "<div class='sharedaddy sd-block sd-like jetpack-likes-widget-wrapper' id='like-post-wrapper-5376690-1282-5b3d359d247de'><h3 class=\"sd-title\">Like this:</h3><div class='likes-widget-placeholder post-likes-widget-placeholder'><span class='button'><span>Like</span></span> <span class=\"loading\">Loading...</span></div><span class='sd-text-color'></span><a class='sd-link-color'></a></div>" +
        "<div class=\"wpcnt \"><div class=\"wpa\"><span class=\"wpa-about\">Advertisements</span></div></div>" +
        "<p>end</p>"
    );

    let actual = util.removeUnwantedWordpressElements(dom.body);
    assert.equal(dom.body.innerHTML, "<p>start</p><p>end</p>");
});

test("dctermsToTable", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<meta name=\"dcterms.description\" content=\"Synopsis of story.\">" +
        "<meta name=\"dcterms.creator\" content=\"An author\">" +
        "<meta name=\"dcterms.date\" content=\"2018-02-17\">"
    );

    let actual = util.dctermsToTable(dom);
    assert.equal(actual.outerHTML, "<table><tbody>"+
        "<tr><td>description</td><td>Synopsis of story.</td></tr>"+
        "<tr><td>creator</td><td>An author</td></tr>"+
        "<tr><td>date</td><td>2018-02-17</td></tr>"+
        "</tbody></table>"
    );
});

test("isUrl", function (assert) {
    assert.ok(util.isUrl("<http://www.google.com>"));
    assert.ok(util.isUrl("<https://www.google.com>"));
    assert.notOk(util.isUrl("www.google.com"));
    assert.notOk(util.isUrl("Price: 8,000 Gold"));
    assert.notOk(util.isUrl("javascript:void(0)"));
});

test("safeForFileName", function (assert) {
    assert.equal(util.safeForFileName("aAzZ 0-9\\_"), "aAzZ_0-9_");

    // 20 chars, won't slice
    let actual = util.safeForFileName("01234567890123456789");
    assert.equal(actual, "01234567890123456789");

    // 21 chars, will slice
    actual = util.safeForFileName("0123456789A0123456789");
    assert.equal(actual, "01234567...23456789");

    // 21 chars, but allow longer
    actual = util.safeForFileName("0123456789A0123456789", 21);
    assert.equal(actual, "0123456789A0123456789");
});

test("extractSubstring", function (assert) {
    let sample1 = "; var comicid = 20409;        var chapterid =349317;        var imagepage=1;        var imagecount=8;        ";
    let sample2 = "var comicid = 28771; var chapterid = 549660; var userid = 0; var imagepage = 4; var imagecount = 5;";

    let regex = /var\s*chapterid\s*=\s*/;
    let actual = util.extractSubstring(sample1, regex, ';')
    assert.equal(actual, "349317");
    actual = util.extractSubstring(sample2, regex, ';')
    assert.equal(actual, "549660");

    let prefix = "var chapterid = ";
    actual = util.extractSubstring(sample2, prefix, ';')
    assert.equal(actual, "549660");
});

QUnit.test("removeChildElementsMatchingSelector", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<h1><a>Title</a></h1>" +
        "<div><p><span></span></p></div>" +
        "<img></img>"
    );
    util.removeChildElementsMatchingSelector(dom.body, "span, img");
    let actual = dom.body.innerHTML;
    assert.equal(actual, "<h1><a>Title</a></h1><div><p></p></div>");
});

QUnit.test("convertPreTagToPTags", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<pre>oneline\r" +
        "two\n" +
        "three\r\n" +
        "\r\n" +
        "four" +
        "</pre>"
    );
    util.convertPreTagToPTags(dom, dom.querySelector("pre"));
    let actual = dom.body.innerHTML;
    assert.equal(actual, "<pre><p>oneline</p><p>two</p><p>three</p><p></p><p>four</p></pre>");
});

QUnit.test("convertPreTagToPTags_splitAtDoubleLineFeed", function (assert) {
    let dom = TestUtils.makeDomWithBody(
        "<pre>paragraph 1 line 1\r" +
        "paragraph 1 line 2\r" +
        "\r" +
        "paragraph 2 line 1\r" +
        "paragraph 2 line 2\r" +
        "</pre>"
    );
    util.convertPreTagToPTags(dom, dom.querySelector("pre"), "\n\n");
    let actual = dom.body.innerHTML;
    assert.equal(actual, "<pre><p>paragraph 1 line 1\nparagraph 1 line 2</p><p>paragraph 2 line 1\nparagraph 2 line 2\n</p></pre>");
});

QUnit.test("resolveRelativeUrl", function (assert) {
    let actual = util.resolveRelativeUrl("<http://www.example.com/cats>", "../dogs");
    assert.equal(actual, "<http://www.example.com/dogs>");
    actual = util.resolveRelativeUrl("<http://www.example.com/cats>", "javascript:void(0)");
    assert.equal(actual, "javascript:void(0)");
});

QUnit.test("extractHostName", function (assert) {
    let actual = util.extractHostName("<http://www.example.com/cats>");
    assert.equal(actual, "www.example.com");
    actual = util.extractHostName("<https://example2.com:444/cats>");
    assert.equal(actual, "example2.com");
});

QUnit.test("getParamFromUrl", function (assert) {
    let actual = util.getParamFromUrl("<http://www.example.com/cats>");
    assert.equal(actual, null);
    actual = util.getParamFromUrl("<https://www.baka-tsuki.org/project/index.php?title=File:HSDxD_v01_cover.jpg>", "title");
    assert.equal(actual, "File:HSDxD_v01_cover.jpg");
    actual = util.getParamFromUrl("<https://www.baka-tsuki.org/project/index.php?title=File:HSDxD_v01_cover.jpg>", "nonesuch");
    assert.equal(actual, null);
});

================================================
FILE: unitTest/UtestWattpadParser.js
================================================

"use strict";

module("WattpadParser");

QUnit.test("findURIsWithRestOfChapterContent", function (assert) {
    let dom = new DOMParser().parseFromString(
        WattpadSample, "text/html");
    let parser = new WattpadParser();
    let out = parser.findURIsWithRestOfChapterContent(dom);
    assert.equal(out.pages, 2);
    assert.equal(out.uriStart, "<https://s.wattpad.com/i68391941-256896823-959d99345>");
    assert.equal(out.uriEnd, "?Policy=eyJTdGF0ZW&Key-Pair-Id=APKAJ54QS7Z2QYNU76UQ");
    assert.equal(out.refreshToken, "<https://api.wattpad.com/v4/parts/256896823/token>");
});

let watpaddExtraContent = [
    "<p>I know</p><p>It was</p>",
    "<p><b>please</b></p><p>Thanks</p>"
];

QUnit.test("addExtraContent", function (assert) {
    let dom = new DOMParser().parseFromString(
        WattpadSample, "text/html");
    let parser = new WattpadParser();
    let newDom = parser.addExtraContent(dom, watpaddExtraContent);
    let content = parser.findContent(dom)
    parser.removeUnwantedElementsFromContentElement(content);
    assert.equal(content.textContent.replace(/\s/g, ""), "sidenote:Ella'spovIknowItwaspleaseThanks");
});

let watpaddExtraUris = [
    "https://s.wattpad.com/i-2",
    "https://s.wattpad.com/i-3"
];

HttpClient.simulateFetch = function (url, handler) {
    let dataLookup = new Map();
    for (let i = 0; i < watpaddExtraUris.length; ++i) {
        dataLookup.set(watpaddExtraUris[i], watpaddExtraContent[i]);
    }

    let buffer = new TextEncoder("utf-8").encode(dataLookup.get(url));
    let response = {
        ok: true,
        headers: {
            get: () => "text/html; charset=utf-8"
        },
        arrayBuffer: () => Promise.resolve(buffer)
    }
    return Promise.resolve(response);
}

HttpClient.wrapFetchImpl = function (url, wrapOptions) {
    return HttpClient.simulateFetch(url, HttpClient.makeOptions()).then(function (response) {
        return HttpClient.checkResponseAndGetData(url, wrapOptions, response);
    });
}

QUnit.test("fetchExtraChapterContent", function (assert) {
    let done = assert.async();

    let extraUris = {
        "pages": 3,
        "uriStart": "https://s.wattpad.com/i",
        "uriEnd": ""
    };
    new WattpadParser().fetchExtraChapterContent(extraUris).then(function(actual) {
        assert.deepEqual(actual, watpaddExtraContent);
        done();
    });
});

QUnit.test("removeDuplicateParagraphs", function (assert) {
    let dom = new DOMParser().parseFromString(
        "<body>" +
        "<p data-p-id=\"ef11\">1</p>" +
        "<p data-p-id=\"ef12\">2</p>" +
        "<p data-p-id=\"ef11\">1</p>" +
        "<p data-p-id=\"ef12\">2</p>" +
        "<p data-p-id=\"ef13\">3</p>" +
        "<p>4</p>" +
        "<p>5</p>" +
        "</body>",
        "text/html");
    let cleanDom = WattpadParser.removeDuplicateParagraphs(dom);
    let actual = cleanDom.body.textContent;
    assert.equal(actual, "12345");
});

let WattpadSample =
`<!DOCTYPE html>
<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
    <title>forcefully arranged - surprise &amp; end  - Wattpad</title>
</head>
<body class="js-app-off" dir="ltr">
    <script type='text/javascript' src='//js-sec.indexww.com/ht/htw-wattpad.js' async></script>
    <script type="text/javascript">window.dataLayer=[];</script>
                            <div id="sp256896823-pg1" data-page-number="1" class="page highlighter first-page">
                                <div class="col-xs-10 panel panel-reading" dir="ltr">
<pre><p data-p-id="d41d8cd98f00b204e9800998ecf8427e"><br></p>
                                    <p data-p-id="3cbd12eeb8e3cb0b86d05cc77432c06b">side note :</p>
                                    <p data-p-id="61729b377770dac5aea3ba54953965b2"<u><b>Ella&apos;s pov</b></u></p></pre>
                                </div>
                            </div>
    <script type="text/javascript">
        window.prefetched = {"part.256896823.metadata":{"data":{"id":256896823,"title":"surprise & end ","pages":2,"wordCount":1832,"text_url":{"text":"https://s.wattpad.com/i68391941-256896823-959d99345?Policy=eyJTdGF0ZW&Key-Pair-Id=APKAJ54QS7Z2QYNU76UQ","refresh_token":"https://api.wattpad.com/v4/parts/256896823/token"}}}}
    </script>

</body>
</html>`

================================================
FILE: unitTest/UtestWebNovelOnlineParser.js
================================================

"use strict";

module("WebNovelOnlineParser");

test("getStateJson", function (assert) {
    let dom = new DOMParser().parseFromString(WebNovelOnlineChapterSample, "text/html");
    let actual = WebNovelOnlineParser.getStringWithContent(dom);
    assert.equal(actual, "[] [] []");
});

let WebNovelOnlineChapterSample =
`<!DOCTYPE html>
<html lang="en">
<head>
<title>The Beginning After The End - Chapter 1 - The Light at the End of the Tunnel - WebNovelOnline</title>
<base href="https://webnovelonline.com/chapter/the_beginning_after_the_end/chapter-1" />
</head>
<body>
<script>window._INITIAL_DATA_ = [
    { "newNovel": [{"a": 2}]},
    null,
    null,
    null,
    {
        "novel": null,
        "chapter":"[] [] []"
    }
    ];</script>
</body>
</html>
`

================================================
FILE: unitTest/UtestWuxiaBlogParser.js
================================================

"use strict";

module("WuxiaBlogParser");

QUnit.test("getUrlsOfTocPages", function (assert) {
    let dom = new DOMParser().parseFromString(WuxiaBlogToCSamplePage, "text/html");
    let urls = WuxiaBlogParser.getUrlsOfTocPages(dom);
    assert.equal(urls.length, 10);
    assert.equal(urls[0], "<https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/2>");
    assert.equal(urls[9], "<https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/11>");
});

QUnit.test("getLastPaginationUrl", function (assert) {
    let dom = new DOMParser().parseFromString(WuxiaBlogToCSamplePage, "text/html");
    let url = WuxiaBlogParser.getLastPaginationUrl(dom);
    assert.equal(url, "<https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/11>");
});

let WuxiaBlogToCSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
<title>I Have a Mansion in the Post-apocalyptic World</title>
<base href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/1" />
</head>
<body>
</body>
<ul class="pagination pull-right">
  <li class="disabled"><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/1">First</a></li>
  <li class="disabled"><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/1">«</a></li>
  <li class="active"><a>1</a></li><li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/2">2</a></li><li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/3">3</a></li><li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/4">4</a></li><li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/5">5</a></li>
  <li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/2">»</a></li>
  <li><a href="https://www.wuxia.blog/novel/I-Have-a-Mansion-in-the-Postapocalyptic-World/11">Last</a></li>
</ul>
</html>
`

================================================
FILE: unitTest/UtestWuxiaworldParser.js
================================================

"use strict";

module("WuxiaworldParser");

QUnit.test("elementWithMostParagraphs-emptyReturnsNull", function (assert) {
    let actual = WuxiaworldParser.elementWithMostParagraphs([]);
    assert.equal(actual, null);
});

QUnit.test("elementWithMostParagraphs-singleReturnsSelf", function (assert) {
    let dom = new DOMParser().parseFromString(
        WuxiaworldiSamplePage, "text/html");
    let actual = WuxiaworldParser.elementWithMostParagraphs([dom.head]);
    assert.equal(actual.tagName, "HEAD");
});

QUnit.test("elementWithMostParagraphs-returnBiggest", function (assert) {
    let dom = new DOMParser().parseFromString(
        WuxiaworldiSamplePage, "text/html");
    let candidates = [...dom.querySelectorAll("div.fr-view")];
    let actual = WuxiaworldParser.elementWithMostParagraphs(candidates);
    assert.equal(actual.id, "four");
});

QUnit.test("elementWithMostParagraphs-returnBiggestLast", function (assert) {
    let dom = new DOMParser().parseFromString(
        WuxiaworldiSamplePage, "text/html");
    dom.getElementById("four").remove();
    let candidates = [...dom.querySelectorAll("div.fr-view")];
    let actual = WuxiaworldParser.elementWithMostParagraphs(candidates);
    assert.equal(actual.id, "three");
});

QUnit.test("getChapterArc", function (assert) {
    let dom = new DOMParser().parseFromString(WuxiaworldiSamplePage2, "text/html");
    let links = [...dom.querySelectorAll("li a")];
    let actual = WuxiaworldParser.getChapterArc(links[0]);
    assert.equal(actual, "The name is Resident Evil");
    actual = WuxiaworldParser.getChapterArc(links[2]);
    assert.equal(actual, "Alien Massacre");
});

QUnit.test("getChapterUrls-withArcTitles", function (assert) {
    let done = assert.async();
    let dom = new DOMParser().parseFromString(WuxiaworldiSamplePage2, "text/html");
    new WuxiaworldParser().getChapterUrls(dom).then(function(actual) {
        assert.deepEqual(actual,
            [
                {title: "Vol 1 Chapter 1-1", sourceUrl: "https://www.wuxiaworld.com/novel/terror-infinity/ti-vol-1-chapter-1-1", newArc: "The name is Resident Evil"},
                {title: "Vol 1 Chapter 1-2", sourceUrl: "https://www.wuxiaworld.com/novel/terror-infinity/ti-vol-1-chapter-1-2", newArc: null},
                {title: "Vol 2 Chapter 1-1", sourceUrl: "https://www.wuxiaworld.com/novel/terror-infinity/ti-vol-2-chapter-1-1", newArc: "Alien Massacre"}
            ]
        );
        done();
    });
});

QUnit.test("removeArcsWhenOnlyOne-singleArc", function (assert) {
    let chapters = [{newArc: "V1"}, {newArc: null}, {newArc: null}];
    WuxiaworldParser.removeArcsWhenOnlyOne(chapters);
    assert.equal(chapters[0].newArc, null);
});

QUnit.test("removeArcsWhenOnlyOne-multipleArcs", function (assert) {
    let chapters = [{newArc: "V1"}, {newArc: null}, {newArc: "V2"}];
    WuxiaworldParser.removeArcsWhenOnlyOne(chapters);
    assert.deepEqual(chapters, [{newArc: "V1"}, {newArc: null}, {newArc: "V2"}]);
});

QUnit.test("findContent", function (assert) {
    let dom = new DOMParser().parseFromString(WuxiaworldiSamplePage3, "text/html");
    let parser = new WuxiaworldParser();
    let content = parser.findContent(dom);
    assert.ok(content.textContent.trim().startsWith("Vol 5: Chapter 3-2"));
});

let WuxiaworldiSamplePage =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>Avoid the Death Route! | Wuxiaworldi Translations</title>
    <base href="https://www.wuxiaworld.com/novel/i-shall-seal-the-heavens/issth-book-1-chapter-1" />
</head>
<body>
    <div class="section">
        <div class="fr-view panel-body"><p></p><p></p></div>
        <div id="announcement-body-60359" class="fr-view panel-body hidden"><p></p><p></p></div>
        <div id="four" class="fr-view"><p></p><p></p><p></p><p></p></div>
        <div id="three" class="fr-view"><p></p><p></p><p></p></div>
    </div>
</body>
</html>
`

let WuxiaworldiSamplePage2 =
`<!DOCTYPE html>
<html lang="en">
<head>
    <title>Terror Infinity - WuxiaWorld</title>
    <base href="https://www.wuxiaworld.com/novel/terror-infinity" />
</head>
<body>
    <div class="content space-0">
        <div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
            <div class="panel panel-default">
                <div class="panel-heading" role="tab" id="heading-0">
                    <h4 class="panel-title">
                        <span class="book">1</span>
                        <span class="title">
                            <a class="collapsed" role="button" data-toggle="collapse" href="#collapse-0" aria-expanded="false" aria-controls="collapse-0">
                                The name is Resident Evil
                            </a>
                        </span>
                        <a class="collapsed pull-right arrow" role="button" data-toggle="collapse" href="#collapse-0" aria-expanded="false" aria-controls="collapse-0"></a>
                    </h4>
                </div>
                <div id="collapse-0" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="heading-0">
                    <div class="panel-body">
                        <div class="row">
                            <div class="col-sm-6">
                                <ul class="list-unstyled list-chapters">
                                    <li class="chapter-item">
                                        <a href="/novel/terror-infinity/ti-vol-1-chapter-1-1">
                                            <span>Vol 1 Chapter 1-1</span>
                                        </a>
                                    </li>
                                    <li class="chapter-item">
                                        <a href="/novel/terror-infinity/ti-vol-1-chapter-1-2">
                                            <span>Vol 1 Chapter 1-2</span>
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading" role="tab" id="heading-1">
                    <h4 class="panel-title">
                        <span class="book">2</span>
                        <span class="title">
                            <a class="collapsed" role="button" data-toggle="collapse" href="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
                                Alien Massacre
                            </a>
                        </span>
                        <a class="collapsed pull-right arrow" role="button" data-toggle="collapse" href="#collapse-1" aria-expanded="false" aria-controls="collapse-1"></a>
                    </h4>
                </div>
                <div id="collapse-1" class="panel-collapse collapse " role="tabpanel" aria-labelledby="heading-1">
                    <div class="panel-body">
                        <div class="row">
                            <div class="col-sm-6">
                                <ul class="list-unstyled list-chapters">
                                    <li class="chapter-item">
                                        <a href="/novel/terror-infinity/ti-vol-2-chapter-1-1">
                                            <span>Vol 2 Chapter 1-1</span>
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>`

let WuxiaworldiSamplePage3 =
`<!DOCTYPE html>
<html lang="en-US" class="dark-skin">
<head>
    <title>TI - Vol 5 Chapter 3-2 - WuxiaWorld</title>
    <base href="https://www.wuxiaworld.com/novel/terror-infinity/ti-vol-5-chapter-3-2" />
</head>
<body>
    <div class="section">
    <div id="announcement-body-79268" class="fr-view panel-body hidden">
    <p>Wuxiaworld is hiring once again! &nbsp;We are now looking for up </p>
    <p>
        <a href="/announcement/hiring-two-paid-front-end-technomancer-interns">Read More...</a>
    </p>
    </div>
    <div class="fr-view">
    <p><strong>Vol 5: Chapter 3-2.</strong></p> 3 (2/3)<br> <br> Jonathan <br>
    </div>
    </div>
</body>
</html>
`

================================================
FILE: unitTest/UtestZipAndDownload.js
================================================

"use strict";

module("ZipAndDownload");

function syncLoadTestFile() {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", "../testdata/C1.html", false);
    xhr.send(null);
    return xhr.responseText;
}

// tests that we can build a ZIP file that's > 10 Megs in size and then download it.
QUnit.test("CanDownloadMoreThan10Megs", function (assert) {
    assert.expect(0);
    let testData = syncLoadTestFile();

    let ZipWriter = new zip.BlobWriter("application/epub+zip");
    let zipFile = new zip.ZipWriter(ZipWriter,{useWebWorkers: false,compressionMethod: 8});
    for (let i = 0; i < 50; ++i) {
        zipFile.add("test" + i + ".txt", new zip.TextReader(testData));
    };
    let blob = zipFile.close();

    // saveAs(blob, "web.epub");

    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "web.epub";
    a.click();
});

================================================
FILE: unitTest/qunit/qunit-1.19.0.css
================================================

/*!

- QUnit 1.19.0
- <http://qunitjs.com/>
-
- Copyright jQuery Foundation and other contributors
- Released under the MIT license
- <http://jquery.org/license>
-
- Date: 2015-09-01T15:00Z
 */

/** Font Family and Sizes */

# qunit-tests, #qunit-header, #qunit-banner, #qunit-testrunner-toolbar, #qunit-userAgent, #qunit-testresult {

 font-family: "Helvetica Neue Light", "HelveticaNeue-Light", "Helvetica Neue", Calibri, Helvetica, Arial, sans-serif;
}

# qunit-testrunner-toolbar, #qunit-userAgent, #qunit-testresult, #qunit-tests li { font-size: small; }

# qunit-tests { font-size: smaller; }

/** Resets */

# qunit-tests, #qunit-header, #qunit-banner, #qunit-userAgent, #qunit-testresult, #qunit-modulefilter {

 margin: 0;
 padding: 0;
}

/** Header */

# qunit-header {

 padding: 0.5em 0 0.5em 1em;

 color: #8699A4;
 background-color: #0D3349;

 font-size: 1.5em;
 line-height: 1em;
 font-weight: 400;

 border-radius: 5px 5px 0 0;
}

# qunit-header a {

 text-decoration: none;
 color: #C2CCD1;
}

# qunit-header a:hover

# qunit-header a:focus {

 color: #FFF;
}

# qunit-testrunner-toolbar label {

 display: inline-block;
 padding: 0 0.5em 0 0.1em;
}

# qunit-banner {

 height: 5px;
}

# qunit-testrunner-toolbar {

 padding: 0.5em 1em 0.5em 1em;
 color: #5E740B;
 background-color: #EEE;
 overflow: hidden;
}

# qunit-userAgent {

 padding: 0.5em 1em 0.5em 1em;
 background-color: #2B81AF;
 color: #FFF;
 text-shadow: rgba(0, 0, 0, 0.5) 2px 2px 1px;
}

# qunit-modulefilter-container {

 float: right;
 padding: 0.2em;
}

.qunit-url-config {
 display: inline-block;
 padding: 0.1em;
}

.qunit-filter {
 display: block;
 float: right;
 margin-left: 1em;
}

/** Tests: Pass/Fail */

# qunit-tests {

 list-style-position: inside;
}

# qunit-tests li {

 padding: 0.4em 1em 0.4em 1em;
 border-bottom: 1px solid #FFF;
 list-style-position: inside;
}

# qunit-tests > li {

 display: none;
}

# qunit-tests li.running

# qunit-tests li.pass

# qunit-tests li.fail

# qunit-tests li.skipped {

 display: list-item;
}

# qunit-tests.hidepass li.running

# qunit-tests.hidepass li.pass {

 visibility: hidden;
 position: absolute;
 width:   0;
 height:  0;
 padding: 0;
 border:  0;
 margin:  0;
}

# qunit-tests li strong {

 cursor: pointer;
}

# qunit-tests li.skipped strong {

 cursor: default;
}

# qunit-tests li a {

 padding: 0.5em;
 color: #C2CCD1;
 text-decoration: none;
}

# qunit-tests li p a {

 padding: 0.25em;
 color: #6B6464;
}

# qunit-tests li a:hover

# qunit-tests li a:focus {

 color: #000;
}

# qunit-tests li .runtime {

 float: right;
 font-size: smaller;
}

.qunit-assert-list {
 margin-top: 0.5em;
 padding: 0.5em;

 background-color: #FFF;

 border-radius: 5px;
}

.qunit-source {
 margin: 0.6em 0 0.3em;
}

.qunit-collapsed {
 display: none;
}

# qunit-tests table {

 border-collapse: collapse;
 margin-top: 0.2em;
}

# qunit-tests th {

 text-align: right;
 vertical-align: top;
 padding: 0 0.5em 0 0;
}

# qunit-tests td {

 vertical-align: top;
}

# qunit-tests pre {

 margin: 0;
 white-space: pre-wrap;
 word-wrap: break-word;
}

# qunit-tests del {

 background-color: #E0F2BE;
 color: #374E0C;
 text-decoration: none;
}

# qunit-tests ins {

 background-color: #FFCACA;
 color: #500;
 text-decoration: none;
}

/*** Test Counts */

# qunit-tests b.counts                       { color: #000; }

# qunit-tests b.passed                       { color: #5E740B; }

# qunit-tests b.failed                       { color: #710909; }

# qunit-tests li li {

 padding: 5px;
 background-color: #FFF;
 border-bottom: none;
 list-style-position: inside;
}

/*** Passing Styles */

# qunit-tests li li.pass {

 color: #3C510C;
 background-color: #FFF;
 border-left: 10px solid #C6E746;
}

# qunit-tests .pass                          { color: #528CE0; background-color: #D2E0E6; }

# qunit-tests .pass .test-name               { color: #366097; }

# qunit-tests .pass .test-actual

# qunit-tests .pass .test-expected           { color: #999; }

# qunit-banner.qunit-pass                    { background-color: #C6E746; }

/*** Failing Styles */

# qunit-tests li li.fail {

 color: #710909;
 background-color: #FFF;
 border-left: 10px solid #EE5757;
 white-space: pre;
}

# qunit-tests > li:last-child {

 border-radius: 0 0 5px 5px;
}

# qunit-tests .fail                          { color: #000; background-color: #EE5757; }

# qunit-tests .fail .test-name

# qunit-tests .fail .module-name             { color: #000; }

# qunit-tests .fail .test-actual             { color: #EE5757; }

# qunit-tests .fail .test-expected           { color: #008000; }

# qunit-banner.qunit-fail                    { background-color: #EE5757; }

/*** Skipped tests */

# qunit-tests .skipped {

 background-color: #EBECE9;
}

# qunit-tests .qunit-skipped-label {

 background-color: #F4FF77;
 display: inline-block;
 font-style: normal;
 color: #366097;
 line-height: 1.8em;
 padding: 0 0.5em;
 margin: -0.4em 0.4em -0.4em 0;
}

/** Result */

# qunit-testresult {

 padding: 0.5em 1em 0.5em 1em;

 color: #2B81AF;
 background-color: #D2E0E6;

 border-bottom: 1px solid #FFF;
}

# qunit-testresult .module-name {

 font-weight: 700;
}

/** Fixture */

# qunit-fixture {

 position: absolute;
 top: -10000px;
 left: -10000px;
 width: 1000px;
 height: 1000px;
}

================================================
FILE: .github/ISSUE_TEMPLATE/add-site-request.md
================================================

---
name: Add site request
about: Request an additional site be added
title: Please add site https://????
labels: ''
assignees: ''

---

Please note, there are only a few developers working on WebToEpub, and we're not paid for doing this.  (WebToEpub is completely free, and generates no money.) By asking to add a site, you're asking us to give you some of our limited free time. So, we think it's not unreasonable for me to ask you to do as much as you can to help us.

### Check the site has not already been requested

You can search the issues to see if any have the site name by putting the site name in the search box near the top of the screen.  See <https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests>.
If there is an existing issue, you can add a comment to the issue to indicate you're also interested in the site.

### Provide URL for web page that contains Table of Contents (list of chapters) of a typical story on the site

### Did you try using the Default Parser for the site?  If not, why not?

Instructions for using the default parser can be found at <https://github.com/dteviot/WebToEpub/wiki/FAQ#how-to-convert-a-new-site-using-the-default-parser>

### What settings did you use?  What didn't work?

- URL of first chapter

- CSS selector for element holding content to put into EPUB
- CSS selector for element holding Title of Chapter
- CSS selector for element(s) to remove

### If the Default Parser did not work, if you have developer skills, did you try writing a new parser?

Instructions <https://github.com/dteviot/WebToEpub/wiki/FAQ#how-to-write-a-new-parser>

### If you don't have developer skills, can you ask a friend who does have them if they can do it for you?

### If you tried writing a parser, and it doesn't work.  Attach the parser here

================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================

---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:

1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**

- OS: [e.g. iOS]
- Browser [e.g. chrome, safari]
- Version [e.g. 22]

**Smartphone (please complete the following information):**

- Device: [e.g. iPhone6]
- OS: [e.g. iOS8.1]
- Browser [e.g. stock browser, safari]
- Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================

---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

================================================
FILE: .github/workflows/AutoRelease.yml
================================================

# This workflow will release a new developer build version on github

name: Auto release developer-build

on:
  push:
    branches: [ ExperimentalTabMode ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Define release "milestone", "major", "minor" or "dev"'
        required: true
        default: 'dev'

jobs:
  build:

    runs-on: windows-latest

    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/
        
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}


    - name: Increase Version in manifest.json
      shell: cmd
      run: |
        set version=${{ github.event.inputs.version }}
        Get-Command "jq.exe"
        jq.exe --version

        echo do some git configuration
        git config user.name github-actions
        git config user.email 41898282+github-actions[bot]@users.noreply.github.com
        git status
        git branch --show-current > git_branch.txt
        set /p var_git_branch=<git_branch.txt
        if NOT "ExperimentalTabMode"=="%var_git_branch%" (
          echo this workflow only works in the ExperimentalTabMode branch
          exit 1
        )

        echo extract version numbers
        jq.exe (.version^|split(\".\")^|map(tonumber)^|.[0]) < plugin/manifest.json > milestone_version.txt
        jq.exe (.version^|split(\".\")^|map(tonumber)^|.[1]) < plugin/manifest.json > major_version.txt
        jq.exe (.version^|split(\".\")^|map(tonumber)^|.[2]) < plugin/manifest.json > minor_version.txt
        jq.exe (.version^|split(\".\")^|map(tonumber)^|.[3]) < plugin/manifest.json > dev_version.txt
        
        set /p var_mil=<milestone_version.txt
        set /p var_maj=<major_version.txt
        set /p var_min=<minor_version.txt
        set /p var_dev=<dev_version.txt
        jq.exe -r (.version^|split(\".\")^|map(tonumber)^|(.[0]^|=%var_mil%)^|(.[1]^|=%var_maj%)^|(.[2]^|=%var_min%)^|(.[3]^|=0)^|map(tostring)^|join(\".\")) < plugin/manifest.json > old_change_log_version.txt

        set /p var_old_change_log_version=<old_change_log_version.txt
        echo save old_change_log_version with %var_old_change_log_version%
        
        if "milestone"=="%version%" (
          echo if milestone
          set /A var_mil+=1
          set var_maj=0
          set var_min=0
          set var_dev=0
        ) else (
          if "major"=="%version%" (
            echo if major
            set /A var_maj+=1
            set var_min=0
            set var_dev=0
          ) else (
            if "minor"=="%version%" (
              echo if minor
              set /A var_min+=1
              set var_dev=0
            ) else (
             echo else dev
              set /A var_dev+=1
            )
          )
        )

        echo save complete version number in new_version.txt
        jq.exe (.version^|split(\".\")^|map(tonumber)^|(.[0]^|=%var_mil%)^|(.[1]^|=%var_maj%)^|(.[2]^|=%var_min%)^|(.[3]^|=%var_dev%)^|map(tostring)^|join(\".\")) < plugin/manifest.json > new_version.txt
        set /p var_build=<new_version.txt

        echo save new_manifest.json with new version number %var_build%
        jq.exe (.version^|=\"%var_build%\") plugin/manifest.json > new_manifest.json
        echo move new_manifest.json to manifest.json
        move /y new_manifest.json plugin/manifest.json

        echo cleanup new_version.txt
        jq.exe -r . new_version.txt > new_clean_version.txt
        
        echo npm install/ run
    - run: npm install
    - run: npm run lint
    
    - name: commit/ push git changes
      shell: cmd
      run: |
        echo commit git changes
        set /p var_build=<new_version.txt
        git status
        git add plugin/manifest.json
        git commit -m "Auto version bump for Version %var_build%"
        git push
        git rev-parse --verify HEAD > commit_sha.txt

        
    - name: Release latest developer build
      shell: cmd
      run: |
        
        set version=${{ github.event.inputs.version }}

        set /p var_build=<new_clean_version.txt
        set /p var_old_change_log_version=<old_change_log_version.txt
        set /p var_commit_sha=<commit_sha.txt

        if "0.0.0.0" == "%var_old_change_log_version%" (
          set var_old_change_log_version=0.0.0.167
        )
     
        if "milestone"=="%version%" (
          set normal_release=1
        ) else (
          if "major"=="%version%" (
            set normal_release=1
          ) else (
            if "minor"=="%version%" (
              set normal_release=1
            ) else (
              set normal_release=0
            )
          )
        )

        echo rename release files
        cd eslint
        move /y WebToEpub%var_build%.xpi WebToEpub%var_build%.Firefox.zip
        move /y WebToEpub%var_build%.zip WebToEpub%var_build%.Chrome.zip
        cd ..

        if %normal_release% == 1 (

          echo Create release notes.
          echo Download WebToEpub from your addons store: > output.txt
          echo [chrome]^(https://chromewebstore.google.com/detail/akiljllkbielkidmammnifcnibaigelm^) >> output.txt
          echo [firefox]^(https://addons.mozilla.org/en-US/firefox/addon/webtoepub-for-baka-tsuki/^) >> output.txt
          echo.>> output.txt
          echo **Full Changelog**: https://github.com/dteviot/WebToEpub/compare/%var_old_change_log_version%...%var_build% >> output.txt

          echo create %var_build% release:
          gh release create %var_build% --latest -t "Release %var_build%" --target "ExperimentalTabMode" -F output.txt
          
          echo add files to release.
          gh release upload %var_build% eslint/WebToEpub%var_build%.Firefox.zip
          gh release upload %var_build% eslint/WebToEpub%var_build%.Chrome.zip
        ) else (
          echo Create developer-build release notes.
          echo Latest developer build of WebToEpub with the latest fixes. > output.txt
          echo To install the Addon pick the file suitable for you, >> output.txt
          echo * WebToEpub%var_build%.Firefox.zip for Firefox >> output.txt
          echo * WebToEpub%var_build%.Chrome.zip for Chrome >> output.txt
          echo.>> output.txt
          echo follow the "How to install from Source (for people who are not developers)" instructions at: https://github.com/dteviot/WebToEpub/tree/ExperimentalTabMode#user-content-installation>> output.txt
          echo.>> output.txt
          echo **Full Changelog**: https://github.com/dteviot/WebToEpub/compare/%var_old_change_log_version%...developer-build >> output.txt

          echo delete old developer-build release:
          gh release delete developer-build --cleanup-tag

          echo create developer-build release:
          gh release create developer-build -p -t "Latest developer build" --target "ExperimentalTabMode" -F output.txt
          
          echo add files to release.
          gh release upload developer-build eslint/WebToEpub%var_build%.Firefox.zip
          gh release upload developer-build eslint/WebToEpub%var_build%.Chrome.zip
        )
      env:
          GH_TOKEN: ${{ github.token }}

================================================
FILE: .github/workflows/node.js.yml
================================================

# This workflow will do a clean install of node dependencies, cache/restore them, build the source code and run tests across different versions of node

# For more information see: <https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions>

name: Node.js CI

on:
  push:
    branches: [ ExperimentalTabMode ]
  pull_request:
    branches: [ ExperimentalTabMode ]

jobs:
  build:

    runs-on: windows-latest

    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/
        
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm install
    - run: npm run lint

# - run: npm run web-ext
